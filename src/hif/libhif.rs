/* automatically generated by rust-bindgen */

pub type ptrdiff_t = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed1 {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: ::std::os::raw::c_double,
}
impl ::std::clone::Clone for Struct_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type max_align_t = Struct_Unnamed1;
pub type gint8 = ::std::os::raw::c_char;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed2 {
    pub __val: [::std::os::raw::c_int; 2usize],
}
impl ::std::clone::Clone for Struct_Unnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __fsid_t = Struct_Unnamed2;
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
impl ::std::clone::Clone for Struct_timespec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_tm {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_tm {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_itimerspec {
    pub it_interval: Struct_timespec,
    pub it_value: Struct_timespec,
}
impl ::std::clone::Clone for Struct_itimerspec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_itimerspec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pid_t = __pid_t;
pub enum Struct___locale_data { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct___locale_struct {
    pub __locales: [*mut Struct___locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
impl ::std::clone::Clone for Struct___locale_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___locale_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __locale_t = *mut Struct___locale_struct;
pub type locale_t = __locale_t;
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = ::std::os::raw::c_float;
pub type gdouble = ::std::os::raw::c_double;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<extern "C" fn(a: gconstpointer, b: gconstpointer)
                              -> gint>;
pub type GCompareDataFunc =
    ::std::option::Option<extern "C" fn(a: gconstpointer, b: gconstpointer,
                                        user_data: gpointer) -> gint>;
pub type GEqualFunc =
    ::std::option::Option<extern "C" fn(a: gconstpointer, b: gconstpointer)
                              -> gboolean>;
pub type GDestroyNotify =
    ::std::option::Option<extern "C" fn(data: gpointer)>;
pub type GFunc =
    ::std::option::Option<extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc =
    ::std::option::Option<extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc =
    ::std::option::Option<extern "C" fn(key: gpointer, value: gpointer,
                                        user_data: gpointer)>;
pub type GFreeFunc = ::std::option::Option<extern "C" fn(data: gpointer)>;
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str: *const gchar,
                                               data: gpointer)
                              -> *const gchar>;
pub type GDoubleIEEE754 = Union__GDoubleIEEE754;
pub type GFloatIEEE754 = Union__GFloatIEEE754;
#[repr(C)]
#[derive(Copy)]
pub struct Union__GFloatIEEE754 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union__GFloatIEEE754 {
    pub unsafe fn v_float(&mut self) -> *mut gfloat {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mpn(&mut self) -> *mut Struct_Unnamed3 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union__GFloatIEEE754 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union__GFloatIEEE754 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union__GDoubleIEEE754 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union__GDoubleIEEE754 {
    pub unsafe fn v_double(&mut self) -> *mut gdouble {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mpn(&mut self) -> *mut Struct_Unnamed4 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union__GDoubleIEEE754 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union__GDoubleIEEE754 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTimeVal = Struct__GTimeVal;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
impl ::std::clone::Clone for Struct__GTimeVal {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTimeVal {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GBytes { }
pub type GBytes = Struct__GBytes;
pub type GArray = Struct__GArray;
pub type GByteArray = Struct__GByteArray;
pub type GPtrArray = Struct__GPtrArray;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GArray {
    pub data: *mut gchar,
    pub len: guint,
}
impl ::std::clone::Clone for Struct__GArray {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
impl ::std::clone::Clone for Struct__GByteArray {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GByteArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
impl ::std::clone::Clone for Struct__GPtrArray {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GPtrArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type va_list = __gnuc_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
pub type GError = Struct__GError;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
impl ::std::clone::Clone for Struct__GError {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GError {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed5 {
    G_USER_DIRECTORY_DESKTOP = 0,
    G_USER_DIRECTORY_DOCUMENTS = 1,
    G_USER_DIRECTORY_DOWNLOAD = 2,
    G_USER_DIRECTORY_MUSIC = 3,
    G_USER_DIRECTORY_PICTURES = 4,
    G_USER_DIRECTORY_PUBLIC_SHARE = 5,
    G_USER_DIRECTORY_TEMPLATES = 6,
    G_USER_DIRECTORY_VIDEOS = 7,
    G_USER_N_DIRECTORIES = 8,
}
pub type GUserDirectory = Enum_Unnamed5;
pub type GDebugKey = Struct__GDebugKey;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
impl ::std::clone::Clone for Struct__GDebugKey {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDebugKey {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed6 {
    G_FORMAT_SIZE_DEFAULT = 0,
    G_FORMAT_SIZE_LONG_FORMAT = 1,
    G_FORMAT_SIZE_IEC_UNITS = 2,
}
pub type GFormatSizeFlags = Enum_Unnamed6;
pub type GVoidFunc = ::std::option::Option<extern "C" fn()>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed7 { G_THREAD_ERROR_AGAIN = 0, }
pub type GThreadError = Enum_Unnamed7;
pub type GThreadFunc =
    ::std::option::Option<extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = Struct__GThread;
pub type GMutex = Union__GMutex;
pub type GRecMutex = Struct__GRecMutex;
pub type GRWLock = Struct__GRWLock;
pub type GCond = Struct__GCond;
pub type GPrivate = Struct__GPrivate;
pub type GOnce = Struct__GOnce;
#[repr(C)]
#[derive(Copy)]
pub struct Union__GMutex {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union__GMutex {
    pub unsafe fn p(&mut self) -> *mut gpointer {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn i(&mut self) -> *mut [guint; 2usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union__GMutex {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union__GMutex {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
impl ::std::clone::Clone for Struct__GRWLock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GRWLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
impl ::std::clone::Clone for Struct__GCond {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GCond {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
impl ::std::clone::Clone for Struct__GRecMutex {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GRecMutex {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
impl ::std::clone::Clone for Struct__GPrivate {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GPrivate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed8 {
    G_ONCE_STATUS_NOTCALLED = 0,
    G_ONCE_STATUS_PROGRESS = 1,
    G_ONCE_STATUS_READY = 2,
}
pub type GOnceStatus = Enum_Unnamed8;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
impl ::std::clone::Clone for Struct__GOnce {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GOnce {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GMutexLocker = ::std::os::raw::c_void;
pub enum Struct__GAsyncQueue { }
pub type GAsyncQueue = Struct__GAsyncQueue;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed9 {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
impl ::std::clone::Clone for Struct_Unnamed9 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __sigset_t = Struct_Unnamed9;
pub type sig_atomic_t = __sig_atomic_t;
pub type sigset_t = __sigset_t;
pub type uid_t = __uid_t;
#[repr(C)]
#[derive(Copy)]
pub struct Union_sigval {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_sigval {
    pub unsafe fn sival_int(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sival_ptr(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_sigval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_sigval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sigval_t = Union_sigval;
pub type __sigchld_clock_t = __clock_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed10 {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: Union_Unnamed11,
}
impl ::std::clone::Clone for Struct_Unnamed10 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed11 {
    pub _bindgen_data_: [u64; 14usize],
}
impl Union_Unnamed11 {
    pub unsafe fn _pad(&mut self) -> *mut [::std::os::raw::c_int; 28usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _kill(&mut self) -> *mut Struct_Unnamed12 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _timer(&mut self) -> *mut Struct_Unnamed13 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _rt(&mut self) -> *mut Struct_Unnamed14 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _sigchld(&mut self) -> *mut Struct_Unnamed15 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _sigfault(&mut self) -> *mut Struct_Unnamed16 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _sigpoll(&mut self) -> *mut Struct_Unnamed18 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _sigsys(&mut self) -> *mut Struct_Unnamed19 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed11 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed12 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
impl ::std::clone::Clone for Struct_Unnamed12 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed13 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: sigval_t,
}
impl ::std::clone::Clone for Struct_Unnamed13 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed14 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
impl ::std::clone::Clone for Struct_Unnamed14 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed15 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __sigchld_clock_t,
    pub si_stime: __sigchld_clock_t,
}
impl ::std::clone::Clone for Struct_Unnamed15 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed16 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub si_addr_bnd: Struct_Unnamed17,
}
impl ::std::clone::Clone for Struct_Unnamed16 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed16 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed17 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_Unnamed17 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed17 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed18 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed18 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed18 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed19 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed19 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed19 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type siginfo_t = Struct_Unnamed10;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed20 {
    SI_ASYNCNL = -60,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed21 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed22 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed23 { SEGV_MAPERR = 1, SEGV_ACCERR = 2, }
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed24 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed25 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed26 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6,
}
pub type pthread_attr_t = Union_pthread_attr_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: Union_Unnamed27,
}
impl ::std::clone::Clone for Struct_sigevent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigevent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed27 {
    pub _bindgen_data_: [u64; 6usize],
}
impl Union_Unnamed27 {
    pub unsafe fn _pad(&mut self) -> *mut [::std::os::raw::c_int; 12usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _tid(&mut self) -> *mut __pid_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _sigev_thread(&mut self) -> *mut Struct_Unnamed28 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed27 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed27 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed28 {
    pub _function: ::std::option::Option<extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
impl ::std::clone::Clone for Struct_Unnamed28 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed28 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sigevent_t = Struct_sigevent;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed29 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4,
}
pub type __sighandler_t =
    ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type sig_t = __sighandler_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigaction {
    pub __sigaction_handler: Union_Unnamed30,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct_sigaction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigaction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed30 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed30 {
    pub unsafe fn sa_handler(&mut self) -> *mut __sighandler_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sa_sigaction(&mut self)
     ->
         *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             ::std::os::raw::c_int,
                                                         arg2: *mut siginfo_t,
                                                         arg3:
                                                             *mut ::std::os::raw::c_void)> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed30 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed30 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub padding: [__uint32_t; 7usize],
}
impl ::std::clone::Clone for Struct__fpx_sw_bytes {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__fpx_sw_bytes {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
impl ::std::clone::Clone for Struct__fpreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__fpreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
impl ::std::clone::Clone for Struct__fpxreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__fpxreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__xmmreg {
    pub element: [__uint32_t; 4usize],
}
impl ::std::clone::Clone for Struct__xmmreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__xmmreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [Struct__fpxreg; 8usize],
    pub _xmm: [Struct__xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
impl ::std::clone::Clone for Struct__fpstate {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__fpstate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub _bindgen_data_1_: [u64; 1usize],
    pub __reserved1: [__uint64_t; 8usize],
}
impl Struct_sigcontext {
    pub unsafe fn fpstate(&mut self) -> *mut *mut Struct__fpstate {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __fpstate_word(&mut self) -> *mut __uint64_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Struct_sigcontext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigcontext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub reserved1: [__uint64_t; 2usize],
    pub reserved2: [__uint64_t; 5usize],
}
impl ::std::clone::Clone for Struct__xsave_hdr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__xsave_hdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
impl ::std::clone::Clone for Struct__ymmh_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__ymmh_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__xstate {
    pub fpstate: Struct__fpstate,
    pub xstate_hdr: Struct__xsave_hdr,
    pub ymmh: Struct__ymmh_state,
}
impl ::std::clone::Clone for Struct__xstate {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__xstate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_sigstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed31 { SS_ONSTACK = 1, SS_DISABLE = 2, }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: size_t,
}
impl ::std::clone::Clone for Struct_sigaltstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigaltstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type stack_t = Struct_sigaltstack;
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct__libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
impl ::std::clone::Clone for Struct__libc_fpxreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__libc_fpxreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
impl ::std::clone::Clone for Struct__libc_xmmreg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__libc_xmmreg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [Struct__libc_fpxreg; 8usize],
    pub _xmm: [Struct__libc_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
impl ::std::clone::Clone for Struct__libc_fpstate {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__libc_fpstate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fpregset_t = *mut Struct__libc_fpstate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed32 {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
impl ::std::clone::Clone for Struct_Unnamed32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mcontext_t = Struct_Unnamed32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut Struct_ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: __sigset_t,
    pub __fpregs_mem: Struct__libc_fpstate,
}
impl ::std::clone::Clone for Struct_ucontext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ucontext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ucontext_t = Struct_ucontext;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Union_pthread_attr_t {
    pub _bindgen_data_: [u64; 7usize],
}
impl Union_pthread_attr_t {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_pthread_attr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___pthread_internal_list {
    pub __prev: *mut Struct___pthread_internal_list,
    pub __next: *mut Struct___pthread_internal_list,
}
impl ::std::clone::Clone for Struct___pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___pthread_internal_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_list_t = Struct___pthread_internal_list;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed33 {
    pub _bindgen_data_: [u64; 5usize],
}
impl Union_Unnamed33 {
    pub unsafe fn __data(&mut self) -> *mut Struct___pthread_mutex_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 40usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed33 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed33 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl ::std::clone::Clone for Struct___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___pthread_mutex_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_mutex_t = Union_Unnamed33;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed34 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed34 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed34 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed34 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_mutexattr_t = Union_Unnamed34;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed35 {
    pub _bindgen_data_: [u64; 6usize],
}
impl Union_Unnamed35 {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed36 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 48usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed35 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed35 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed36 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed36 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed36 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_cond_t = Union_Unnamed35;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed37 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed37 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed37 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed37 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_condattr_t = Union_Unnamed37;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed38 {
    pub _bindgen_data_: [u64; 7usize],
}
impl Union_Unnamed38 {
    pub unsafe fn __data(&mut self) -> *mut Struct_Unnamed39 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 56usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed38 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed38 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed39 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_char,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed39 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed39 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_rwlock_t = Union_Unnamed38;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed40 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed40 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed40 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed40 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_rwlockattr_t = Union_Unnamed40;
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed41 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed41 {
    pub unsafe fn __size(&mut self)
     -> *mut [::std::os::raw::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed41 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed41 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_barrier_t = Union_Unnamed41;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed42 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed42 {
    pub unsafe fn __size(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __align(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed42 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed42 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pthread_barrierattr_t = Union_Unnamed42;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed43 {
    G_BOOKMARK_FILE_ERROR_INVALID_URI = 0,
    G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1,
    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2,
    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3,
    G_BOOKMARK_FILE_ERROR_READ = 4,
    G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5,
    G_BOOKMARK_FILE_ERROR_WRITE = 6,
    G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7,
}
pub type GBookmarkFileError = Enum_Unnamed43;
pub enum Struct__GBookmarkFile { }
pub type GBookmarkFile = Struct__GBookmarkFile;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed44 {
    G_CHECKSUM_MD5 = 0,
    G_CHECKSUM_SHA1 = 1,
    G_CHECKSUM_SHA256 = 2,
    G_CHECKSUM_SHA512 = 3,
}
pub type GChecksumType = Enum_Unnamed44;
pub enum Struct__GChecksum { }
pub type GChecksum = Struct__GChecksum;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed45 {
    G_CONVERT_ERROR_NO_CONVERSION = 0,
    G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1,
    G_CONVERT_ERROR_FAILED = 2,
    G_CONVERT_ERROR_PARTIAL_INPUT = 3,
    G_CONVERT_ERROR_BAD_URI = 4,
    G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5,
    G_CONVERT_ERROR_NO_MEMORY = 6,
}
pub type GConvertError = Enum_Unnamed45;
pub enum Struct__GIConv { }
pub type GIConv = *mut Struct__GIConv;
pub enum Struct__GData { }
pub type GData = Struct__GData;
pub type GDataForeachFunc =
    ::std::option::Option<extern "C" fn(key_id: GQuark, data: gpointer,
                                        user_data: gpointer)>;
pub type GDuplicateFunc =
    ::std::option::Option<extern "C" fn(data: gpointer, user_data: gpointer)
                              -> gpointer>;
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = Struct__GDate;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed46 { G_DATE_DAY = 0, G_DATE_MONTH = 1, G_DATE_YEAR = 2, }
pub type GDateDMY = Enum_Unnamed46;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed47 {
    G_DATE_BAD_WEEKDAY = 0,
    G_DATE_MONDAY = 1,
    G_DATE_TUESDAY = 2,
    G_DATE_WEDNESDAY = 3,
    G_DATE_THURSDAY = 4,
    G_DATE_FRIDAY = 5,
    G_DATE_SATURDAY = 6,
    G_DATE_SUNDAY = 7,
}
pub type GDateWeekday = Enum_Unnamed47;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed48 {
    G_DATE_BAD_MONTH = 0,
    G_DATE_JANUARY = 1,
    G_DATE_FEBRUARY = 2,
    G_DATE_MARCH = 3,
    G_DATE_APRIL = 4,
    G_DATE_MAY = 5,
    G_DATE_JUNE = 6,
    G_DATE_JULY = 7,
    G_DATE_AUGUST = 8,
    G_DATE_SEPTEMBER = 9,
    G_DATE_OCTOBER = 10,
    G_DATE_NOVEMBER = 11,
    G_DATE_DECEMBER = 12,
}
pub type GDateMonth = Enum_Unnamed48;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDate {
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
    pub _bindgen_bitfield_5_: guint,
    pub _bindgen_bitfield_6_: guint,
}
impl ::std::clone::Clone for Struct__GDate {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GTimeZone { }
pub type GTimeZone = Struct__GTimeZone;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed49 {
    G_TIME_TYPE_STANDARD = 0,
    G_TIME_TYPE_DAYLIGHT = 1,
    G_TIME_TYPE_UNIVERSAL = 2,
}
pub type GTimeType = Enum_Unnamed49;
pub type GTimeSpan = gint64;
pub enum Struct__GDateTime { }
pub type GDateTime = Struct__GDateTime;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
impl ::std::clone::Clone for Struct_dirent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dirent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed50 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14,
}
pub enum Struct___dirstream { }
pub type DIR = Struct___dirstream;
pub enum Struct__GDir { }
pub type GDir = Struct__GDir;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed51 {
    G_FILE_ERROR_EXIST = 0,
    G_FILE_ERROR_ISDIR = 1,
    G_FILE_ERROR_ACCES = 2,
    G_FILE_ERROR_NAMETOOLONG = 3,
    G_FILE_ERROR_NOENT = 4,
    G_FILE_ERROR_NOTDIR = 5,
    G_FILE_ERROR_NXIO = 6,
    G_FILE_ERROR_NODEV = 7,
    G_FILE_ERROR_ROFS = 8,
    G_FILE_ERROR_TXTBSY = 9,
    G_FILE_ERROR_FAULT = 10,
    G_FILE_ERROR_LOOP = 11,
    G_FILE_ERROR_NOSPC = 12,
    G_FILE_ERROR_NOMEM = 13,
    G_FILE_ERROR_MFILE = 14,
    G_FILE_ERROR_NFILE = 15,
    G_FILE_ERROR_BADF = 16,
    G_FILE_ERROR_INVAL = 17,
    G_FILE_ERROR_PIPE = 18,
    G_FILE_ERROR_AGAIN = 19,
    G_FILE_ERROR_INTR = 20,
    G_FILE_ERROR_IO = 21,
    G_FILE_ERROR_PERM = 22,
    G_FILE_ERROR_NOSYS = 23,
    G_FILE_ERROR_FAILED = 24,
}
pub type GFileError = Enum_Unnamed51;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed52 {
    G_FILE_TEST_IS_REGULAR = 1,
    G_FILE_TEST_IS_SYMLINK = 2,
    G_FILE_TEST_IS_DIR = 4,
    G_FILE_TEST_IS_EXECUTABLE = 8,
    G_FILE_TEST_EXISTS = 16,
}
pub type GFileTest = Enum_Unnamed52;
pub type GMemVTable = Struct__GMemVTable;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMemVTable {
    pub malloc: ::std::option::Option<extern "C" fn(n_bytes: gsize)
                                          -> gpointer>,
    pub realloc: ::std::option::Option<extern "C" fn(mem: gpointer,
                                                     n_bytes: gsize)
                                           -> gpointer>,
    pub free: ::std::option::Option<extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<extern "C" fn(n_blocks: gsize,
                                                    n_block_bytes: gsize)
                                          -> gpointer>,
    pub try_malloc: ::std::option::Option<extern "C" fn(n_bytes: gsize)
                                              -> gpointer>,
    pub try_realloc: ::std::option::Option<extern "C" fn(mem: gpointer,
                                                         n_bytes: gsize)
                                               -> gpointer>,
}
impl ::std::clone::Clone for Struct__GMemVTable {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMemVTable {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GNode = Struct__GNode;
pub const G_TRAVERSE_MASK: Enum_Unnamed53 = Enum_Unnamed53::G_TRAVERSE_ALL;
pub const G_TRAVERSE_LEAFS: Enum_Unnamed53 =
    Enum_Unnamed53::G_TRAVERSE_LEAVES;
pub const G_TRAVERSE_NON_LEAFS: Enum_Unnamed53 =
    Enum_Unnamed53::G_TRAVERSE_NON_LEAVES;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed53 {
    G_TRAVERSE_LEAVES = 1,
    G_TRAVERSE_NON_LEAVES = 2,
    G_TRAVERSE_ALL = 3,
}
pub type GTraverseFlags = Enum_Unnamed53;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed54 {
    G_IN_ORDER = 0,
    G_PRE_ORDER = 1,
    G_POST_ORDER = 2,
    G_LEVEL_ORDER = 3,
}
pub type GTraverseType = Enum_Unnamed54;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode,
                                               data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode,
                                               data: gpointer)>;
pub type GCopyFunc =
    ::std::option::Option<extern "C" fn(src: gconstpointer, data: gpointer)
                              -> gpointer>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
impl ::std::clone::Clone for Struct__GNode {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GNode {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GList = Struct__GList;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
impl ::std::clone::Clone for Struct__GList {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GList {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GHashTable { }
pub type GHashTable = Struct__GHashTable;
pub type GHRFunc =
    ::std::option::Option<extern "C" fn(key: gpointer, value: gpointer,
                                        user_data: gpointer) -> gboolean>;
pub type GHashTableIter = Struct__GHashTableIter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
impl ::std::clone::Clone for Struct__GHashTableIter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GHashTableIter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GHmac { }
pub type GHmac = Struct__GHmac;
pub type GHook = Struct__GHook;
pub type GHookList = Struct__GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook,
                                               sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook,
                                               data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook,
                                               marshal_data: gpointer)>;
pub type GHookCheckMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook,
                                               marshal_data: gpointer)
                              -> gboolean>;
pub type GHookFunc = ::std::option::Option<extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc =
    ::std::option::Option<extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList,
                                               hook: *mut GHook)>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed55 {
    G_HOOK_FLAG_ACTIVE = 1,
    G_HOOK_FLAG_IN_CALL = 2,
    G_HOOK_FLAG_MASK = 15,
}
pub type GHookFlagMask = Enum_Unnamed55;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GHookList {
    pub seq_id: gulong,
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
impl ::std::clone::Clone for Struct__GHookList {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GHookList {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
impl ::std::clone::Clone for Struct__GHook {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GHook {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GPollFD = Struct__GPollFD;
pub type GPollFunc =
    ::std::option::Option<unsafe extern "C" fn(ufds: *mut GPollFD,
                                               nfsd: guint, timeout_: gint)
                              -> gint>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
impl ::std::clone::Clone for Struct__GPollFD {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GPollFD {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSList = Struct__GSList;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
impl ::std::clone::Clone for Struct__GSList {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSList {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed56 {
    G_IO_IN = 1,
    G_IO_OUT = 4,
    G_IO_PRI = 2,
    G_IO_ERR = 8,
    G_IO_HUP = 16,
    G_IO_NVAL = 32,
}
pub type GIOCondition = Enum_Unnamed56;
pub enum Struct__GMainContext { }
pub type GMainContext = Struct__GMainContext;
pub enum Struct__GMainLoop { }
pub type GMainLoop = Struct__GMainLoop;
pub type GSource = Struct__GSource;
pub enum Struct__GSourcePrivate { }
pub type GSourcePrivate = Struct__GSourcePrivate;
pub type GSourceCallbackFuncs = Struct__GSourceCallbackFuncs;
pub type GSourceFuncs = Struct__GSourceFuncs;
pub type GSourceFunc =
    ::std::option::Option<extern "C" fn(user_data: gpointer) -> gboolean>;
pub type GChildWatchFunc =
    ::std::option::Option<extern "C" fn(pid: GPid, status: gint,
                                        user_data: gpointer)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub _priv: *mut GSourcePrivate,
}
impl ::std::clone::Clone for Struct__GSource {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSource {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSourceCallbackFuncs {
    pub _ref: ::std::option::Option<extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer,
                                                        source: *mut GSource,
                                                        func:
                                                            *mut GSourceFunc,
                                                        data: *mut gpointer)>,
}
impl ::std::clone::Clone for Struct__GSourceCallbackFuncs {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSourceCallbackFuncs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSourceDummyMarshal = ::std::option::Option<extern "C" fn()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSourceFuncs {
    pub prepare: ::std::option::Option<unsafe extern "C" fn(source:
                                                                *mut GSource,
                                                            timeout_:
                                                                *mut gint)
                                           -> gboolean>,
    pub check: ::std::option::Option<unsafe extern "C" fn(source:
                                                              *mut GSource)
                                         -> gboolean>,
    pub dispatch: ::std::option::Option<unsafe extern "C" fn(source:
                                                                 *mut GSource,
                                                             callback:
                                                                 GSourceFunc,
                                                             user_data:
                                                                 gpointer)
                                            -> gboolean>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source:
                                                                 *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
impl ::std::clone::Clone for Struct__GSourceFuncs {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSourceFuncs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type gunichar = guint32;
pub type gunichar2 = guint16;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed57 {
    G_UNICODE_CONTROL = 0,
    G_UNICODE_FORMAT = 1,
    G_UNICODE_UNASSIGNED = 2,
    G_UNICODE_PRIVATE_USE = 3,
    G_UNICODE_SURROGATE = 4,
    G_UNICODE_LOWERCASE_LETTER = 5,
    G_UNICODE_MODIFIER_LETTER = 6,
    G_UNICODE_OTHER_LETTER = 7,
    G_UNICODE_TITLECASE_LETTER = 8,
    G_UNICODE_UPPERCASE_LETTER = 9,
    G_UNICODE_SPACING_MARK = 10,
    G_UNICODE_ENCLOSING_MARK = 11,
    G_UNICODE_NON_SPACING_MARK = 12,
    G_UNICODE_DECIMAL_NUMBER = 13,
    G_UNICODE_LETTER_NUMBER = 14,
    G_UNICODE_OTHER_NUMBER = 15,
    G_UNICODE_CONNECT_PUNCTUATION = 16,
    G_UNICODE_DASH_PUNCTUATION = 17,
    G_UNICODE_CLOSE_PUNCTUATION = 18,
    G_UNICODE_FINAL_PUNCTUATION = 19,
    G_UNICODE_INITIAL_PUNCTUATION = 20,
    G_UNICODE_OTHER_PUNCTUATION = 21,
    G_UNICODE_OPEN_PUNCTUATION = 22,
    G_UNICODE_CURRENCY_SYMBOL = 23,
    G_UNICODE_MODIFIER_SYMBOL = 24,
    G_UNICODE_MATH_SYMBOL = 25,
    G_UNICODE_OTHER_SYMBOL = 26,
    G_UNICODE_LINE_SEPARATOR = 27,
    G_UNICODE_PARAGRAPH_SEPARATOR = 28,
    G_UNICODE_SPACE_SEPARATOR = 29,
}
pub type GUnicodeType = Enum_Unnamed57;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed58 {
    G_UNICODE_BREAK_MANDATORY = 0,
    G_UNICODE_BREAK_CARRIAGE_RETURN = 1,
    G_UNICODE_BREAK_LINE_FEED = 2,
    G_UNICODE_BREAK_COMBINING_MARK = 3,
    G_UNICODE_BREAK_SURROGATE = 4,
    G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5,
    G_UNICODE_BREAK_INSEPARABLE = 6,
    G_UNICODE_BREAK_NON_BREAKING_GLUE = 7,
    G_UNICODE_BREAK_CONTINGENT = 8,
    G_UNICODE_BREAK_SPACE = 9,
    G_UNICODE_BREAK_AFTER = 10,
    G_UNICODE_BREAK_BEFORE = 11,
    G_UNICODE_BREAK_BEFORE_AND_AFTER = 12,
    G_UNICODE_BREAK_HYPHEN = 13,
    G_UNICODE_BREAK_NON_STARTER = 14,
    G_UNICODE_BREAK_OPEN_PUNCTUATION = 15,
    G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16,
    G_UNICODE_BREAK_QUOTATION = 17,
    G_UNICODE_BREAK_EXCLAMATION = 18,
    G_UNICODE_BREAK_IDEOGRAPHIC = 19,
    G_UNICODE_BREAK_NUMERIC = 20,
    G_UNICODE_BREAK_INFIX_SEPARATOR = 21,
    G_UNICODE_BREAK_SYMBOL = 22,
    G_UNICODE_BREAK_ALPHABETIC = 23,
    G_UNICODE_BREAK_PREFIX = 24,
    G_UNICODE_BREAK_POSTFIX = 25,
    G_UNICODE_BREAK_COMPLEX_CONTEXT = 26,
    G_UNICODE_BREAK_AMBIGUOUS = 27,
    G_UNICODE_BREAK_UNKNOWN = 28,
    G_UNICODE_BREAK_NEXT_LINE = 29,
    G_UNICODE_BREAK_WORD_JOINER = 30,
    G_UNICODE_BREAK_HANGUL_L_JAMO = 31,
    G_UNICODE_BREAK_HANGUL_V_JAMO = 32,
    G_UNICODE_BREAK_HANGUL_T_JAMO = 33,
    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34,
    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35,
    G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36,
    G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37,
    G_UNICODE_BREAK_HEBREW_LETTER = 38,
    G_UNICODE_BREAK_REGIONAL_INDICATOR = 39,
}
pub type GUnicodeBreakType = Enum_Unnamed58;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed59 {
    G_UNICODE_SCRIPT_INVALID_CODE = -1,
    G_UNICODE_SCRIPT_COMMON = 0,
    G_UNICODE_SCRIPT_INHERITED = 1,
    G_UNICODE_SCRIPT_ARABIC = 2,
    G_UNICODE_SCRIPT_ARMENIAN = 3,
    G_UNICODE_SCRIPT_BENGALI = 4,
    G_UNICODE_SCRIPT_BOPOMOFO = 5,
    G_UNICODE_SCRIPT_CHEROKEE = 6,
    G_UNICODE_SCRIPT_COPTIC = 7,
    G_UNICODE_SCRIPT_CYRILLIC = 8,
    G_UNICODE_SCRIPT_DESERET = 9,
    G_UNICODE_SCRIPT_DEVANAGARI = 10,
    G_UNICODE_SCRIPT_ETHIOPIC = 11,
    G_UNICODE_SCRIPT_GEORGIAN = 12,
    G_UNICODE_SCRIPT_GOTHIC = 13,
    G_UNICODE_SCRIPT_GREEK = 14,
    G_UNICODE_SCRIPT_GUJARATI = 15,
    G_UNICODE_SCRIPT_GURMUKHI = 16,
    G_UNICODE_SCRIPT_HAN = 17,
    G_UNICODE_SCRIPT_HANGUL = 18,
    G_UNICODE_SCRIPT_HEBREW = 19,
    G_UNICODE_SCRIPT_HIRAGANA = 20,
    G_UNICODE_SCRIPT_KANNADA = 21,
    G_UNICODE_SCRIPT_KATAKANA = 22,
    G_UNICODE_SCRIPT_KHMER = 23,
    G_UNICODE_SCRIPT_LAO = 24,
    G_UNICODE_SCRIPT_LATIN = 25,
    G_UNICODE_SCRIPT_MALAYALAM = 26,
    G_UNICODE_SCRIPT_MONGOLIAN = 27,
    G_UNICODE_SCRIPT_MYANMAR = 28,
    G_UNICODE_SCRIPT_OGHAM = 29,
    G_UNICODE_SCRIPT_OLD_ITALIC = 30,
    G_UNICODE_SCRIPT_ORIYA = 31,
    G_UNICODE_SCRIPT_RUNIC = 32,
    G_UNICODE_SCRIPT_SINHALA = 33,
    G_UNICODE_SCRIPT_SYRIAC = 34,
    G_UNICODE_SCRIPT_TAMIL = 35,
    G_UNICODE_SCRIPT_TELUGU = 36,
    G_UNICODE_SCRIPT_THAANA = 37,
    G_UNICODE_SCRIPT_THAI = 38,
    G_UNICODE_SCRIPT_TIBETAN = 39,
    G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40,
    G_UNICODE_SCRIPT_YI = 41,
    G_UNICODE_SCRIPT_TAGALOG = 42,
    G_UNICODE_SCRIPT_HANUNOO = 43,
    G_UNICODE_SCRIPT_BUHID = 44,
    G_UNICODE_SCRIPT_TAGBANWA = 45,
    G_UNICODE_SCRIPT_BRAILLE = 46,
    G_UNICODE_SCRIPT_CYPRIOT = 47,
    G_UNICODE_SCRIPT_LIMBU = 48,
    G_UNICODE_SCRIPT_OSMANYA = 49,
    G_UNICODE_SCRIPT_SHAVIAN = 50,
    G_UNICODE_SCRIPT_LINEAR_B = 51,
    G_UNICODE_SCRIPT_TAI_LE = 52,
    G_UNICODE_SCRIPT_UGARITIC = 53,
    G_UNICODE_SCRIPT_NEW_TAI_LUE = 54,
    G_UNICODE_SCRIPT_BUGINESE = 55,
    G_UNICODE_SCRIPT_GLAGOLITIC = 56,
    G_UNICODE_SCRIPT_TIFINAGH = 57,
    G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58,
    G_UNICODE_SCRIPT_OLD_PERSIAN = 59,
    G_UNICODE_SCRIPT_KHAROSHTHI = 60,
    G_UNICODE_SCRIPT_UNKNOWN = 61,
    G_UNICODE_SCRIPT_BALINESE = 62,
    G_UNICODE_SCRIPT_CUNEIFORM = 63,
    G_UNICODE_SCRIPT_PHOENICIAN = 64,
    G_UNICODE_SCRIPT_PHAGS_PA = 65,
    G_UNICODE_SCRIPT_NKO = 66,
    G_UNICODE_SCRIPT_KAYAH_LI = 67,
    G_UNICODE_SCRIPT_LEPCHA = 68,
    G_UNICODE_SCRIPT_REJANG = 69,
    G_UNICODE_SCRIPT_SUNDANESE = 70,
    G_UNICODE_SCRIPT_SAURASHTRA = 71,
    G_UNICODE_SCRIPT_CHAM = 72,
    G_UNICODE_SCRIPT_OL_CHIKI = 73,
    G_UNICODE_SCRIPT_VAI = 74,
    G_UNICODE_SCRIPT_CARIAN = 75,
    G_UNICODE_SCRIPT_LYCIAN = 76,
    G_UNICODE_SCRIPT_LYDIAN = 77,
    G_UNICODE_SCRIPT_AVESTAN = 78,
    G_UNICODE_SCRIPT_BAMUM = 79,
    G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80,
    G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83,
    G_UNICODE_SCRIPT_JAVANESE = 84,
    G_UNICODE_SCRIPT_KAITHI = 85,
    G_UNICODE_SCRIPT_LISU = 86,
    G_UNICODE_SCRIPT_MEETEI_MAYEK = 87,
    G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88,
    G_UNICODE_SCRIPT_OLD_TURKIC = 89,
    G_UNICODE_SCRIPT_SAMARITAN = 90,
    G_UNICODE_SCRIPT_TAI_THAM = 91,
    G_UNICODE_SCRIPT_TAI_VIET = 92,
    G_UNICODE_SCRIPT_BATAK = 93,
    G_UNICODE_SCRIPT_BRAHMI = 94,
    G_UNICODE_SCRIPT_MANDAIC = 95,
    G_UNICODE_SCRIPT_CHAKMA = 96,
    G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97,
    G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98,
    G_UNICODE_SCRIPT_MIAO = 99,
    G_UNICODE_SCRIPT_SHARADA = 100,
    G_UNICODE_SCRIPT_SORA_SOMPENG = 101,
    G_UNICODE_SCRIPT_TAKRI = 102,
    G_UNICODE_SCRIPT_BASSA_VAH = 103,
    G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104,
    G_UNICODE_SCRIPT_DUPLOYAN = 105,
    G_UNICODE_SCRIPT_ELBASAN = 106,
    G_UNICODE_SCRIPT_GRANTHA = 107,
    G_UNICODE_SCRIPT_KHOJKI = 108,
    G_UNICODE_SCRIPT_KHUDAWADI = 109,
    G_UNICODE_SCRIPT_LINEAR_A = 110,
    G_UNICODE_SCRIPT_MAHAJANI = 111,
    G_UNICODE_SCRIPT_MANICHAEAN = 112,
    G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113,
    G_UNICODE_SCRIPT_MODI = 114,
    G_UNICODE_SCRIPT_MRO = 115,
    G_UNICODE_SCRIPT_NABATAEAN = 116,
    G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117,
    G_UNICODE_SCRIPT_OLD_PERMIC = 118,
    G_UNICODE_SCRIPT_PAHAWH_HMONG = 119,
    G_UNICODE_SCRIPT_PALMYRENE = 120,
    G_UNICODE_SCRIPT_PAU_CIN_HAU = 121,
    G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122,
    G_UNICODE_SCRIPT_SIDDHAM = 123,
    G_UNICODE_SCRIPT_TIRHUTA = 124,
    G_UNICODE_SCRIPT_WARANG_CITI = 125,
}
pub type GUnicodeScript = Enum_Unnamed59;
pub const G_NORMALIZE_NFD: Enum_Unnamed60 =
    Enum_Unnamed60::G_NORMALIZE_DEFAULT;
pub const G_NORMALIZE_NFC: Enum_Unnamed60 =
    Enum_Unnamed60::G_NORMALIZE_DEFAULT_COMPOSE;
pub const G_NORMALIZE_NFKD: Enum_Unnamed60 = Enum_Unnamed60::G_NORMALIZE_ALL;
pub const G_NORMALIZE_NFKC: Enum_Unnamed60 =
    Enum_Unnamed60::G_NORMALIZE_ALL_COMPOSE;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed60 {
    G_NORMALIZE_DEFAULT = 0,
    G_NORMALIZE_DEFAULT_COMPOSE = 1,
    G_NORMALIZE_ALL = 2,
    G_NORMALIZE_ALL_COMPOSE = 3,
}
pub type GNormalizeMode = Enum_Unnamed60;
pub type GString = Struct__GString;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GString {
    pub _str: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
impl ::std::clone::Clone for Struct__GString {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GString {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GIOChannel = Struct__GIOChannel;
pub type GIOFuncs = Struct__GIOFuncs;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed61 {
    G_IO_ERROR_NONE = 0,
    G_IO_ERROR_AGAIN = 1,
    G_IO_ERROR_INVAL = 2,
    G_IO_ERROR_UNKNOWN = 3,
}
pub type GIOError = Enum_Unnamed61;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed62 {
    G_IO_CHANNEL_ERROR_FBIG = 0,
    G_IO_CHANNEL_ERROR_INVAL = 1,
    G_IO_CHANNEL_ERROR_IO = 2,
    G_IO_CHANNEL_ERROR_ISDIR = 3,
    G_IO_CHANNEL_ERROR_NOSPC = 4,
    G_IO_CHANNEL_ERROR_NXIO = 5,
    G_IO_CHANNEL_ERROR_OVERFLOW = 6,
    G_IO_CHANNEL_ERROR_PIPE = 7,
    G_IO_CHANNEL_ERROR_FAILED = 8,
}
pub type GIOChannelError = Enum_Unnamed62;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed63 {
    G_IO_STATUS_ERROR = 0,
    G_IO_STATUS_NORMAL = 1,
    G_IO_STATUS_EOF = 2,
    G_IO_STATUS_AGAIN = 3,
}
pub type GIOStatus = Enum_Unnamed63;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed64 { G_SEEK_CUR = 0, G_SEEK_SET = 1, G_SEEK_END = 2, }
pub type GSeekType = Enum_Unnamed64;
pub const G_IO_FLAG_IS_WRITEABLE: Enum_Unnamed65 =
    Enum_Unnamed65::G_IO_FLAG_IS_WRITABLE;
pub const G_IO_FLAG_GET_MASK: Enum_Unnamed65 = Enum_Unnamed65::G_IO_FLAG_MASK;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed65 {
    G_IO_FLAG_APPEND = 1,
    G_IO_FLAG_NONBLOCK = 2,
    G_IO_FLAG_IS_READABLE = 4,
    G_IO_FLAG_IS_WRITABLE = 8,
    G_IO_FLAG_IS_SEEKABLE = 16,
    G_IO_FLAG_MASK = 31,
    G_IO_FLAG_SET_MASK = 3,
}
pub type GIOFlags = Enum_Unnamed65;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
    pub _bindgen_bitfield_5_: guint,
    pub _bindgen_bitfield_6_: guint,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
impl ::std::clone::Clone for Struct__GIOChannel {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GIOChannel {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GIOFunc =
    ::std::option::Option<unsafe extern "C" fn(source: *mut GIOChannel,
                                               condition: GIOCondition,
                                               data: gpointer) -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GIOFuncs {
    pub io_read: ::std::option::Option<unsafe extern "C" fn(channel:
                                                                *mut GIOChannel,
                                                            buf: *mut gchar,
                                                            count: gsize,
                                                            bytes_read:
                                                                *mut gsize,
                                                            err:
                                                                *mut *mut GError)
                                           -> GIOStatus>,
    pub io_write: ::std::option::Option<unsafe extern "C" fn(channel:
                                                                 *mut GIOChannel,
                                                             buf:
                                                                 *const gchar,
                                                             count: gsize,
                                                             bytes_written:
                                                                 *mut gsize,
                                                             err:
                                                                 *mut *mut GError)
                                            -> GIOStatus>,
    pub io_seek: ::std::option::Option<unsafe extern "C" fn(channel:
                                                                *mut GIOChannel,
                                                            offset: gint64,
                                                            _type: GSeekType,
                                                            err:
                                                                *mut *mut GError)
                                           -> GIOStatus>,
    pub io_close: ::std::option::Option<unsafe extern "C" fn(channel:
                                                                 *mut GIOChannel,
                                                             err:
                                                                 *mut *mut GError)
                                            -> GIOStatus>,
    pub io_create_watch: ::std::option::Option<unsafe extern "C" fn(channel:
                                                                        *mut GIOChannel,
                                                                    condition:
                                                                        GIOCondition)
                                                   -> *mut GSource>,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel:
                                                                *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<unsafe extern "C" fn(channel:
                                                                     *mut GIOChannel,
                                                                 flags:
                                                                     GIOFlags,
                                                                 err:
                                                                     *mut *mut GError)
                                                -> GIOStatus>,
    pub io_get_flags: ::std::option::Option<unsafe extern "C" fn(channel:
                                                                     *mut GIOChannel)
                                                -> GIOFlags>,
}
impl ::std::clone::Clone for Struct__GIOFuncs {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GIOFuncs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed66 {
    G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0,
    G_KEY_FILE_ERROR_PARSE = 1,
    G_KEY_FILE_ERROR_NOT_FOUND = 2,
    G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3,
    G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4,
    G_KEY_FILE_ERROR_INVALID_VALUE = 5,
}
pub type GKeyFileError = Enum_Unnamed66;
pub enum Struct__GKeyFile { }
pub type GKeyFile = Struct__GKeyFile;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed67 {
    G_KEY_FILE_NONE = 0,
    G_KEY_FILE_KEEP_COMMENTS = 1,
    G_KEY_FILE_KEEP_TRANSLATIONS = 2,
}
pub type GKeyFileFlags = Enum_Unnamed67;
pub enum Struct__GMappedFile { }
pub type GMappedFile = Struct__GMappedFile;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed68 {
    G_MARKUP_ERROR_BAD_UTF8 = 0,
    G_MARKUP_ERROR_EMPTY = 1,
    G_MARKUP_ERROR_PARSE = 2,
    G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3,
    G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4,
    G_MARKUP_ERROR_INVALID_CONTENT = 5,
    G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6,
}
pub type GMarkupError = Enum_Unnamed68;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed69 {
    G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1,
    G_MARKUP_TREAT_CDATA_AS_TEXT = 2,
    G_MARKUP_PREFIX_ERROR_POSITION = 4,
    G_MARKUP_IGNORE_QUALIFIED = 8,
}
pub type GMarkupParseFlags = Enum_Unnamed69;
pub enum Struct__GMarkupParseContext { }
pub type GMarkupParseContext = Struct__GMarkupParseContext;
pub type GMarkupParser = Struct__GMarkupParser;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMarkupParser {
    pub start_element: ::std::option::Option<unsafe extern "C" fn(context:
                                                                      *mut GMarkupParseContext,
                                                                  element_name:
                                                                      *const gchar,
                                                                  attribute_names:
                                                                      *mut *const gchar,
                                                                  attribute_values:
                                                                      *mut *const gchar,
                                                                  user_data:
                                                                      gpointer,
                                                                  error:
                                                                      *mut *mut GError)>,
    pub end_element: ::std::option::Option<unsafe extern "C" fn(context:
                                                                    *mut GMarkupParseContext,
                                                                element_name:
                                                                    *const gchar,
                                                                user_data:
                                                                    gpointer,
                                                                error:
                                                                    *mut *mut GError)>,
    pub text: ::std::option::Option<unsafe extern "C" fn(context:
                                                             *mut GMarkupParseContext,
                                                         text: *const gchar,
                                                         text_len: gsize,
                                                         user_data: gpointer,
                                                         error:
                                                             *mut *mut GError)>,
    pub passthrough: ::std::option::Option<unsafe extern "C" fn(context:
                                                                    *mut GMarkupParseContext,
                                                                passthrough_text:
                                                                    *const gchar,
                                                                text_len:
                                                                    gsize,
                                                                user_data:
                                                                    gpointer,
                                                                error:
                                                                    *mut *mut GError)>,
    pub error: ::std::option::Option<unsafe extern "C" fn(context:
                                                              *mut GMarkupParseContext,
                                                          error: *mut GError,
                                                          user_data:
                                                              gpointer)>,
}
impl ::std::clone::Clone for Struct__GMarkupParser {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMarkupParser {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed70 {
    G_MARKUP_COLLECT_INVALID = 0,
    G_MARKUP_COLLECT_STRING = 1,
    G_MARKUP_COLLECT_STRDUP = 2,
    G_MARKUP_COLLECT_BOOLEAN = 3,
    G_MARKUP_COLLECT_TRISTATE = 4,
    G_MARKUP_COLLECT_OPTIONAL = 65536,
}
pub type GMarkupCollectType = Enum_Unnamed70;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed71 {
    G_LOG_FLAG_RECURSION = 1,
    G_LOG_FLAG_FATAL = 2,
    G_LOG_LEVEL_ERROR = 4,
    G_LOG_LEVEL_CRITICAL = 8,
    G_LOG_LEVEL_WARNING = 16,
    G_LOG_LEVEL_MESSAGE = 32,
    G_LOG_LEVEL_INFO = 64,
    G_LOG_LEVEL_DEBUG = 128,
    G_LOG_LEVEL_MASK = -4,
}
pub type GLogLevelFlags = Enum_Unnamed71;
pub type GLogFunc =
    ::std::option::Option<unsafe extern "C" fn(log_domain: *const gchar,
                                               log_level: GLogLevelFlags,
                                               message: *const gchar,
                                               user_data: gpointer)>;
pub type GPrintFunc =
    ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
pub enum Struct__GOptionContext { }
pub type GOptionContext = Struct__GOptionContext;
pub enum Struct__GOptionGroup { }
pub type GOptionGroup = Struct__GOptionGroup;
pub type GOptionEntry = Struct__GOptionEntry;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed72 {
    G_OPTION_FLAG_NONE = 0,
    G_OPTION_FLAG_HIDDEN = 1,
    G_OPTION_FLAG_IN_MAIN = 2,
    G_OPTION_FLAG_REVERSE = 4,
    G_OPTION_FLAG_NO_ARG = 8,
    G_OPTION_FLAG_FILENAME = 16,
    G_OPTION_FLAG_OPTIONAL_ARG = 32,
    G_OPTION_FLAG_NOALIAS = 64,
}
pub type GOptionFlags = Enum_Unnamed72;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed73 {
    G_OPTION_ARG_NONE = 0,
    G_OPTION_ARG_STRING = 1,
    G_OPTION_ARG_INT = 2,
    G_OPTION_ARG_CALLBACK = 3,
    G_OPTION_ARG_FILENAME = 4,
    G_OPTION_ARG_STRING_ARRAY = 5,
    G_OPTION_ARG_FILENAME_ARRAY = 6,
    G_OPTION_ARG_DOUBLE = 7,
    G_OPTION_ARG_INT64 = 8,
}
pub type GOptionArg = Enum_Unnamed73;
pub type GOptionArgFunc =
    ::std::option::Option<unsafe extern "C" fn(option_name: *const gchar,
                                               value: *const gchar,
                                               data: gpointer,
                                               error: *mut *mut GError)
                              -> gboolean>;
pub type GOptionParseFunc =
    ::std::option::Option<unsafe extern "C" fn(context: *mut GOptionContext,
                                               group: *mut GOptionGroup,
                                               data: gpointer,
                                               error: *mut *mut GError)
                              -> gboolean>;
pub type GOptionErrorFunc =
    ::std::option::Option<unsafe extern "C" fn(context: *mut GOptionContext,
                                               group: *mut GOptionGroup,
                                               data: gpointer,
                                               error: *mut *mut GError)>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed74 {
    G_OPTION_ERROR_UNKNOWN_OPTION = 0,
    G_OPTION_ERROR_BAD_VALUE = 1,
    G_OPTION_ERROR_FAILED = 2,
}
pub type GOptionError = Enum_Unnamed74;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
impl ::std::clone::Clone for Struct__GOptionEntry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GOptionEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GPatternSpec { }
pub type GPatternSpec = Struct__GPatternSpec;
pub type GQueue = Struct__GQueue;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
impl ::std::clone::Clone for Struct__GQueue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GQueue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GRand { }
pub type GRand = Struct__GRand;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed75 {
    G_REGEX_ERROR_COMPILE = 0,
    G_REGEX_ERROR_OPTIMIZE = 1,
    G_REGEX_ERROR_REPLACE = 2,
    G_REGEX_ERROR_MATCH = 3,
    G_REGEX_ERROR_INTERNAL = 4,
    G_REGEX_ERROR_STRAY_BACKSLASH = 101,
    G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
    G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
    G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
    G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
    G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
    G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
    G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
    G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
    G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
    G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
    G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
    G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
    G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
    G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
    G_REGEX_ERROR_MEMORY_ERROR = 121,
    G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
    G_REGEX_ERROR_MALFORMED_CONDITION = 126,
    G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
    G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
    G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
    G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
    G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
    G_REGEX_ERROR_INVALID_CONDITION = 135,
    G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
    G_REGEX_ERROR_INFINITE_LOOP = 140,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
    G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
    G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
    G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
    G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
    G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
    G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
    G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
    G_REGEX_ERROR_DEFINE_REPETION = 155,
    G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
    G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
    G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
    G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
    G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
    G_REGEX_ERROR_MISSING_DIGIT = 163,
    G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
    G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
    G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
    G_REGEX_ERROR_MISSING_NAME = 169,
    G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
    G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
    G_REGEX_ERROR_NAME_TOO_LONG = 175,
    G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176,
}
pub type GRegexError = Enum_Unnamed75;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed76 {
    G_REGEX_CASELESS = 1,
    G_REGEX_MULTILINE = 2,
    G_REGEX_DOTALL = 4,
    G_REGEX_EXTENDED = 8,
    G_REGEX_ANCHORED = 16,
    G_REGEX_DOLLAR_ENDONLY = 32,
    G_REGEX_UNGREEDY = 512,
    G_REGEX_RAW = 2048,
    G_REGEX_NO_AUTO_CAPTURE = 4096,
    G_REGEX_OPTIMIZE = 8192,
    G_REGEX_FIRSTLINE = 262144,
    G_REGEX_DUPNAMES = 524288,
    G_REGEX_NEWLINE_CR = 1048576,
    G_REGEX_NEWLINE_LF = 2097152,
    G_REGEX_NEWLINE_CRLF = 3145728,
    G_REGEX_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_BSR_ANYCRLF = 8388608,
    G_REGEX_JAVASCRIPT_COMPAT = 33554432,
}
pub type GRegexCompileFlags = Enum_Unnamed76;
pub const G_REGEX_MATCH_PARTIAL_SOFT: Enum_Unnamed77 =
    Enum_Unnamed77::G_REGEX_MATCH_PARTIAL;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed77 {
    G_REGEX_MATCH_ANCHORED = 16,
    G_REGEX_MATCH_NOTBOL = 128,
    G_REGEX_MATCH_NOTEOL = 256,
    G_REGEX_MATCH_NOTEMPTY = 1024,
    G_REGEX_MATCH_PARTIAL = 32768,
    G_REGEX_MATCH_NEWLINE_CR = 1048576,
    G_REGEX_MATCH_NEWLINE_LF = 2097152,
    G_REGEX_MATCH_NEWLINE_CRLF = 3145728,
    G_REGEX_MATCH_NEWLINE_ANY = 4194304,
    G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_MATCH_BSR_ANYCRLF = 8388608,
    G_REGEX_MATCH_BSR_ANY = 16777216,
    G_REGEX_MATCH_PARTIAL_HARD = 134217728,
    G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456,
}
pub type GRegexMatchFlags = Enum_Unnamed77;
pub enum Struct__GRegex { }
pub type GRegex = Struct__GRegex;
pub enum Struct__GMatchInfo { }
pub type GMatchInfo = Struct__GMatchInfo;
pub type GRegexEvalCallback =
    ::std::option::Option<unsafe extern "C" fn(match_info: *const GMatchInfo,
                                               result: *mut GString,
                                               user_data: gpointer)
                              -> gboolean>;
pub type GScanner = Struct__GScanner;
pub type GScannerConfig = Struct__GScannerConfig;
pub type GTokenValue = Union__GTokenValue;
pub type GScannerMsgFunc =
    ::std::option::Option<unsafe extern "C" fn(scanner: *mut GScanner,
                                               message: *mut gchar,
                                               error: gboolean)>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed78 {
    G_ERR_UNKNOWN = 0,
    G_ERR_UNEXP_EOF = 1,
    G_ERR_UNEXP_EOF_IN_STRING = 2,
    G_ERR_UNEXP_EOF_IN_COMMENT = 3,
    G_ERR_NON_DIGIT_IN_CONST = 4,
    G_ERR_DIGIT_RADIX = 5,
    G_ERR_FLOAT_RADIX = 6,
    G_ERR_FLOAT_MALFORMED = 7,
}
pub type GErrorType = Enum_Unnamed78;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed79 {
    G_TOKEN_EOF = 0,
    G_TOKEN_LEFT_PAREN = 40,
    G_TOKEN_RIGHT_PAREN = 41,
    G_TOKEN_LEFT_CURLY = 123,
    G_TOKEN_RIGHT_CURLY = 125,
    G_TOKEN_LEFT_BRACE = 91,
    G_TOKEN_RIGHT_BRACE = 93,
    G_TOKEN_EQUAL_SIGN = 61,
    G_TOKEN_COMMA = 44,
    G_TOKEN_NONE = 256,
    G_TOKEN_ERROR = 257,
    G_TOKEN_CHAR = 258,
    G_TOKEN_BINARY = 259,
    G_TOKEN_OCTAL = 260,
    G_TOKEN_INT = 261,
    G_TOKEN_HEX = 262,
    G_TOKEN_FLOAT = 263,
    G_TOKEN_STRING = 264,
    G_TOKEN_SYMBOL = 265,
    G_TOKEN_IDENTIFIER = 266,
    G_TOKEN_IDENTIFIER_NULL = 267,
    G_TOKEN_COMMENT_SINGLE = 268,
    G_TOKEN_COMMENT_MULTI = 269,
    G_TOKEN_LAST = 270,
}
pub type GTokenType = Enum_Unnamed79;
#[repr(C)]
#[derive(Copy)]
pub struct Union__GTokenValue {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union__GTokenValue {
    pub unsafe fn v_symbol(&mut self) -> *mut gpointer {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_identifier(&mut self) -> *mut *mut gchar {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_binary(&mut self) -> *mut gulong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_octal(&mut self) -> *mut gulong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_int(&mut self) -> *mut gulong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_int64(&mut self) -> *mut guint64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_float(&mut self) -> *mut gdouble {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_hex(&mut self) -> *mut gulong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_string(&mut self) -> *mut *mut gchar {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_comment(&mut self) -> *mut *mut gchar {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_char(&mut self) -> *mut guchar {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_error(&mut self) -> *mut guint {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union__GTokenValue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union__GTokenValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
    pub _bindgen_bitfield_5_: guint,
    pub _bindgen_bitfield_6_: guint,
    pub _bindgen_bitfield_7_: guint,
    pub _bindgen_bitfield_8_: guint,
    pub _bindgen_bitfield_9_: guint,
    pub _bindgen_bitfield_10_: guint,
    pub _bindgen_bitfield_11_: guint,
    pub _bindgen_bitfield_12_: guint,
    pub _bindgen_bitfield_13_: guint,
    pub _bindgen_bitfield_14_: guint,
    pub _bindgen_bitfield_15_: guint,
    pub _bindgen_bitfield_16_: guint,
    pub _bindgen_bitfield_17_: guint,
    pub _bindgen_bitfield_18_: guint,
    pub _bindgen_bitfield_19_: guint,
    pub _bindgen_bitfield_20_: guint,
    pub _bindgen_bitfield_21_: guint,
    pub _bindgen_bitfield_22_: guint,
    pub padding_dummy: guint,
}
impl ::std::clone::Clone for Struct__GScannerConfig {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GScannerConfig {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
impl ::std::clone::Clone for Struct__GScanner {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GScanner {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GSequence { }
pub type GSequence = Struct__GSequence;
pub enum Struct__GSequenceNode { }
pub type GSequenceIter = Struct__GSequenceNode;
pub type GSequenceIterCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut GSequenceIter,
                                               b: *mut GSequenceIter,
                                               data: gpointer) -> gint>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed80 {
    G_SHELL_ERROR_BAD_QUOTING = 0,
    G_SHELL_ERROR_EMPTY_STRING = 1,
    G_SHELL_ERROR_FAILED = 2,
}
pub type GShellError = Enum_Unnamed80;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed81 {
    G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
    G_SLICE_CONFIG_BYPASS_MAGAZINES = 2,
    G_SLICE_CONFIG_WORKING_SET_MSECS = 3,
    G_SLICE_CONFIG_COLOR_INCREMENT = 4,
    G_SLICE_CONFIG_CHUNK_SIZES = 5,
    G_SLICE_CONFIG_CONTENTION_COUNTER = 6,
}
pub type GSliceConfig = Enum_Unnamed81;
pub const G_SPAWN_ERROR_2BIG: Enum_Unnamed82 =
    Enum_Unnamed82::G_SPAWN_ERROR_TOO_BIG;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed82 {
    G_SPAWN_ERROR_FORK = 0,
    G_SPAWN_ERROR_READ = 1,
    G_SPAWN_ERROR_CHDIR = 2,
    G_SPAWN_ERROR_ACCES = 3,
    G_SPAWN_ERROR_PERM = 4,
    G_SPAWN_ERROR_TOO_BIG = 5,
    G_SPAWN_ERROR_NOEXEC = 6,
    G_SPAWN_ERROR_NAMETOOLONG = 7,
    G_SPAWN_ERROR_NOENT = 8,
    G_SPAWN_ERROR_NOMEM = 9,
    G_SPAWN_ERROR_NOTDIR = 10,
    G_SPAWN_ERROR_LOOP = 11,
    G_SPAWN_ERROR_TXTBUSY = 12,
    G_SPAWN_ERROR_IO = 13,
    G_SPAWN_ERROR_NFILE = 14,
    G_SPAWN_ERROR_MFILE = 15,
    G_SPAWN_ERROR_INVAL = 16,
    G_SPAWN_ERROR_ISDIR = 17,
    G_SPAWN_ERROR_LIBBAD = 18,
    G_SPAWN_ERROR_FAILED = 19,
}
pub type GSpawnError = Enum_Unnamed82;
pub type GSpawnChildSetupFunc =
    ::std::option::Option<extern "C" fn(user_data: gpointer)>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed83 {
    G_SPAWN_DEFAULT = 0,
    G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1,
    G_SPAWN_DO_NOT_REAP_CHILD = 2,
    G_SPAWN_SEARCH_PATH = 4,
    G_SPAWN_STDOUT_TO_DEV_NULL = 8,
    G_SPAWN_STDERR_TO_DEV_NULL = 16,
    G_SPAWN_CHILD_INHERITS_STDIN = 32,
    G_SPAWN_FILE_AND_ARGV_ZERO = 64,
    G_SPAWN_SEARCH_PATH_FROM_ENVP = 128,
    G_SPAWN_CLOEXEC_PIPES = 256,
}
pub type GSpawnFlags = Enum_Unnamed83;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed84 {
    G_ASCII_ALNUM = 1,
    G_ASCII_ALPHA = 2,
    G_ASCII_CNTRL = 4,
    G_ASCII_DIGIT = 8,
    G_ASCII_GRAPH = 16,
    G_ASCII_LOWER = 32,
    G_ASCII_PRINT = 64,
    G_ASCII_PUNCT = 128,
    G_ASCII_SPACE = 256,
    G_ASCII_UPPER = 512,
    G_ASCII_XDIGIT = 1024,
}
pub type GAsciiType = Enum_Unnamed84;
pub type GStrv = *mut *mut gchar;
pub enum Struct__GStringChunk { }
pub type GStringChunk = Struct__GStringChunk;
pub enum Struct_GTestCase { }
pub type GTestCase = Struct_GTestCase;
pub enum Struct_GTestSuite { }
pub type GTestSuite = Struct_GTestSuite;
pub type GTestFunc = ::std::option::Option<extern "C" fn()>;
pub type GTestDataFunc =
    ::std::option::Option<extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<extern "C" fn(fixture: gpointer,
                                        user_data: gconstpointer)>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed85 {
    G_TEST_TRAP_SILENCE_STDOUT = 128,
    G_TEST_TRAP_SILENCE_STDERR = 256,
    G_TEST_TRAP_INHERIT_STDIN = 512,
}
pub type GTestTrapFlags = Enum_Unnamed85;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed86 {
    G_TEST_SUBPROCESS_INHERIT_STDIN = 1,
    G_TEST_SUBPROCESS_INHERIT_STDOUT = 2,
    G_TEST_SUBPROCESS_INHERIT_STDERR = 4,
}
pub type GTestSubprocessFlags = Enum_Unnamed86;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed87 {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
impl ::std::clone::Clone for Struct_Unnamed87 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed87 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTestConfig = Struct_Unnamed87;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed88 {
    G_TEST_LOG_NONE = 0,
    G_TEST_LOG_ERROR = 1,
    G_TEST_LOG_START_BINARY = 2,
    G_TEST_LOG_LIST_CASE = 3,
    G_TEST_LOG_SKIP_CASE = 4,
    G_TEST_LOG_START_CASE = 5,
    G_TEST_LOG_STOP_CASE = 6,
    G_TEST_LOG_MIN_RESULT = 7,
    G_TEST_LOG_MAX_RESULT = 8,
    G_TEST_LOG_MESSAGE = 9,
    G_TEST_LOG_START_SUITE = 10,
    G_TEST_LOG_STOP_SUITE = 11,
}
pub type GTestLogType = Enum_Unnamed88;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed89 {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut ::std::os::raw::c_double,
}
impl ::std::clone::Clone for Struct_Unnamed89 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed89 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTestLogMsg = Struct_Unnamed89;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed90 {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
impl ::std::clone::Clone for Struct_Unnamed90 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed90 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTestLogBuffer = Struct_Unnamed90;
pub type GTestLogFatalFunc =
    ::std::option::Option<unsafe extern "C" fn(log_domain: *const gchar,
                                               log_level: GLogLevelFlags,
                                               message: *const gchar,
                                               user_data: gpointer)
                              -> gboolean>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed91 { G_TEST_DIST = 0, G_TEST_BUILT = 1, }
pub type GTestFileType = Enum_Unnamed91;
pub type GThreadPool = Struct__GThreadPool;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
impl ::std::clone::Clone for Struct__GThreadPool {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GThreadPool {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GTimer { }
pub type GTimer = Struct__GTimer;
pub type GTrashStack = Struct__GTrashStack;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTrashStack {
    pub next: *mut GTrashStack,
}
impl ::std::clone::Clone for Struct__GTrashStack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTrashStack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GTree { }
pub type GTree = Struct__GTree;
pub type GTraverseFunc =
    ::std::option::Option<extern "C" fn(key: gpointer, value: gpointer,
                                        data: gpointer) -> gboolean>;
pub enum Struct__GVariantType { }
pub type GVariantType = Struct__GVariantType;
pub enum Struct__GVariant { }
pub type GVariant = Struct__GVariant;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed92 {
    G_VARIANT_CLASS_BOOLEAN = 98,
    G_VARIANT_CLASS_BYTE = 121,
    G_VARIANT_CLASS_INT16 = 110,
    G_VARIANT_CLASS_UINT16 = 113,
    G_VARIANT_CLASS_INT32 = 105,
    G_VARIANT_CLASS_UINT32 = 117,
    G_VARIANT_CLASS_INT64 = 120,
    G_VARIANT_CLASS_UINT64 = 116,
    G_VARIANT_CLASS_HANDLE = 104,
    G_VARIANT_CLASS_DOUBLE = 100,
    G_VARIANT_CLASS_STRING = 115,
    G_VARIANT_CLASS_OBJECT_PATH = 111,
    G_VARIANT_CLASS_SIGNATURE = 103,
    G_VARIANT_CLASS_VARIANT = 118,
    G_VARIANT_CLASS_MAYBE = 109,
    G_VARIANT_CLASS_ARRAY = 97,
    G_VARIANT_CLASS_TUPLE = 40,
    G_VARIANT_CLASS_DICT_ENTRY = 123,
}
pub type GVariantClass = Enum_Unnamed92;
pub type GVariantIter = Struct__GVariantIter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVariantIter {
    pub x: [gsize; 16usize],
}
impl ::std::clone::Clone for Struct__GVariantIter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GVariantIter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GVariantBuilder = Struct__GVariantBuilder;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVariantBuilder {
    pub x: [gsize; 16usize],
}
impl ::std::clone::Clone for Struct__GVariantBuilder {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GVariantBuilder {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed93 {
    G_VARIANT_PARSE_ERROR_FAILED = 0,
    G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1,
    G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2,
    G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3,
    G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4,
    G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5,
    G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6,
    G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7,
    G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8,
    G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9,
    G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10,
    G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11,
    G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12,
    G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13,
    G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14,
    G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15,
    G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16,
    G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17,
}
pub type GVariantParseError = Enum_Unnamed93;
pub type GVariantDict = Struct__GVariantDict;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVariantDict {
    pub x: [gsize; 16usize],
}
impl ::std::clone::Clone for Struct__GVariantDict {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GVariantDict {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GAllocator { }
pub type GAllocator = Struct__GAllocator;
pub enum Struct__GMemChunk { }
pub type GMemChunk = Struct__GMemChunk;
pub enum Struct__GCache { }
pub type GCache = Struct__GCache;
pub type GCacheNewFunc =
    ::std::option::Option<extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc =
    ::std::option::Option<extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc =
    ::std::option::Option<extern "C" fn(value: gpointer)>;
pub type GCompletion = Struct__GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc =
    ::std::option::Option<unsafe extern "C" fn(s1: *const gchar,
                                               s2: *const gchar, n: gsize)
                              -> gint>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
impl ::std::clone::Clone for Struct__GCompletion {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GCompletion {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GRelation { }
pub type GRelation = Struct__GRelation;
pub type GTuples = Struct__GTuples;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTuples {
    pub len: guint,
}
impl ::std::clone::Clone for Struct__GTuples {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTuples {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed94 {
    G_THREAD_PRIORITY_LOW = 0,
    G_THREAD_PRIORITY_NORMAL = 1,
    G_THREAD_PRIORITY_HIGH = 2,
    G_THREAD_PRIORITY_URGENT = 3,
}
pub type GThreadPriority = Enum_Unnamed94;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
impl ::std::clone::Clone for Struct__GThread {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GThread {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GThreadFunctions = Struct__GThreadFunctions;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GThreadFunctions {
    pub mutex_new: ::std::option::Option<extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex:
                                                                   *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex:
                                                                      *mut GMutex)
                                                 -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex:
                                                                     *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex:
                                                                   *mut GMutex)>,
    pub cond_new: ::std::option::Option<extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond:
                                                                    *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond:
                                                                       *mut GCond)>,
    pub cond_wait: ::std::option::Option<unsafe extern "C" fn(cond:
                                                                  *mut GCond,
                                                              mutex:
                                                                  *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<unsafe extern "C" fn(cond:
                                                                        *mut GCond,
                                                                    mutex:
                                                                        *mut GMutex,
                                                                    end_time:
                                                                        *mut GTimeVal)
                                                   -> gboolean>,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond:
                                                                  *mut GCond)>,
    pub private_new: ::std::option::Option<extern "C" fn(destructor:
                                                             GDestroyNotify)
                                               -> *mut GPrivate>,
    pub private_get: ::std::option::Option<unsafe extern "C" fn(private_key:
                                                                    *mut GPrivate)
                                               -> gpointer>,
    pub private_set: ::std::option::Option<unsafe extern "C" fn(private_key:
                                                                    *mut GPrivate,
                                                                data:
                                                                    gpointer)>,
    pub thread_create: ::std::option::Option<unsafe extern "C" fn(func:
                                                                      GThreadFunc,
                                                                  data:
                                                                      gpointer,
                                                                  stack_size:
                                                                      gulong,
                                                                  joinable:
                                                                      gboolean,
                                                                  bound:
                                                                      gboolean,
                                                                  priority:
                                                                      GThreadPriority,
                                                                  thread:
                                                                      gpointer,
                                                                  error:
                                                                      *mut *mut GError)>,
    pub thread_yield: ::std::option::Option<extern "C" fn()>,
    pub thread_join: ::std::option::Option<extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<extern "C" fn()>,
    pub thread_set_priority: ::std::option::Option<extern "C" fn(thread:
                                                                     gpointer,
                                                                 priority:
                                                                     GThreadPriority)>,
    pub thread_self: ::std::option::Option<extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<extern "C" fn(thread1: gpointer,
                                                          thread2: gpointer)
                                                -> gboolean>,
}
impl ::std::clone::Clone for Struct__GThreadFunctions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GThreadFunctions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type _uint = ::std::os::raw::c_uint;
pub type int8_t = ::std::os::raw::c_char;
pub type int16_t = ::std::os::raw::c_short;
pub type int32_t = ::std::os::raw::c_int;
pub type int64_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
impl ::std::clone::Clone for Struct_timeval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timeval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed95 {
    pub __fds_bits: [__fd_mask; 16usize],
}
impl ::std::clone::Clone for Struct_Unnamed95 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed95 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fd_set = Struct_Unnamed95;
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_sched_param {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sched_param {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct___sched_param {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sched_param {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed96 {
    pub __bits: [__cpu_mask; 16usize],
}
impl ::std::clone::Clone for Struct_Unnamed96 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed96 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type cpu_set_t = Struct_Unnamed96;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed97 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_NORMAL: Enum_Unnamed98 =
    Enum_Unnamed98::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: Enum_Unnamed98 =
    Enum_Unnamed98::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: Enum_Unnamed98 =
    Enum_Unnamed98::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: Enum_Unnamed98 =
    Enum_Unnamed98::PTHREAD_MUTEX_TIMED_NP;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed98 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED_NP: Enum_Unnamed99 =
    Enum_Unnamed99::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST_NP: Enum_Unnamed99 =
    Enum_Unnamed99::PTHREAD_MUTEX_ROBUST;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed99 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed100 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_DEFAULT_NP: Enum_Unnamed101 =
    Enum_Unnamed101::PTHREAD_RWLOCK_PREFER_READER_NP;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed101 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed102 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed103 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed104 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut Struct__pthread_cleanup_buffer,
}
impl ::std::clone::Clone for Struct__pthread_cleanup_buffer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__pthread_cleanup_buffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed105 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed106 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed107 {
    pub __cancel_jmp_buf: [Struct_Unnamed108; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
impl ::std::clone::Clone for Struct_Unnamed107 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed107 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed108 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed108 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed108 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_unwind_buf_t = Struct_Unnamed107;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct___pthread_cleanup_frame {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___pthread_cleanup_frame {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct___jmp_buf_tag { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed109 {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
impl ::std::clone::Clone for Struct_Unnamed109 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed109 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GStaticMutex = Struct_Unnamed109;
pub type GStaticRecMutex = Struct__GStaticRecMutex;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: Union_Unnamed110,
}
impl ::std::clone::Clone for Struct__GStaticRecMutex {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GStaticRecMutex {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed110 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed110 {
    pub unsafe fn owner(&mut self) -> *mut pthread_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn dummy(&mut self) -> *mut gdouble {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed110 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed110 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GStaticRWLock = Struct__GStaticRWLock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
impl ::std::clone::Clone for Struct__GStaticRWLock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GStaticRWLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GStaticPrivate = Struct__GStaticPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GStaticPrivate {
    pub index: guint,
}
impl ::std::clone::Clone for Struct__GStaticPrivate {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GStaticPrivate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBytes_autoptr = *mut GBytes;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDir_autoptr = *mut GDir;
pub type GError_autoptr = *mut GError;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHmac_autoptr = *mut GHmac;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GList_autoptr = *mut GList;
pub type GArray_autoptr = *mut GArray;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GSource_autoptr = *mut GSource;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GNode_autoptr = *mut GNode;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GQueue_autoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRegex_autoptr = *mut GRegex;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GScanner_autoptr = *mut GScanner;
pub type GSequence_autoptr = *mut GSequence;
pub type GSList_autoptr = *mut GSList;
pub type GString_autoptr = *mut GString;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GThread_autoptr = *mut GThread;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTree_autoptr = *mut GTree;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GType = gsize;
pub type GValue = Struct__GValue;
pub enum Union__GTypeCValue { }
pub type GTypeCValue = Union__GTypeCValue;
pub enum Struct__GTypePlugin { }
pub type GTypePlugin = Struct__GTypePlugin;
pub type GTypeClass = Struct__GTypeClass;
pub type GTypeInterface = Struct__GTypeInterface;
pub type GTypeInstance = Struct__GTypeInstance;
pub type GTypeInfo = Struct__GTypeInfo;
pub type GTypeFundamentalInfo = Struct__GTypeFundamentalInfo;
pub type GInterfaceInfo = Struct__GInterfaceInfo;
pub type GTypeValueTable = Struct__GTypeValueTable;
pub type GTypeQuery = Struct__GTypeQuery;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeClass {
    pub g_type: GType,
}
impl ::std::clone::Clone for Struct__GTypeClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypeClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeInstance {
    pub g_class: *mut GTypeClass,
}
impl ::std::clone::Clone for Struct__GTypeInstance {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypeInstance {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
impl ::std::clone::Clone for Struct__GTypeInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypeInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeQuery {
    pub _type: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}
impl ::std::clone::Clone for Struct__GTypeQuery {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypeQuery {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed111 {
    G_TYPE_DEBUG_NONE = 0,
    G_TYPE_DEBUG_OBJECTS = 1,
    G_TYPE_DEBUG_SIGNALS = 2,
    G_TYPE_DEBUG_INSTANCE_COUNT = 4,
    G_TYPE_DEBUG_MASK = 7,
}
pub type GTypeDebugFlags = Enum_Unnamed111;
pub type GBaseInitFunc =
    ::std::option::Option<extern "C" fn(g_class: gpointer)>;
pub type GBaseFinalizeFunc =
    ::std::option::Option<extern "C" fn(g_class: gpointer)>;
pub type GClassInitFunc =
    ::std::option::Option<extern "C" fn(g_class: gpointer,
                                        class_data: gpointer)>;
pub type GClassFinalizeFunc =
    ::std::option::Option<extern "C" fn(g_class: gpointer,
                                        class_data: gpointer)>;
pub type GInstanceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(instance: *mut GTypeInstance,
                                               g_class: gpointer)>;
pub type GInterfaceInitFunc =
    ::std::option::Option<extern "C" fn(g_iface: gpointer,
                                        iface_data: gpointer)>;
pub type GInterfaceFinalizeFunc =
    ::std::option::Option<extern "C" fn(g_iface: gpointer,
                                        iface_data: gpointer)>;
pub type GTypeClassCacheFunc =
    ::std::option::Option<unsafe extern "C" fn(cache_data: gpointer,
                                               g_class: *mut GTypeClass)
                              -> gboolean>;
pub type GTypeInterfaceCheckFunc =
    ::std::option::Option<extern "C" fn(check_data: gpointer,
                                        g_iface: gpointer)>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed112 {
    G_TYPE_FLAG_CLASSED = 1,
    G_TYPE_FLAG_INSTANTIATABLE = 2,
    G_TYPE_FLAG_DERIVABLE = 4,
    G_TYPE_FLAG_DEEP_DERIVABLE = 8,
}
pub type GTypeFundamentalFlags = Enum_Unnamed112;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed113 {
    G_TYPE_FLAG_ABSTRACT = 16,
    G_TYPE_FLAG_VALUE_ABSTRACT = 32,
}
pub type GTypeFlags = Enum_Unnamed113;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeInfo {
    pub class_size: guint16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}
impl ::std::clone::Clone for Struct__GTypeInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypeInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}
impl ::std::clone::Clone for Struct__GTypeFundamentalInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypeFundamentalInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}
impl ::std::clone::Clone for Struct__GInterfaceInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInterfaceInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeValueTable {
    pub value_init: ::std::option::Option<unsafe extern "C" fn(value:
                                                                   *mut GValue)>,
    pub value_free: ::std::option::Option<unsafe extern "C" fn(value:
                                                                   *mut GValue)>,
    pub value_copy: ::std::option::Option<unsafe extern "C" fn(src_value:
                                                                   *const GValue,
                                                               dest_value:
                                                                   *mut GValue)>,
    pub value_peek_pointer: ::std::option::Option<unsafe extern "C" fn(value:
                                                                           *const GValue)
                                                      -> gpointer>,
    pub collect_format: *const gchar,
    pub collect_value: ::std::option::Option<unsafe extern "C" fn(value:
                                                                      *mut GValue,
                                                                  n_collect_values:
                                                                      guint,
                                                                  collect_values:
                                                                      *mut GTypeCValue,
                                                                  collect_flags:
                                                                      guint)
                                                 -> *mut gchar>,
    pub lcopy_format: *const gchar,
    pub lcopy_value: ::std::option::Option<unsafe extern "C" fn(value:
                                                                    *const GValue,
                                                                n_collect_values:
                                                                    guint,
                                                                collect_values:
                                                                    *mut GTypeCValue,
                                                                collect_flags:
                                                                    guint)
                                               -> *mut gchar>,
}
impl ::std::clone::Clone for Struct__GTypeValueTable {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypeValueTable {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GValueTransform =
    ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue,
                                               dest_value: *mut GValue)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GValue {
    pub g_type: GType,
    pub data: [Union_Unnamed114; 2usize],
}
impl ::std::clone::Clone for Struct__GValue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed114 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed114 {
    pub unsafe fn v_int(&mut self) -> *mut gint {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_uint(&mut self) -> *mut guint {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_long(&mut self) -> *mut glong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_ulong(&mut self) -> *mut gulong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_int64(&mut self) -> *mut gint64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_uint64(&mut self) -> *mut guint64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_float(&mut self) -> *mut gfloat {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_double(&mut self) -> *mut gdouble {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v_pointer(&mut self) -> *mut gpointer {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed114 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed114 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub const G_PARAM_PRIVATE: Enum_Unnamed115 =
    Enum_Unnamed115::G_PARAM_STATIC_NAME;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed115 {
    G_PARAM_READABLE = 1,
    G_PARAM_WRITABLE = 2,
    G_PARAM_READWRITE = 3,
    G_PARAM_CONSTRUCT = 4,
    G_PARAM_CONSTRUCT_ONLY = 8,
    G_PARAM_LAX_VALIDATION = 16,
    G_PARAM_STATIC_NAME = 32,
    G_PARAM_STATIC_NICK = 64,
    G_PARAM_STATIC_BLURB = 128,
    G_PARAM_EXPLICIT_NOTIFY = 1073741824,
    G_PARAM_DEPRECATED = -2147483648,
}
pub type GParamFlags = Enum_Unnamed115;
pub type GParamSpec = Struct__GParamSpec;
pub type GParamSpecClass = Struct__GParamSpecClass;
pub type GParameter = Struct__GParameter;
pub enum Struct__GParamSpecPool { }
pub type GParamSpecPool = Struct__GParamSpecPool;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
impl ::std::clone::Clone for Struct__GParamSpec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec:
                                                                 *mut GParamSpec)>,
    pub value_set_default: ::std::option::Option<unsafe extern "C" fn(pspec:
                                                                          *mut GParamSpec,
                                                                      value:
                                                                          *mut GValue)>,
    pub value_validate: ::std::option::Option<unsafe extern "C" fn(pspec:
                                                                       *mut GParamSpec,
                                                                   value:
                                                                       *mut GValue)
                                                  -> gboolean>,
    pub values_cmp: ::std::option::Option<unsafe extern "C" fn(pspec:
                                                                   *mut GParamSpec,
                                                               value1:
                                                                   *const GValue,
                                                               value2:
                                                                   *const GValue)
                                              -> gint>,
    pub dummy: [gpointer; 4usize],
}
impl ::std::clone::Clone for Struct__GParamSpecClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParameter {
    pub name: *const gchar,
    pub value: GValue,
}
impl ::std::clone::Clone for Struct__GParameter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParameter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GParamSpecTypeInfo = Struct__GParamSpecTypeInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecTypeInfo {
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: ::std::option::Option<unsafe extern "C" fn(pspec:
                                                                      *mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec:
                                                                 *mut GParamSpec)>,
    pub value_set_default: ::std::option::Option<unsafe extern "C" fn(pspec:
                                                                          *mut GParamSpec,
                                                                      value:
                                                                          *mut GValue)>,
    pub value_validate: ::std::option::Option<unsafe extern "C" fn(pspec:
                                                                       *mut GParamSpec,
                                                                   value:
                                                                       *mut GValue)
                                                  -> gboolean>,
    pub values_cmp: ::std::option::Option<unsafe extern "C" fn(pspec:
                                                                   *mut GParamSpec,
                                                               value1:
                                                                   *const GValue,
                                                               value2:
                                                                   *const GValue)
                                              -> gint>,
}
impl ::std::clone::Clone for Struct__GParamSpecTypeInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecTypeInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GClosure = Struct__GClosure;
pub type GClosureNotifyData = Struct__GClosureNotifyData;
pub type GCallback = ::std::option::Option<extern "C" fn()>;
pub type GClosureNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer,
                                               closure: *mut GClosure)>;
pub type GClosureMarshal =
    ::std::option::Option<unsafe extern "C" fn(closure: *mut GClosure,
                                               return_value: *mut GValue,
                                               n_param_values: guint,
                                               param_values: *const GValue,
                                               invocation_hint: gpointer,
                                               marshal_data: gpointer)>;
pub type GVaClosureMarshal =
    ::std::option::Option<unsafe extern "C" fn(closure: *mut GClosure,
                                               return_value: *mut GValue,
                                               instance: gpointer,
                                               args: va_list,
                                               marshal_data: gpointer,
                                               n_params:
                                                   ::std::os::raw::c_int,
                                               param_types: *mut GType)>;
pub type GCClosure = Struct__GCClosure;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
impl ::std::clone::Clone for Struct__GClosureNotifyData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GClosureNotifyData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GClosure {
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
    pub _bindgen_bitfield_3_: guint,
    pub _bindgen_bitfield_4_: guint,
    pub _bindgen_bitfield_5_: guint,
    pub _bindgen_bitfield_6_: guint,
    pub _bindgen_bitfield_7_: guint,
    pub _bindgen_bitfield_8_: guint,
    pub _bindgen_bitfield_9_: guint,
    pub _bindgen_bitfield_10_: guint,
    pub marshal: ::std::option::Option<unsafe extern "C" fn(closure:
                                                                *mut GClosure,
                                                            return_value:
                                                                *mut GValue,
                                                            n_param_values:
                                                                guint,
                                                            param_values:
                                                                *const GValue,
                                                            invocation_hint:
                                                                gpointer,
                                                            marshal_data:
                                                                gpointer)>,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
impl ::std::clone::Clone for Struct__GClosure {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GClosure {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}
impl ::std::clone::Clone for Struct__GCClosure {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GCClosure {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSignalQuery = Struct__GSignalQuery;
pub type GSignalInvocationHint = Struct__GSignalInvocationHint;
pub type GSignalCMarshaller = GClosureMarshal;
pub type GSignalCVaMarshaller = GVaClosureMarshal;
pub type GSignalEmissionHook =
    ::std::option::Option<unsafe extern "C" fn(ihint:
                                                   *mut GSignalInvocationHint,
                                               n_param_values: guint,
                                               param_values: *const GValue,
                                               data: gpointer) -> gboolean>;
pub type GSignalAccumulator =
    ::std::option::Option<unsafe extern "C" fn(ihint:
                                                   *mut GSignalInvocationHint,
                                               return_accu: *mut GValue,
                                               handler_return: *const GValue,
                                               data: gpointer) -> gboolean>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed116 {
    G_SIGNAL_RUN_FIRST = 1,
    G_SIGNAL_RUN_LAST = 2,
    G_SIGNAL_RUN_CLEANUP = 4,
    G_SIGNAL_NO_RECURSE = 8,
    G_SIGNAL_DETAILED = 16,
    G_SIGNAL_ACTION = 32,
    G_SIGNAL_NO_HOOKS = 64,
    G_SIGNAL_MUST_COLLECT = 128,
    G_SIGNAL_DEPRECATED = 256,
}
pub type GSignalFlags = Enum_Unnamed116;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed117 { G_CONNECT_AFTER = 1, G_CONNECT_SWAPPED = 2, }
pub type GConnectFlags = Enum_Unnamed117;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed118 {
    G_SIGNAL_MATCH_ID = 1,
    G_SIGNAL_MATCH_DETAIL = 2,
    G_SIGNAL_MATCH_CLOSURE = 4,
    G_SIGNAL_MATCH_FUNC = 8,
    G_SIGNAL_MATCH_DATA = 16,
    G_SIGNAL_MATCH_UNBLOCKED = 32,
}
pub type GSignalMatchType = Enum_Unnamed118;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: GQuark,
    pub run_type: GSignalFlags,
}
impl ::std::clone::Clone for Struct__GSignalInvocationHint {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSignalInvocationHint {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *const GType,
}
impl ::std::clone::Clone for Struct__GSignalQuery {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSignalQuery {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GBoxedCopyFunc =
    ::std::option::Option<extern "C" fn(boxed: gpointer) -> gpointer>;
pub type GBoxedFreeFunc =
    ::std::option::Option<extern "C" fn(boxed: gpointer)>;
pub type GObject = Struct__GObject;
pub type GObjectClass = Struct__GObjectClass;
pub type GInitiallyUnowned = Struct__GObject;
pub type GInitiallyUnownedClass = Struct__GObjectClass;
pub type GObjectConstructParam = Struct__GObjectConstructParam;
pub type GObjectGetPropertyFunc =
    ::std::option::Option<unsafe extern "C" fn(object: *mut GObject,
                                               property_id: guint,
                                               value: *mut GValue,
                                               pspec: *mut GParamSpec)>;
pub type GObjectSetPropertyFunc =
    ::std::option::Option<unsafe extern "C" fn(object: *mut GObject,
                                               property_id: guint,
                                               value: *const GValue,
                                               pspec: *mut GParamSpec)>;
pub type GObjectFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>;
pub type GWeakNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer,
                                               where_the_object_was:
                                                   *mut GObject)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
impl ::std::clone::Clone for Struct__GObject {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GObject {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<unsafe extern "C" fn(_type: GType,
                                                                n_construct_properties:
                                                                    guint,
                                                                construct_properties:
                                                                    *mut GObjectConstructParam)
                                               -> *mut GObject>,
    pub set_property: ::std::option::Option<unsafe extern "C" fn(object:
                                                                     *mut GObject,
                                                                 property_id:
                                                                     guint,
                                                                 value:
                                                                     *const GValue,
                                                                 pspec:
                                                                     *mut GParamSpec)>,
    pub get_property: ::std::option::Option<unsafe extern "C" fn(object:
                                                                     *mut GObject,
                                                                 property_id:
                                                                     guint,
                                                                 value:
                                                                     *mut GValue,
                                                                 pspec:
                                                                     *mut GParamSpec)>,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object:
                                                                *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object:
                                                                 *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<unsafe extern "C" fn(object:
                                                                                    *mut GObject,
                                                                                n_pspecs:
                                                                                    guint,
                                                                                pspecs:
                                                                                    *mut *mut GParamSpec)>,
    pub notify: ::std::option::Option<unsafe extern "C" fn(object:
                                                               *mut GObject,
                                                           pspec:
                                                               *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object:
                                                                    *mut GObject)>,
    pub flags: gsize,
    pub pdummy: [gpointer; 6usize],
}
impl ::std::clone::Clone for Struct__GObjectClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GObjectClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
impl ::std::clone::Clone for Struct__GObjectConstructParam {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GObjectConstructParam {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GToggleNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer,
                                               object: *mut GObject,
                                               is_last_ref: gboolean)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed119 {
    pub _priv: Union_Unnamed120,
}
impl ::std::clone::Clone for Struct_Unnamed119 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed119 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed120 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed120 {
    pub unsafe fn p(&mut self) -> *mut gpointer {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed120 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed120 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GWeakRef = Struct_Unnamed119;
pub enum Struct__GBinding { }
pub type GBinding = Struct__GBinding;
pub type GBindingTransformFunc =
    ::std::option::Option<unsafe extern "C" fn(binding: *mut GBinding,
                                               from_value: *const GValue,
                                               to_value: *mut GValue,
                                               user_data: gpointer)
                              -> gboolean>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed121 {
    G_BINDING_DEFAULT = 0,
    G_BINDING_BIDIRECTIONAL = 1,
    G_BINDING_SYNC_CREATE = 2,
    G_BINDING_INVERT_BOOLEAN = 4,
}
pub type GBindingFlags = Enum_Unnamed121;
pub type GEnumClass = Struct__GEnumClass;
pub type GFlagsClass = Struct__GFlagsClass;
pub type GEnumValue = Struct__GEnumValue;
pub type GFlagsValue = Struct__GFlagsValue;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}
impl ::std::clone::Clone for Struct__GEnumClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GEnumClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}
impl ::std::clone::Clone for Struct__GFlagsClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFlagsClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
impl ::std::clone::Clone for Struct__GEnumValue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GEnumValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
impl ::std::clone::Clone for Struct__GFlagsValue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFlagsValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GParamSpecChar = Struct__GParamSpecChar;
pub type GParamSpecUChar = Struct__GParamSpecUChar;
pub type GParamSpecBoolean = Struct__GParamSpecBoolean;
pub type GParamSpecInt = Struct__GParamSpecInt;
pub type GParamSpecUInt = Struct__GParamSpecUInt;
pub type GParamSpecLong = Struct__GParamSpecLong;
pub type GParamSpecULong = Struct__GParamSpecULong;
pub type GParamSpecInt64 = Struct__GParamSpecInt64;
pub type GParamSpecUInt64 = Struct__GParamSpecUInt64;
pub type GParamSpecUnichar = Struct__GParamSpecUnichar;
pub type GParamSpecEnum = Struct__GParamSpecEnum;
pub type GParamSpecFlags = Struct__GParamSpecFlags;
pub type GParamSpecFloat = Struct__GParamSpecFloat;
pub type GParamSpecDouble = Struct__GParamSpecDouble;
pub type GParamSpecString = Struct__GParamSpecString;
pub type GParamSpecParam = Struct__GParamSpecParam;
pub type GParamSpecBoxed = Struct__GParamSpecBoxed;
pub type GParamSpecPointer = Struct__GParamSpecPointer;
pub type GParamSpecValueArray = Struct__GParamSpecValueArray;
pub type GParamSpecObject = Struct__GParamSpecObject;
pub type GParamSpecOverride = Struct__GParamSpecOverride;
pub type GParamSpecGType = Struct__GParamSpecGType;
pub type GParamSpecVariant = Struct__GParamSpecVariant;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: gint8,
    pub maximum: gint8,
    pub default_value: gint8,
}
impl ::std::clone::Clone for Struct__GParamSpecChar {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecChar {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: guint8,
    pub maximum: guint8,
    pub default_value: guint8,
}
impl ::std::clone::Clone for Struct__GParamSpecUChar {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecUChar {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}
impl ::std::clone::Clone for Struct__GParamSpecBoolean {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecBoolean {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}
impl ::std::clone::Clone for Struct__GParamSpecInt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecInt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}
impl ::std::clone::Clone for Struct__GParamSpecUInt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecUInt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}
impl ::std::clone::Clone for Struct__GParamSpecLong {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecLong {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}
impl ::std::clone::Clone for Struct__GParamSpecULong {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecULong {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: gint64,
    pub maximum: gint64,
    pub default_value: gint64,
}
impl ::std::clone::Clone for Struct__GParamSpecInt64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecInt64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: guint64,
    pub maximum: guint64,
    pub default_value: guint64,
}
impl ::std::clone::Clone for Struct__GParamSpecUInt64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecUInt64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}
impl ::std::clone::Clone for Struct__GParamSpecUnichar {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecUnichar {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}
impl ::std::clone::Clone for Struct__GParamSpecEnum {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecEnum {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}
impl ::std::clone::Clone for Struct__GParamSpecFlags {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecFlags {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}
impl ::std::clone::Clone for Struct__GParamSpecFloat {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecFloat {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}
impl ::std::clone::Clone for Struct__GParamSpecDouble {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecDouble {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    pub _bindgen_bitfield_1_: guint,
    pub _bindgen_bitfield_2_: guint,
}
impl ::std::clone::Clone for Struct__GParamSpecString {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecString {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecParam {
    pub parent_instance: GParamSpec,
}
impl ::std::clone::Clone for Struct__GParamSpecParam {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecParam {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}
impl ::std::clone::Clone for Struct__GParamSpecBoxed {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecBoxed {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecPointer {
    pub parent_instance: GParamSpec,
}
impl ::std::clone::Clone for Struct__GParamSpecPointer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecPointer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}
impl ::std::clone::Clone for Struct__GParamSpecValueArray {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecValueArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecObject {
    pub parent_instance: GParamSpec,
}
impl ::std::clone::Clone for Struct__GParamSpecObject {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecObject {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}
impl ::std::clone::Clone for Struct__GParamSpecOverride {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecOverride {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}
impl ::std::clone::Clone for Struct__GParamSpecGType {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecGType {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub _type: *mut GVariantType,
    pub default_value: *mut GVariant,
    pub padding: [gpointer; 4usize],
}
impl ::std::clone::Clone for Struct__GParamSpecVariant {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GParamSpecVariant {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTypeModule = Struct__GTypeModule;
pub type GTypeModuleClass = Struct__GTypeModuleClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut GSList,
    pub interface_infos: *mut GSList,
    pub name: *mut gchar,
}
impl ::std::clone::Clone for Struct__GTypeModule {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypeModule {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: ::std::option::Option<unsafe extern "C" fn(module:
                                                             *mut GTypeModule)
                                        -> gboolean>,
    pub unload: ::std::option::Option<unsafe extern "C" fn(module:
                                                               *mut GTypeModule)>,
    pub reserved1: ::std::option::Option<extern "C" fn()>,
    pub reserved2: ::std::option::Option<extern "C" fn()>,
    pub reserved3: ::std::option::Option<extern "C" fn()>,
    pub reserved4: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GTypeModuleClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypeModuleClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTypePluginClass = Struct__GTypePluginClass;
pub type GTypePluginUse =
    ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
pub type GTypePluginUnuse =
    ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
pub type GTypePluginCompleteTypeInfo =
    ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin,
                                               g_type: GType,
                                               info: *mut GTypeInfo,
                                               value_table:
                                                   *mut GTypeValueTable)>;
pub type GTypePluginCompleteInterfaceInfo =
    ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin,
                                               instance_type: GType,
                                               interface_type: GType,
                                               info: *mut GInterfaceInfo)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}
impl ::std::clone::Clone for Struct__GTypePluginClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTypePluginClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GValueArray = Struct__GValueArray;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    pub n_prealloced: guint,
}
impl ::std::clone::Clone for Struct__GValueArray {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GValueArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type gchararray = *mut gchar;
pub type GObject_autoptr = *mut GObject;
pub type GInitiallyUnowned_autoptr = *mut GInitiallyUnowned;
pub type HifAdvisory = Struct__HifAdvisory;
pub type HifAdvisoryClass = Struct__HifAdvisoryClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifAdvisory {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifAdvisory {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifAdvisory {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifAdvisory_autoptr = *mut HifAdvisory;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifAdvisoryClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifAdvisoryClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifAdvisoryClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed122 {
    HIF_ADVISORY_KIND_UNKNOWN = 0,
    HIF_ADVISORY_KIND_SECURITY = 1,
    HIF_ADVISORY_KIND_BUGFIX = 2,
    HIF_ADVISORY_KIND_ENHANCEMENT = 3,
}
pub type HifAdvisoryKind = Enum_Unnamed122;
pub type HifAdvisoryPkg = Struct__HifAdvisoryPkg;
pub type HifAdvisoryPkgClass = Struct__HifAdvisoryPkgClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifAdvisoryPkg {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifAdvisoryPkg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifAdvisoryPkg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifAdvisoryPkg_autoptr = *mut HifAdvisoryPkg;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifAdvisoryPkgClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifAdvisoryPkgClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifAdvisoryPkgClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifAdvisoryRef = Struct__HifAdvisoryRef;
pub type HifAdvisoryRefClass = Struct__HifAdvisoryRefClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifAdvisoryRef {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifAdvisoryRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifAdvisoryRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifAdvisoryRef_autoptr = *mut HifAdvisoryRef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifAdvisoryRefClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifAdvisoryRefClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifAdvisoryRefClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed123 {
    HIF_REFERENCE_KIND_UNKNOWN = 0,
    HIF_REFERENCE_KIND_BUGZILLA = 1,
    HIF_REFERENCE_KIND_CVE = 2,
    HIF_REFERENCE_KIND_VENDOR = 3,
}
pub type HifAdvisoryRefKind = Enum_Unnamed123;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed124 {
    G_APP_INFO_CREATE_NONE = 0,
    G_APP_INFO_CREATE_NEEDS_TERMINAL = 1,
    G_APP_INFO_CREATE_SUPPORTS_URIS = 2,
    G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = 4,
}
pub type GAppInfoCreateFlags = Enum_Unnamed124;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed125 {
    G_CONVERTER_NO_FLAGS = 0,
    G_CONVERTER_INPUT_AT_END = 1,
    G_CONVERTER_FLUSH = 2,
}
pub type GConverterFlags = Enum_Unnamed125;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed126 {
    G_CONVERTER_ERROR = 0,
    G_CONVERTER_CONVERTED = 1,
    G_CONVERTER_FINISHED = 2,
    G_CONVERTER_FLUSHED = 3,
}
pub type GConverterResult = Enum_Unnamed126;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed127 {
    G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN = 0,
    G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN = 1,
    G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN = 2,
}
pub type GDataStreamByteOrder = Enum_Unnamed127;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed128 {
    G_DATA_STREAM_NEWLINE_TYPE_LF = 0,
    G_DATA_STREAM_NEWLINE_TYPE_CR = 1,
    G_DATA_STREAM_NEWLINE_TYPE_CR_LF = 2,
    G_DATA_STREAM_NEWLINE_TYPE_ANY = 3,
}
pub type GDataStreamNewlineType = Enum_Unnamed128;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed129 {
    G_FILE_ATTRIBUTE_TYPE_INVALID = 0,
    G_FILE_ATTRIBUTE_TYPE_STRING = 1,
    G_FILE_ATTRIBUTE_TYPE_BYTE_STRING = 2,
    G_FILE_ATTRIBUTE_TYPE_BOOLEAN = 3,
    G_FILE_ATTRIBUTE_TYPE_UINT32 = 4,
    G_FILE_ATTRIBUTE_TYPE_INT32 = 5,
    G_FILE_ATTRIBUTE_TYPE_UINT64 = 6,
    G_FILE_ATTRIBUTE_TYPE_INT64 = 7,
    G_FILE_ATTRIBUTE_TYPE_OBJECT = 8,
    G_FILE_ATTRIBUTE_TYPE_STRINGV = 9,
}
pub type GFileAttributeType = Enum_Unnamed129;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed130 {
    G_FILE_ATTRIBUTE_INFO_NONE = 0,
    G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = 1,
    G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = 2,
}
pub type GFileAttributeInfoFlags = Enum_Unnamed130;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed131 {
    G_FILE_ATTRIBUTE_STATUS_UNSET = 0,
    G_FILE_ATTRIBUTE_STATUS_SET = 1,
    G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING = 2,
}
pub type GFileAttributeStatus = Enum_Unnamed131;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed132 {
    G_FILE_QUERY_INFO_NONE = 0,
    G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = 1,
}
pub type GFileQueryInfoFlags = Enum_Unnamed132;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed133 {
    G_FILE_CREATE_NONE = 0,
    G_FILE_CREATE_PRIVATE = 1,
    G_FILE_CREATE_REPLACE_DESTINATION = 2,
}
pub type GFileCreateFlags = Enum_Unnamed133;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed134 {
    G_FILE_MEASURE_NONE = 0,
    G_FILE_MEASURE_REPORT_ANY_ERROR = 2,
    G_FILE_MEASURE_APPARENT_SIZE = 4,
    G_FILE_MEASURE_NO_XDEV = 8,
}
pub type GFileMeasureFlags = Enum_Unnamed134;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed135 { G_MOUNT_MOUNT_NONE = 0, }
pub type GMountMountFlags = Enum_Unnamed135;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed136 {
    G_MOUNT_UNMOUNT_NONE = 0,
    G_MOUNT_UNMOUNT_FORCE = 1,
}
pub type GMountUnmountFlags = Enum_Unnamed136;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed137 { G_DRIVE_START_NONE = 0, }
pub type GDriveStartFlags = Enum_Unnamed137;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed138 {
    G_DRIVE_START_STOP_TYPE_UNKNOWN = 0,
    G_DRIVE_START_STOP_TYPE_SHUTDOWN = 1,
    G_DRIVE_START_STOP_TYPE_NETWORK = 2,
    G_DRIVE_START_STOP_TYPE_MULTIDISK = 3,
    G_DRIVE_START_STOP_TYPE_PASSWORD = 4,
}
pub type GDriveStartStopType = Enum_Unnamed138;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed139 {
    G_FILE_COPY_NONE = 0,
    G_FILE_COPY_OVERWRITE = 1,
    G_FILE_COPY_BACKUP = 2,
    G_FILE_COPY_NOFOLLOW_SYMLINKS = 4,
    G_FILE_COPY_ALL_METADATA = 8,
    G_FILE_COPY_NO_FALLBACK_FOR_MOVE = 16,
    G_FILE_COPY_TARGET_DEFAULT_PERMS = 32,
}
pub type GFileCopyFlags = Enum_Unnamed139;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed140 {
    G_FILE_MONITOR_NONE = 0,
    G_FILE_MONITOR_WATCH_MOUNTS = 1,
    G_FILE_MONITOR_SEND_MOVED = 2,
    G_FILE_MONITOR_WATCH_HARD_LINKS = 4,
    G_FILE_MONITOR_WATCH_MOVES = 8,
}
pub type GFileMonitorFlags = Enum_Unnamed140;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed141 {
    G_FILE_TYPE_UNKNOWN = 0,
    G_FILE_TYPE_REGULAR = 1,
    G_FILE_TYPE_DIRECTORY = 2,
    G_FILE_TYPE_SYMBOLIC_LINK = 3,
    G_FILE_TYPE_SPECIAL = 4,
    G_FILE_TYPE_SHORTCUT = 5,
    G_FILE_TYPE_MOUNTABLE = 6,
}
pub type GFileType = Enum_Unnamed141;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed142 {
    G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0,
    G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL = 1,
    G_FILESYSTEM_PREVIEW_TYPE_NEVER = 2,
}
pub type GFilesystemPreviewType = Enum_Unnamed142;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed143 {
    G_FILE_MONITOR_EVENT_CHANGED = 0,
    G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT = 1,
    G_FILE_MONITOR_EVENT_DELETED = 2,
    G_FILE_MONITOR_EVENT_CREATED = 3,
    G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED = 4,
    G_FILE_MONITOR_EVENT_PRE_UNMOUNT = 5,
    G_FILE_MONITOR_EVENT_UNMOUNTED = 6,
    G_FILE_MONITOR_EVENT_MOVED = 7,
    G_FILE_MONITOR_EVENT_RENAMED = 8,
    G_FILE_MONITOR_EVENT_MOVED_IN = 9,
    G_FILE_MONITOR_EVENT_MOVED_OUT = 10,
}
pub type GFileMonitorEvent = Enum_Unnamed143;
pub const G_IO_ERROR_CONNECTION_CLOSED: Enum_Unnamed144 =
    Enum_Unnamed144::G_IO_ERROR_BROKEN_PIPE;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed144 {
    G_IO_ERROR_FAILED = 0,
    G_IO_ERROR_NOT_FOUND = 1,
    G_IO_ERROR_EXISTS = 2,
    G_IO_ERROR_IS_DIRECTORY = 3,
    G_IO_ERROR_NOT_DIRECTORY = 4,
    G_IO_ERROR_NOT_EMPTY = 5,
    G_IO_ERROR_NOT_REGULAR_FILE = 6,
    G_IO_ERROR_NOT_SYMBOLIC_LINK = 7,
    G_IO_ERROR_NOT_MOUNTABLE_FILE = 8,
    G_IO_ERROR_FILENAME_TOO_LONG = 9,
    G_IO_ERROR_INVALID_FILENAME = 10,
    G_IO_ERROR_TOO_MANY_LINKS = 11,
    G_IO_ERROR_NO_SPACE = 12,
    G_IO_ERROR_INVALID_ARGUMENT = 13,
    G_IO_ERROR_PERMISSION_DENIED = 14,
    G_IO_ERROR_NOT_SUPPORTED = 15,
    G_IO_ERROR_NOT_MOUNTED = 16,
    G_IO_ERROR_ALREADY_MOUNTED = 17,
    G_IO_ERROR_CLOSED = 18,
    G_IO_ERROR_CANCELLED = 19,
    G_IO_ERROR_PENDING = 20,
    G_IO_ERROR_READ_ONLY = 21,
    G_IO_ERROR_CANT_CREATE_BACKUP = 22,
    G_IO_ERROR_WRONG_ETAG = 23,
    G_IO_ERROR_TIMED_OUT = 24,
    G_IO_ERROR_WOULD_RECURSE = 25,
    G_IO_ERROR_BUSY = 26,
    G_IO_ERROR_WOULD_BLOCK = 27,
    G_IO_ERROR_HOST_NOT_FOUND = 28,
    G_IO_ERROR_WOULD_MERGE = 29,
    G_IO_ERROR_FAILED_HANDLED = 30,
    G_IO_ERROR_TOO_MANY_OPEN_FILES = 31,
    G_IO_ERROR_NOT_INITIALIZED = 32,
    G_IO_ERROR_ADDRESS_IN_USE = 33,
    G_IO_ERROR_PARTIAL_INPUT = 34,
    G_IO_ERROR_INVALID_DATA = 35,
    G_IO_ERROR_DBUS_ERROR = 36,
    G_IO_ERROR_HOST_UNREACHABLE = 37,
    G_IO_ERROR_NETWORK_UNREACHABLE = 38,
    G_IO_ERROR_CONNECTION_REFUSED = 39,
    G_IO_ERROR_PROXY_FAILED = 40,
    G_IO_ERROR_PROXY_AUTH_FAILED = 41,
    G_IO_ERROR_PROXY_NEED_AUTH = 42,
    G_IO_ERROR_PROXY_NOT_ALLOWED = 43,
    G_IO_ERROR_BROKEN_PIPE = 44,
    G_IO_ERROR_NOT_CONNECTED = 45,
}
pub type GIOErrorEnum = Enum_Unnamed144;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed145 {
    G_ASK_PASSWORD_NEED_PASSWORD = 1,
    G_ASK_PASSWORD_NEED_USERNAME = 2,
    G_ASK_PASSWORD_NEED_DOMAIN = 4,
    G_ASK_PASSWORD_SAVING_SUPPORTED = 8,
    G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = 16,
}
pub type GAskPasswordFlags = Enum_Unnamed145;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed146 {
    G_PASSWORD_SAVE_NEVER = 0,
    G_PASSWORD_SAVE_FOR_SESSION = 1,
    G_PASSWORD_SAVE_PERMANENTLY = 2,
}
pub type GPasswordSave = Enum_Unnamed146;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed147 {
    G_MOUNT_OPERATION_HANDLED = 0,
    G_MOUNT_OPERATION_ABORTED = 1,
    G_MOUNT_OPERATION_UNHANDLED = 2,
}
pub type GMountOperationResult = Enum_Unnamed147;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed148 {
    G_OUTPUT_STREAM_SPLICE_NONE = 0,
    G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = 1,
    G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = 2,
}
pub type GOutputStreamSpliceFlags = Enum_Unnamed148;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed149 {
    G_IO_STREAM_SPLICE_NONE = 0,
    G_IO_STREAM_SPLICE_CLOSE_STREAM1 = 1,
    G_IO_STREAM_SPLICE_CLOSE_STREAM2 = 2,
    G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = 4,
}
pub type GIOStreamSpliceFlags = Enum_Unnamed149;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed150 {
    G_EMBLEM_ORIGIN_UNKNOWN = 0,
    G_EMBLEM_ORIGIN_DEVICE = 1,
    G_EMBLEM_ORIGIN_LIVEMETADATA = 2,
    G_EMBLEM_ORIGIN_TAG = 3,
}
pub type GEmblemOrigin = Enum_Unnamed150;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed151 {
    G_RESOLVER_ERROR_NOT_FOUND = 0,
    G_RESOLVER_ERROR_TEMPORARY_FAILURE = 1,
    G_RESOLVER_ERROR_INTERNAL = 2,
}
pub type GResolverError = Enum_Unnamed151;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed152 {
    G_RESOLVER_RECORD_SRV = 1,
    G_RESOLVER_RECORD_MX = 2,
    G_RESOLVER_RECORD_TXT = 3,
    G_RESOLVER_RECORD_SOA = 4,
    G_RESOLVER_RECORD_NS = 5,
}
pub type GResolverRecordType = Enum_Unnamed152;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed153 {
    G_RESOURCE_ERROR_NOT_FOUND = 0,
    G_RESOURCE_ERROR_INTERNAL = 1,
}
pub type GResourceError = Enum_Unnamed153;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed154 {
    G_RESOURCE_FLAGS_NONE = 0,
    G_RESOURCE_FLAGS_COMPRESSED = 1,
}
pub type GResourceFlags = Enum_Unnamed154;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed155 { G_RESOURCE_LOOKUP_FLAGS_NONE = 0, }
pub type GResourceLookupFlags = Enum_Unnamed155;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed156 {
    G_SOCKET_FAMILY_INVALID = 0,
    G_SOCKET_FAMILY_UNIX = 1,
    G_SOCKET_FAMILY_IPV4 = 2,
    G_SOCKET_FAMILY_IPV6 = 10,
}
pub type GSocketFamily = Enum_Unnamed156;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed157 {
    G_SOCKET_TYPE_INVALID = 0,
    G_SOCKET_TYPE_STREAM = 1,
    G_SOCKET_TYPE_DATAGRAM = 2,
    G_SOCKET_TYPE_SEQPACKET = 3,
}
pub type GSocketType = Enum_Unnamed157;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed158 {
    G_SOCKET_MSG_NONE = 0,
    G_SOCKET_MSG_OOB = 1,
    G_SOCKET_MSG_PEEK = 2,
    G_SOCKET_MSG_DONTROUTE = 4,
}
pub type GSocketMsgFlags = Enum_Unnamed158;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed159 {
    G_SOCKET_PROTOCOL_UNKNOWN = -1,
    G_SOCKET_PROTOCOL_DEFAULT = 0,
    G_SOCKET_PROTOCOL_TCP = 6,
    G_SOCKET_PROTOCOL_UDP = 17,
    G_SOCKET_PROTOCOL_SCTP = 132,
}
pub type GSocketProtocol = Enum_Unnamed159;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed160 {
    G_ZLIB_COMPRESSOR_FORMAT_ZLIB = 0,
    G_ZLIB_COMPRESSOR_FORMAT_GZIP = 1,
    G_ZLIB_COMPRESSOR_FORMAT_RAW = 2,
}
pub type GZlibCompressorFormat = Enum_Unnamed160;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed161 {
    G_UNIX_SOCKET_ADDRESS_INVALID = 0,
    G_UNIX_SOCKET_ADDRESS_ANONYMOUS = 1,
    G_UNIX_SOCKET_ADDRESS_PATH = 2,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT = 3,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED = 4,
}
pub type GUnixSocketAddressType = Enum_Unnamed161;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed162 {
    G_BUS_TYPE_STARTER = -1,
    G_BUS_TYPE_NONE = 0,
    G_BUS_TYPE_SYSTEM = 1,
    G_BUS_TYPE_SESSION = 2,
}
pub type GBusType = Enum_Unnamed162;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed163 {
    G_BUS_NAME_OWNER_FLAGS_NONE = 0,
    G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = 1,
    G_BUS_NAME_OWNER_FLAGS_REPLACE = 2,
}
pub type GBusNameOwnerFlags = Enum_Unnamed163;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed164 {
    G_BUS_NAME_WATCHER_FLAGS_NONE = 0,
    G_BUS_NAME_WATCHER_FLAGS_AUTO_START = 1,
}
pub type GBusNameWatcherFlags = Enum_Unnamed164;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed165 {
    G_DBUS_PROXY_FLAGS_NONE = 0,
    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 1,
    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 2,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 4,
    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 8,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = 16,
}
pub type GDBusProxyFlags = Enum_Unnamed165;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed166 {
    G_DBUS_ERROR_FAILED = 0,
    G_DBUS_ERROR_NO_MEMORY = 1,
    G_DBUS_ERROR_SERVICE_UNKNOWN = 2,
    G_DBUS_ERROR_NAME_HAS_NO_OWNER = 3,
    G_DBUS_ERROR_NO_REPLY = 4,
    G_DBUS_ERROR_IO_ERROR = 5,
    G_DBUS_ERROR_BAD_ADDRESS = 6,
    G_DBUS_ERROR_NOT_SUPPORTED = 7,
    G_DBUS_ERROR_LIMITS_EXCEEDED = 8,
    G_DBUS_ERROR_ACCESS_DENIED = 9,
    G_DBUS_ERROR_AUTH_FAILED = 10,
    G_DBUS_ERROR_NO_SERVER = 11,
    G_DBUS_ERROR_TIMEOUT = 12,
    G_DBUS_ERROR_NO_NETWORK = 13,
    G_DBUS_ERROR_ADDRESS_IN_USE = 14,
    G_DBUS_ERROR_DISCONNECTED = 15,
    G_DBUS_ERROR_INVALID_ARGS = 16,
    G_DBUS_ERROR_FILE_NOT_FOUND = 17,
    G_DBUS_ERROR_FILE_EXISTS = 18,
    G_DBUS_ERROR_UNKNOWN_METHOD = 19,
    G_DBUS_ERROR_TIMED_OUT = 20,
    G_DBUS_ERROR_MATCH_RULE_NOT_FOUND = 21,
    G_DBUS_ERROR_MATCH_RULE_INVALID = 22,
    G_DBUS_ERROR_SPAWN_EXEC_FAILED = 23,
    G_DBUS_ERROR_SPAWN_FORK_FAILED = 24,
    G_DBUS_ERROR_SPAWN_CHILD_EXITED = 25,
    G_DBUS_ERROR_SPAWN_CHILD_SIGNALED = 26,
    G_DBUS_ERROR_SPAWN_FAILED = 27,
    G_DBUS_ERROR_SPAWN_SETUP_FAILED = 28,
    G_DBUS_ERROR_SPAWN_CONFIG_INVALID = 29,
    G_DBUS_ERROR_SPAWN_SERVICE_INVALID = 30,
    G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND = 31,
    G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID = 32,
    G_DBUS_ERROR_SPAWN_FILE_INVALID = 33,
    G_DBUS_ERROR_SPAWN_NO_MEMORY = 34,
    G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN = 35,
    G_DBUS_ERROR_INVALID_SIGNATURE = 36,
    G_DBUS_ERROR_INVALID_FILE_CONTENT = 37,
    G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN = 38,
    G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN = 39,
    G_DBUS_ERROR_OBJECT_PATH_IN_USE = 40,
    G_DBUS_ERROR_UNKNOWN_OBJECT = 41,
    G_DBUS_ERROR_UNKNOWN_INTERFACE = 42,
    G_DBUS_ERROR_UNKNOWN_PROPERTY = 43,
    G_DBUS_ERROR_PROPERTY_READ_ONLY = 44,
}
pub type GDBusError = Enum_Unnamed166;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed167 {
    G_DBUS_CONNECTION_FLAGS_NONE = 0,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = 1,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = 2,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 4,
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = 8,
    G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = 16,
}
pub type GDBusConnectionFlags = Enum_Unnamed167;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed168 {
    G_DBUS_CAPABILITY_FLAGS_NONE = 0,
    G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = 1,
}
pub type GDBusCapabilityFlags = Enum_Unnamed168;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed169 {
    G_DBUS_CALL_FLAGS_NONE = 0,
    G_DBUS_CALL_FLAGS_NO_AUTO_START = 1,
    G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 2,
}
pub type GDBusCallFlags = Enum_Unnamed169;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed170 {
    G_DBUS_MESSAGE_TYPE_INVALID = 0,
    G_DBUS_MESSAGE_TYPE_METHOD_CALL = 1,
    G_DBUS_MESSAGE_TYPE_METHOD_RETURN = 2,
    G_DBUS_MESSAGE_TYPE_ERROR = 3,
    G_DBUS_MESSAGE_TYPE_SIGNAL = 4,
}
pub type GDBusMessageType = Enum_Unnamed170;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed171 {
    G_DBUS_MESSAGE_FLAGS_NONE = 0,
    G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = 1,
    G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = 2,
    G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 4,
}
pub type GDBusMessageFlags = Enum_Unnamed171;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed172 {
    G_DBUS_MESSAGE_HEADER_FIELD_INVALID = 0,
    G_DBUS_MESSAGE_HEADER_FIELD_PATH = 1,
    G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE = 2,
    G_DBUS_MESSAGE_HEADER_FIELD_MEMBER = 3,
    G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME = 4,
    G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL = 5,
    G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION = 6,
    G_DBUS_MESSAGE_HEADER_FIELD_SENDER = 7,
    G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE = 8,
    G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS = 9,
}
pub type GDBusMessageHeaderField = Enum_Unnamed172;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed173 {
    G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0,
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE = 1,
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = 2,
}
pub type GDBusPropertyInfoFlags = Enum_Unnamed173;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed174 {
    G_DBUS_SUBTREE_FLAGS_NONE = 0,
    G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = 1,
}
pub type GDBusSubtreeFlags = Enum_Unnamed174;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed175 {
    G_DBUS_SERVER_FLAGS_NONE = 0,
    G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = 1,
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 2,
}
pub type GDBusServerFlags = Enum_Unnamed175;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed176 {
    G_DBUS_SIGNAL_FLAGS_NONE = 0,
    G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = 1,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = 2,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = 4,
}
pub type GDBusSignalFlags = Enum_Unnamed176;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed177 {
    G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0,
    G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = 1,
}
pub type GDBusSendMessageFlags = Enum_Unnamed177;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed178 {
    G_CREDENTIALS_TYPE_INVALID = 0,
    G_CREDENTIALS_TYPE_LINUX_UCRED = 1,
    G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED = 2,
    G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED = 3,
    G_CREDENTIALS_TYPE_SOLARIS_UCRED = 4,
    G_CREDENTIALS_TYPE_NETBSD_UNPCBID = 5,
}
pub type GCredentialsType = Enum_Unnamed178;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed179 {
    G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN = 66,
    G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 108,
}
pub type GDBusMessageByteOrder = Enum_Unnamed179;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed180 {
    G_APPLICATION_FLAGS_NONE = 0,
    G_APPLICATION_IS_SERVICE = 1,
    G_APPLICATION_IS_LAUNCHER = 2,
    G_APPLICATION_HANDLES_OPEN = 4,
    G_APPLICATION_HANDLES_COMMAND_LINE = 8,
    G_APPLICATION_SEND_ENVIRONMENT = 16,
    G_APPLICATION_NON_UNIQUE = 32,
}
pub type GApplicationFlags = Enum_Unnamed180;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed181 {
    G_TLS_ERROR_UNAVAILABLE = 0,
    G_TLS_ERROR_MISC = 1,
    G_TLS_ERROR_BAD_CERTIFICATE = 2,
    G_TLS_ERROR_NOT_TLS = 3,
    G_TLS_ERROR_HANDSHAKE = 4,
    G_TLS_ERROR_CERTIFICATE_REQUIRED = 5,
    G_TLS_ERROR_EOF = 6,
}
pub type GTlsError = Enum_Unnamed181;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed182 {
    G_TLS_CERTIFICATE_UNKNOWN_CA = 1,
    G_TLS_CERTIFICATE_BAD_IDENTITY = 2,
    G_TLS_CERTIFICATE_NOT_ACTIVATED = 4,
    G_TLS_CERTIFICATE_EXPIRED = 8,
    G_TLS_CERTIFICATE_REVOKED = 16,
    G_TLS_CERTIFICATE_INSECURE = 32,
    G_TLS_CERTIFICATE_GENERIC_ERROR = 64,
    G_TLS_CERTIFICATE_VALIDATE_ALL = 127,
}
pub type GTlsCertificateFlags = Enum_Unnamed182;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed183 {
    G_TLS_AUTHENTICATION_NONE = 0,
    G_TLS_AUTHENTICATION_REQUESTED = 1,
    G_TLS_AUTHENTICATION_REQUIRED = 2,
}
pub type GTlsAuthenticationMode = Enum_Unnamed183;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed184 {
    G_TLS_REHANDSHAKE_NEVER = 0,
    G_TLS_REHANDSHAKE_SAFELY = 1,
    G_TLS_REHANDSHAKE_UNSAFELY = 2,
}
pub type GTlsRehandshakeMode = Enum_Unnamed184;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum__GTlsPasswordFlags {
    G_TLS_PASSWORD_NONE = 0,
    G_TLS_PASSWORD_RETRY = 2,
    G_TLS_PASSWORD_MANY_TRIES = 4,
    G_TLS_PASSWORD_FINAL_TRY = 8,
}
pub type GTlsPasswordFlags = Enum__GTlsPasswordFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed185 {
    G_TLS_INTERACTION_UNHANDLED = 0,
    G_TLS_INTERACTION_HANDLED = 1,
    G_TLS_INTERACTION_FAILED = 2,
}
pub type GTlsInteractionResult = Enum_Unnamed185;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed186 {
    G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0,
    G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1,
}
pub type GDBusInterfaceSkeletonFlags = Enum_Unnamed186;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed187 {
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0,
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = 1,
}
pub type GDBusObjectManagerClientFlags = Enum_Unnamed187;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed188 { G_TLS_DATABASE_VERIFY_NONE = 0, }
pub type GTlsDatabaseVerifyFlags = Enum_Unnamed188;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed189 {
    G_TLS_DATABASE_LOOKUP_NONE = 0,
    G_TLS_DATABASE_LOOKUP_KEYPAIR = 1,
}
pub type GTlsDatabaseLookupFlags = Enum_Unnamed189;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed190 { G_TLS_CERTIFICATE_REQUEST_NONE = 0, }
pub type GTlsCertificateRequestFlags = Enum_Unnamed190;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed191 {
    G_IO_MODULE_SCOPE_NONE = 0,
    G_IO_MODULE_SCOPE_BLOCK_DUPLICATES = 1,
}
pub type GIOModuleScopeFlags = Enum_Unnamed191;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed192 {
    G_SOCKET_CLIENT_RESOLVING = 0,
    G_SOCKET_CLIENT_RESOLVED = 1,
    G_SOCKET_CLIENT_CONNECTING = 2,
    G_SOCKET_CLIENT_CONNECTED = 3,
    G_SOCKET_CLIENT_PROXY_NEGOTIATING = 4,
    G_SOCKET_CLIENT_PROXY_NEGOTIATED = 5,
    G_SOCKET_CLIENT_TLS_HANDSHAKING = 6,
    G_SOCKET_CLIENT_TLS_HANDSHAKED = 7,
    G_SOCKET_CLIENT_COMPLETE = 8,
}
pub type GSocketClientEvent = Enum_Unnamed192;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed193 {
    G_SOCKET_LISTENER_BINDING = 0,
    G_SOCKET_LISTENER_BOUND = 1,
    G_SOCKET_LISTENER_LISTENING = 2,
    G_SOCKET_LISTENER_LISTENED = 3,
}
pub type GSocketListenerEvent = Enum_Unnamed193;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed194 { G_TEST_DBUS_NONE = 0, }
pub type GTestDBusFlags = Enum_Unnamed194;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed195 {
    G_SUBPROCESS_FLAGS_NONE = 0,
    G_SUBPROCESS_FLAGS_STDIN_PIPE = 1,
    G_SUBPROCESS_FLAGS_STDIN_INHERIT = 2,
    G_SUBPROCESS_FLAGS_STDOUT_PIPE = 4,
    G_SUBPROCESS_FLAGS_STDOUT_SILENCE = 8,
    G_SUBPROCESS_FLAGS_STDERR_PIPE = 16,
    G_SUBPROCESS_FLAGS_STDERR_SILENCE = 32,
    G_SUBPROCESS_FLAGS_STDERR_MERGE = 64,
    G_SUBPROCESS_FLAGS_INHERIT_FDS = 128,
}
pub type GSubprocessFlags = Enum_Unnamed195;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed196 {
    G_NOTIFICATION_PRIORITY_NORMAL = 0,
    G_NOTIFICATION_PRIORITY_LOW = 1,
    G_NOTIFICATION_PRIORITY_HIGH = 2,
    G_NOTIFICATION_PRIORITY_URGENT = 3,
}
pub type GNotificationPriority = Enum_Unnamed196;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed197 {
    G_NETWORK_CONNECTIVITY_LOCAL = 1,
    G_NETWORK_CONNECTIVITY_LIMITED = 2,
    G_NETWORK_CONNECTIVITY_PORTAL = 3,
    G_NETWORK_CONNECTIVITY_FULL = 4,
}
pub type GNetworkConnectivity = Enum_Unnamed197;
pub type GAppLaunchContext = Struct__GAppLaunchContext;
pub enum Struct__GAppInfo { }
pub type GAppInfo = Struct__GAppInfo;
pub enum Struct__GAsyncResult { }
pub type GAsyncResult = Struct__GAsyncResult;
pub enum Struct__GAsyncInitable { }
pub type GAsyncInitable = Struct__GAsyncInitable;
pub type GBufferedInputStream = Struct__GBufferedInputStream;
pub type GBufferedOutputStream = Struct__GBufferedOutputStream;
pub type GCancellable = Struct__GCancellable;
pub enum Struct__GCharsetConverter { }
pub type GCharsetConverter = Struct__GCharsetConverter;
pub enum Struct__GConverter { }
pub type GConverter = Struct__GConverter;
pub type GConverterInputStream = Struct__GConverterInputStream;
pub type GConverterOutputStream = Struct__GConverterOutputStream;
pub type GDataInputStream = Struct__GDataInputStream;
pub enum Struct__GSimplePermission { }
pub type GSimplePermission = Struct__GSimplePermission;
pub enum Struct__GZlibCompressor { }
pub type GZlibCompressor = Struct__GZlibCompressor;
pub enum Struct__GZlibDecompressor { }
pub type GZlibDecompressor = Struct__GZlibDecompressor;
pub type GSimpleActionGroup = Struct__GSimpleActionGroup;
pub enum Struct__GRemoteActionGroup { }
pub type GRemoteActionGroup = Struct__GRemoteActionGroup;
pub enum Struct__GDBusActionGroup { }
pub type GDBusActionGroup = Struct__GDBusActionGroup;
pub enum Struct__GActionMap { }
pub type GActionMap = Struct__GActionMap;
pub enum Struct__GActionGroup { }
pub type GActionGroup = Struct__GActionGroup;
pub enum Struct__GPropertyAction { }
pub type GPropertyAction = Struct__GPropertyAction;
pub enum Struct__GSimpleAction { }
pub type GSimpleAction = Struct__GSimpleAction;
pub enum Struct__GAction { }
pub type GAction = Struct__GAction;
pub type GApplication = Struct__GApplication;
pub type GApplicationCommandLine = Struct__GApplicationCommandLine;
pub enum Struct__GSettingsBackend { }
pub type GSettingsBackend = Struct__GSettingsBackend;
pub type GSettings = Struct__GSettings;
pub type GPermission = Struct__GPermission;
pub type GMenuModel = Struct__GMenuModel;
pub enum Struct__GNotification { }
pub type GNotification = Struct__GNotification;
pub enum Struct__GDrive { }
pub type GDrive = Struct__GDrive;
pub type GFileEnumerator = Struct__GFileEnumerator;
pub type GFileMonitor = Struct__GFileMonitor;
pub type GFilterInputStream = Struct__GFilterInputStream;
pub type GFilterOutputStream = Struct__GFilterOutputStream;
pub enum Struct__GFile { }
pub type GFile = Struct__GFile;
pub enum Struct__GFileInfo { }
pub type GFileInfo = Struct__GFileInfo;
pub enum Struct__GFileAttributeMatcher { }
pub type GFileAttributeMatcher = Struct__GFileAttributeMatcher;
pub type GFileAttributeInfo = Struct__GFileAttributeInfo;
pub type GFileAttributeInfoList = Struct__GFileAttributeInfoList;
pub enum Struct__GFileDescriptorBased { }
pub type GFileDescriptorBased = Struct__GFileDescriptorBased;
pub type GFileInputStream = Struct__GFileInputStream;
pub type GFileOutputStream = Struct__GFileOutputStream;
pub type GFileIOStream = Struct__GFileIOStream;
pub enum Struct__GFileIcon { }
pub type GFileIcon = Struct__GFileIcon;
pub enum Struct__GFilenameCompleter { }
pub type GFilenameCompleter = Struct__GFilenameCompleter;
pub enum Struct__GIcon { }
pub type GIcon = Struct__GIcon;
pub type GInetAddress = Struct__GInetAddress;
pub type GInetAddressMask = Struct__GInetAddressMask;
pub type GInetSocketAddress = Struct__GInetSocketAddress;
pub enum Struct__GNativeSocketAddress { }
pub type GNativeSocketAddress = Struct__GNativeSocketAddress;
pub type GInputStream = Struct__GInputStream;
pub enum Struct__GInitable { }
pub type GInitable = Struct__GInitable;
pub enum Struct__GIOModule { }
pub type GIOModule = Struct__GIOModule;
pub enum Struct__GIOExtensionPoint { }
pub type GIOExtensionPoint = Struct__GIOExtensionPoint;
pub enum Struct__GIOExtension { }
pub type GIOExtension = Struct__GIOExtension;
pub enum Struct__GIOSchedulerJob { }
pub type GIOSchedulerJob = Struct__GIOSchedulerJob;
pub enum Struct__GIOStreamAdapter { }
pub type GIOStreamAdapter = Struct__GIOStreamAdapter;
pub enum Struct__GLoadableIcon { }
pub type GLoadableIcon = Struct__GLoadableIcon;
pub enum Struct__GBytesIcon { }
pub type GBytesIcon = Struct__GBytesIcon;
pub type GMemoryInputStream = Struct__GMemoryInputStream;
pub type GMemoryOutputStream = Struct__GMemoryOutputStream;
pub enum Struct__GMount { }
pub type GMount = Struct__GMount;
pub type GMountOperation = Struct__GMountOperation;
pub type GNetworkAddress = Struct__GNetworkAddress;
pub enum Struct__GNetworkMonitor { }
pub type GNetworkMonitor = Struct__GNetworkMonitor;
pub type GNetworkService = Struct__GNetworkService;
pub type GOutputStream = Struct__GOutputStream;
pub type GIOStream = Struct__GIOStream;
pub enum Struct__GSimpleIOStream { }
pub type GSimpleIOStream = Struct__GSimpleIOStream;
pub enum Struct__GPollableInputStream { }
pub type GPollableInputStream = Struct__GPollableInputStream;
pub enum Struct__GPollableOutputStream { }
pub type GPollableOutputStream = Struct__GPollableOutputStream;
pub type GResolver = Struct__GResolver;
pub enum Struct__GResource { }
pub type GResource = Struct__GResource;
pub enum Struct__GSeekable { }
pub type GSeekable = Struct__GSeekable;
pub enum Struct__GSimpleAsyncResult { }
pub type GSimpleAsyncResult = Struct__GSimpleAsyncResult;
pub type GSocket = Struct__GSocket;
pub type GSocketControlMessage = Struct__GSocketControlMessage;
pub type GSocketClient = Struct__GSocketClient;
pub type GSocketConnection = Struct__GSocketConnection;
pub type GSocketListener = Struct__GSocketListener;
pub type GSocketService = Struct__GSocketService;
pub type GSocketAddress = Struct__GSocketAddress;
pub type GSocketAddressEnumerator = Struct__GSocketAddressEnumerator;
pub enum Struct__GSocketConnectable { }
pub type GSocketConnectable = Struct__GSocketConnectable;
pub enum Struct__GSrvTarget { }
pub type GSrvTarget = Struct__GSrvTarget;
pub enum Struct__GTask { }
pub type GTask = Struct__GTask;
pub type GTcpConnection = Struct__GTcpConnection;
pub type GTcpWrapperConnection = Struct__GTcpWrapperConnection;
pub type GThreadedSocketService = Struct__GThreadedSocketService;
pub enum Struct__GThemedIcon { }
pub type GThemedIcon = Struct__GThemedIcon;
pub type GTlsCertificate = Struct__GTlsCertificate;
pub enum Struct__GTlsClientConnection { }
pub type GTlsClientConnection = Struct__GTlsClientConnection;
pub type GTlsConnection = Struct__GTlsConnection;
pub type GTlsDatabase = Struct__GTlsDatabase;
pub enum Struct__GTlsFileDatabase { }
pub type GTlsFileDatabase = Struct__GTlsFileDatabase;
pub type GTlsInteraction = Struct__GTlsInteraction;
pub type GTlsPassword = Struct__GTlsPassword;
pub enum Struct__GTlsServerConnection { }
pub type GTlsServerConnection = Struct__GTlsServerConnection;
pub type GVfs = Struct__GVfs;
pub enum Struct__GProxyResolver { }
pub type GProxyResolver = Struct__GProxyResolver;
pub enum Struct__GProxy { }
pub type GProxy = Struct__GProxy;
pub type GProxyAddress = Struct__GProxyAddress;
pub type GProxyAddressEnumerator = Struct__GProxyAddressEnumerator;
pub enum Struct__GVolume { }
pub type GVolume = Struct__GVolume;
pub type GVolumeMonitor = Struct__GVolumeMonitor;
pub type GAsyncReadyCallback =
    ::std::option::Option<unsafe extern "C" fn(source_object: *mut GObject,
                                               res: *mut GAsyncResult,
                                               user_data: gpointer)>;
pub type GFileProgressCallback =
    ::std::option::Option<extern "C" fn(current_num_bytes: goffset,
                                        total_num_bytes: goffset,
                                        user_data: gpointer)>;
pub type GFileReadMoreCallback =
    ::std::option::Option<unsafe extern "C" fn(file_contents:
                                                   *const ::std::os::raw::c_char,
                                               file_size: goffset,
                                               callback_data: gpointer)
                              -> gboolean>;
pub type GFileMeasureProgressCallback =
    ::std::option::Option<extern "C" fn(reporting: gboolean,
                                        current_size: guint64,
                                        num_dirs: guint64, num_files: guint64,
                                        user_data: gpointer)>;
pub type GIOSchedulerJobFunc =
    ::std::option::Option<unsafe extern "C" fn(job: *mut GIOSchedulerJob,
                                               cancellable: *mut GCancellable,
                                               user_data: gpointer)
                              -> gboolean>;
pub type GSimpleAsyncThreadFunc =
    ::std::option::Option<unsafe extern "C" fn(res: *mut GSimpleAsyncResult,
                                               object: *mut GObject,
                                               cancellable:
                                                   *mut GCancellable)>;
pub type GSocketSourceFunc =
    ::std::option::Option<unsafe extern "C" fn(socket: *mut GSocket,
                                               condition: GIOCondition,
                                               user_data: gpointer)
                              -> gboolean>;
pub type GInputVector = Struct__GInputVector;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInputVector {
    pub buffer: gpointer,
    pub size: gsize,
}
impl ::std::clone::Clone for Struct__GInputVector {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInputVector {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GOutputVector = Struct__GOutputVector;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GOutputVector {
    pub buffer: gconstpointer,
    pub size: gsize,
}
impl ::std::clone::Clone for Struct__GOutputVector {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GOutputVector {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GOutputMessage = Struct__GOutputMessage;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GOutputMessage {
    pub address: *mut GSocketAddress,
    pub vectors: *mut GOutputVector,
    pub num_vectors: guint,
    pub bytes_sent: guint,
    pub control_messages: *mut *mut GSocketControlMessage,
    pub num_control_messages: guint,
}
impl ::std::clone::Clone for Struct__GOutputMessage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GOutputMessage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GCredentials { }
pub type GCredentials = Struct__GCredentials;
pub enum Struct__GUnixCredentialsMessage { }
pub type GUnixCredentialsMessage = Struct__GUnixCredentialsMessage;
pub enum Struct__GUnixFDList { }
pub type GUnixFDList = Struct__GUnixFDList;
pub enum Struct__GDBusMessage { }
pub type GDBusMessage = Struct__GDBusMessage;
pub enum Struct__GDBusConnection { }
pub type GDBusConnection = Struct__GDBusConnection;
pub type GDBusProxy = Struct__GDBusProxy;
pub enum Struct__GDBusMethodInvocation { }
pub type GDBusMethodInvocation = Struct__GDBusMethodInvocation;
pub enum Struct__GDBusServer { }
pub type GDBusServer = Struct__GDBusServer;
pub enum Struct__GDBusAuthObserver { }
pub type GDBusAuthObserver = Struct__GDBusAuthObserver;
pub type GDBusErrorEntry = Struct__GDBusErrorEntry;
pub type GDBusInterfaceVTable = Struct__GDBusInterfaceVTable;
pub type GDBusSubtreeVTable = Struct__GDBusSubtreeVTable;
pub type GDBusAnnotationInfo = Struct__GDBusAnnotationInfo;
pub type GDBusArgInfo = Struct__GDBusArgInfo;
pub type GDBusMethodInfo = Struct__GDBusMethodInfo;
pub type GDBusSignalInfo = Struct__GDBusSignalInfo;
pub type GDBusPropertyInfo = Struct__GDBusPropertyInfo;
pub type GDBusInterfaceInfo = Struct__GDBusInterfaceInfo;
pub type GDBusNodeInfo = Struct__GDBusNodeInfo;
pub type GCancellableSourceFunc =
    ::std::option::Option<unsafe extern "C" fn(cancellable: *mut GCancellable,
                                               user_data: gpointer)
                              -> gboolean>;
pub type GPollableSourceFunc =
    ::std::option::Option<unsafe extern "C" fn(pollable_stream: *mut GObject,
                                               user_data: gpointer)
                              -> gboolean>;
pub enum Struct__GDBusInterface { }
pub type GDBusInterface = Struct__GDBusInterface;
pub type GDBusInterfaceSkeleton = Struct__GDBusInterfaceSkeleton;
pub enum Struct__GDBusObject { }
pub type GDBusObject = Struct__GDBusObject;
pub type GDBusObjectSkeleton = Struct__GDBusObjectSkeleton;
pub type GDBusObjectProxy = Struct__GDBusObjectProxy;
pub enum Struct__GDBusObjectManager { }
pub type GDBusObjectManager = Struct__GDBusObjectManager;
pub type GDBusObjectManagerClient = Struct__GDBusObjectManagerClient;
pub type GDBusObjectManagerServer = Struct__GDBusObjectManagerServer;
pub type GDBusProxyTypeFunc =
    ::std::option::Option<unsafe extern "C" fn(manager:
                                                   *mut GDBusObjectManagerClient,
                                               object_path: *const gchar,
                                               interface_name: *const gchar,
                                               user_data: gpointer) -> GType>;
pub enum Struct__GTestDBus { }
pub type GTestDBus = Struct__GTestDBus;
pub enum Struct__GSubprocess { }
pub type GSubprocess = Struct__GSubprocess;
pub enum Struct__GSubprocessLauncher { }
pub type GSubprocessLauncher = Struct__GSubprocessLauncher;
pub type GActionInterface = Struct__GActionInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GActionInterface {
    pub g_iface: GTypeInterface,
    pub get_name: ::std::option::Option<unsafe extern "C" fn(action:
                                                                 *mut GAction)
                                            -> *const gchar>,
    pub get_parameter_type: ::std::option::Option<unsafe extern "C" fn(action:
                                                                           *mut GAction)
                                                      -> *const GVariantType>,
    pub get_state_type: ::std::option::Option<unsafe extern "C" fn(action:
                                                                       *mut GAction)
                                                  -> *const GVariantType>,
    pub get_state_hint: ::std::option::Option<unsafe extern "C" fn(action:
                                                                       *mut GAction)
                                                  -> *mut GVariant>,
    pub get_enabled: ::std::option::Option<unsafe extern "C" fn(action:
                                                                    *mut GAction)
                                               -> gboolean>,
    pub get_state: ::std::option::Option<unsafe extern "C" fn(action:
                                                                  *mut GAction)
                                             -> *mut GVariant>,
    pub change_state: ::std::option::Option<unsafe extern "C" fn(action:
                                                                     *mut GAction,
                                                                 value:
                                                                     *mut GVariant)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(action:
                                                                 *mut GAction,
                                                             parameter:
                                                                 *mut GVariant)>,
}
impl ::std::clone::Clone for Struct__GActionInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GActionInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GActionGroupInterface = Struct__GActionGroupInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub has_action: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                   *mut GActionGroup,
                                                               action_name:
                                                                   *const gchar)
                                              -> gboolean>,
    pub list_actions: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                     *mut GActionGroup)
                                                -> *mut *mut gchar>,
    pub get_action_enabled: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                           *mut GActionGroup,
                                                                       action_name:
                                                                           *const gchar)
                                                      -> gboolean>,
    pub get_action_parameter_type: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                                  *mut GActionGroup,
                                                                              action_name:
                                                                                  *const gchar)
                                                             ->
                                                                 *const GVariantType>,
    pub get_action_state_type: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                              *mut GActionGroup,
                                                                          action_name:
                                                                              *const gchar)
                                                         ->
                                                             *const GVariantType>,
    pub get_action_state_hint: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                              *mut GActionGroup,
                                                                          action_name:
                                                                              *const gchar)
                                                         -> *mut GVariant>,
    pub get_action_state: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                         *mut GActionGroup,
                                                                     action_name:
                                                                         *const gchar)
                                                    -> *mut GVariant>,
    pub change_action_state: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                            *mut GActionGroup,
                                                                        action_name:
                                                                            *const gchar,
                                                                        value:
                                                                            *mut GVariant)>,
    pub activate_action: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                        *mut GActionGroup,
                                                                    action_name:
                                                                        *const gchar,
                                                                    parameter:
                                                                        *mut GVariant)>,
    pub action_added: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                     *mut GActionGroup,
                                                                 action_name:
                                                                     *const gchar)>,
    pub action_removed: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                       *mut GActionGroup,
                                                                   action_name:
                                                                       *const gchar)>,
    pub action_enabled_changed: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                               *mut GActionGroup,
                                                                           action_name:
                                                                               *const gchar,
                                                                           enabled:
                                                                               gboolean)>,
    pub action_state_changed: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                             *mut GActionGroup,
                                                                         action_name:
                                                                             *const gchar,
                                                                         state:
                                                                             *mut GVariant)>,
    pub query_action: ::std::option::Option<unsafe extern "C" fn(action_group:
                                                                     *mut GActionGroup,
                                                                 action_name:
                                                                     *const gchar,
                                                                 enabled:
                                                                     *mut gboolean,
                                                                 parameter_type:
                                                                     *mut *const GVariantType,
                                                                 state_type:
                                                                     *mut *const GVariantType,
                                                                 state_hint:
                                                                     *mut *mut GVariant,
                                                                 state:
                                                                     *mut *mut GVariant)
                                                -> gboolean>,
}
impl ::std::clone::Clone for Struct__GActionGroupInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GActionGroupInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GActionMapInterface = Struct__GActionMapInterface;
pub type GActionEntry = Struct__GActionEntry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GActionMapInterface {
    pub g_iface: GTypeInterface,
    pub lookup_action: ::std::option::Option<unsafe extern "C" fn(action_map:
                                                                      *mut GActionMap,
                                                                  action_name:
                                                                      *const gchar)
                                                 -> *mut GAction>,
    pub add_action: ::std::option::Option<unsafe extern "C" fn(action_map:
                                                                   *mut GActionMap,
                                                               action:
                                                                   *mut GAction)>,
    pub remove_action: ::std::option::Option<unsafe extern "C" fn(action_map:
                                                                      *mut GActionMap,
                                                                  action_name:
                                                                      *const gchar)>,
}
impl ::std::clone::Clone for Struct__GActionMapInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GActionMapInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GActionEntry {
    pub name: *const gchar,
    pub activate: ::std::option::Option<unsafe extern "C" fn(action:
                                                                 *mut GSimpleAction,
                                                             parameter:
                                                                 *mut GVariant,
                                                             user_data:
                                                                 gpointer)>,
    pub parameter_type: *const gchar,
    pub state: *const gchar,
    pub change_state: ::std::option::Option<unsafe extern "C" fn(action:
                                                                     *mut GSimpleAction,
                                                                 value:
                                                                     *mut GVariant,
                                                                 user_data:
                                                                     gpointer)>,
    pub padding: [gsize; 3usize],
}
impl ::std::clone::Clone for Struct__GActionEntry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GActionEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GAppLaunchContextClass = Struct__GAppLaunchContextClass;
pub enum Struct__GAppLaunchContextPrivate { }
pub type GAppLaunchContextPrivate = Struct__GAppLaunchContextPrivate;
pub type GAppInfoIface = Struct__GAppInfoIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GAppInfoIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                            *mut GAppInfo)
                                       -> *mut GAppInfo>,
    pub equal: ::std::option::Option<unsafe extern "C" fn(appinfo1:
                                                              *mut GAppInfo,
                                                          appinfo2:
                                                              *mut GAppInfo)
                                         -> gboolean>,
    pub get_id: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                               *mut GAppInfo)
                                          -> *const ::std::os::raw::c_char>,
    pub get_name: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                 *mut GAppInfo)
                                            -> *const ::std::os::raw::c_char>,
    pub get_description: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                        *mut GAppInfo)
                                                   ->
                                                       *const ::std::os::raw::c_char>,
    pub get_executable: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                       *mut GAppInfo)
                                                  ->
                                                      *const ::std::os::raw::c_char>,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                 *mut GAppInfo)
                                            -> *mut GIcon>,
    pub launch: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                               *mut GAppInfo,
                                                           files: *mut GList,
                                                           launch_context:
                                                               *mut GAppLaunchContext,
                                                           error:
                                                               *mut *mut GError)
                                          -> gboolean>,
    pub supports_uris: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                      *mut GAppInfo)
                                                 -> gboolean>,
    pub supports_files: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                       *mut GAppInfo)
                                                  -> gboolean>,
    pub launch_uris: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                    *mut GAppInfo,
                                                                uris:
                                                                    *mut GList,
                                                                launch_context:
                                                                    *mut GAppLaunchContext,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gboolean>,
    pub should_show: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                    *mut GAppInfo)
                                               -> gboolean>,
    pub set_as_default_for_type: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                                *mut GAppInfo,
                                                                            content_type:
                                                                                *const ::std::os::raw::c_char,
                                                                            error:
                                                                                *mut *mut GError)
                                                           -> gboolean>,
    pub set_as_default_for_extension: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                                     *mut GAppInfo,
                                                                                 extension:
                                                                                     *const ::std::os::raw::c_char,
                                                                                 error:
                                                                                     *mut *mut GError)
                                                                -> gboolean>,
    pub add_supports_type: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                          *mut GAppInfo,
                                                                      content_type:
                                                                          *const ::std::os::raw::c_char,
                                                                      error:
                                                                          *mut *mut GError)
                                                     -> gboolean>,
    pub can_remove_supports_type: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                                 *mut GAppInfo)
                                                            -> gboolean>,
    pub remove_supports_type: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                             *mut GAppInfo,
                                                                         content_type:
                                                                             *const ::std::os::raw::c_char,
                                                                         error:
                                                                             *mut *mut GError)
                                                        -> gboolean>,
    pub can_delete: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                   *mut GAppInfo)
                                              -> gboolean>,
    pub do_delete: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                  *mut GAppInfo)
                                             -> gboolean>,
    pub get_commandline: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                        *mut GAppInfo)
                                                   ->
                                                       *const ::std::os::raw::c_char>,
    pub get_display_name: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                         *mut GAppInfo)
                                                    ->
                                                        *const ::std::os::raw::c_char>,
    pub set_as_last_used_for_type: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                                  *mut GAppInfo,
                                                                              content_type:
                                                                                  *const ::std::os::raw::c_char,
                                                                              error:
                                                                                  *mut *mut GError)
                                                             -> gboolean>,
    pub get_supported_types: ::std::option::Option<unsafe extern "C" fn(appinfo:
                                                                            *mut GAppInfo)
                                                       ->
                                                           *mut *const ::std::os::raw::c_char>,
}
impl ::std::clone::Clone for Struct__GAppInfoIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GAppInfoIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GAppLaunchContext {
    pub parent_instance: GObject,
    pub _priv: *mut GAppLaunchContextPrivate,
}
impl ::std::clone::Clone for Struct__GAppLaunchContext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GAppLaunchContext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GAppLaunchContextClass {
    pub parent_class: GObjectClass,
    pub get_display: ::std::option::Option<unsafe extern "C" fn(context:
                                                                    *mut GAppLaunchContext,
                                                                info:
                                                                    *mut GAppInfo,
                                                                files:
                                                                    *mut GList)
                                               ->
                                                   *mut ::std::os::raw::c_char>,
    pub get_startup_notify_id: ::std::option::Option<unsafe extern "C" fn(context:
                                                                              *mut GAppLaunchContext,
                                                                          info:
                                                                              *mut GAppInfo,
                                                                          files:
                                                                              *mut GList)
                                                         ->
                                                             *mut ::std::os::raw::c_char>,
    pub launch_failed: ::std::option::Option<unsafe extern "C" fn(context:
                                                                      *mut GAppLaunchContext,
                                                                  startup_notify_id:
                                                                      *const ::std::os::raw::c_char)>,
    pub launched: ::std::option::Option<unsafe extern "C" fn(context:
                                                                 *mut GAppLaunchContext,
                                                             info:
                                                                 *mut GAppInfo,
                                                             platform_data:
                                                                 *mut GVariant)>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GAppLaunchContextClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GAppLaunchContextClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GAppInfoMonitor { }
pub type GAppInfoMonitor = Struct__GAppInfoMonitor;
pub enum Struct__GApplicationPrivate { }
pub type GApplicationPrivate = Struct__GApplicationPrivate;
pub type GApplicationClass = Struct__GApplicationClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GApplication {
    pub parent_instance: GObject,
    pub _priv: *mut GApplicationPrivate,
}
impl ::std::clone::Clone for Struct__GApplication {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GApplication {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GApplicationClass {
    pub parent_class: GObjectClass,
    pub startup: ::std::option::Option<unsafe extern "C" fn(application:
                                                                *mut GApplication)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(application:
                                                                 *mut GApplication)>,
    pub open: ::std::option::Option<unsafe extern "C" fn(application:
                                                             *mut GApplication,
                                                         files:
                                                             *mut *mut GFile,
                                                         n_files: gint,
                                                         hint: *const gchar)>,
    pub command_line: ::std::option::Option<unsafe extern "C" fn(application:
                                                                     *mut GApplication,
                                                                 command_line:
                                                                     *mut GApplicationCommandLine)
                                                -> ::std::os::raw::c_int>,
    pub local_command_line: ::std::option::Option<unsafe extern "C" fn(application:
                                                                           *mut GApplication,
                                                                       arguments:
                                                                           *mut *mut *mut gchar,
                                                                       exit_status:
                                                                           *mut ::std::os::raw::c_int)
                                                      -> gboolean>,
    pub before_emit: ::std::option::Option<unsafe extern "C" fn(application:
                                                                    *mut GApplication,
                                                                platform_data:
                                                                    *mut GVariant)>,
    pub after_emit: ::std::option::Option<unsafe extern "C" fn(application:
                                                                   *mut GApplication,
                                                               platform_data:
                                                                   *mut GVariant)>,
    pub add_platform_data: ::std::option::Option<unsafe extern "C" fn(application:
                                                                          *mut GApplication,
                                                                      builder:
                                                                          *mut GVariantBuilder)>,
    pub quit_mainloop: ::std::option::Option<unsafe extern "C" fn(application:
                                                                      *mut GApplication)>,
    pub run_mainloop: ::std::option::Option<unsafe extern "C" fn(application:
                                                                     *mut GApplication)>,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(application:
                                                                 *mut GApplication)>,
    pub dbus_register: ::std::option::Option<unsafe extern "C" fn(application:
                                                                      *mut GApplication,
                                                                  connection:
                                                                      *mut GDBusConnection,
                                                                  object_path:
                                                                      *const gchar,
                                                                  error:
                                                                      *mut *mut GError)
                                                 -> gboolean>,
    pub dbus_unregister: ::std::option::Option<unsafe extern "C" fn(application:
                                                                        *mut GApplication,
                                                                    connection:
                                                                        *mut GDBusConnection,
                                                                    object_path:
                                                                        *const gchar)>,
    pub handle_local_options: ::std::option::Option<unsafe extern "C" fn(application:
                                                                             *mut GApplication,
                                                                         options:
                                                                             *mut GVariantDict)
                                                        -> gint>,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GApplicationClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GApplicationClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GApplicationCommandLinePrivate { }
pub type GApplicationCommandLinePrivate =
    Struct__GApplicationCommandLinePrivate;
pub type GApplicationCommandLineClass = Struct__GApplicationCommandLineClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GApplicationCommandLine {
    pub parent_instance: GObject,
    pub _priv: *mut GApplicationCommandLinePrivate,
}
impl ::std::clone::Clone for Struct__GApplicationCommandLine {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GApplicationCommandLine {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GApplicationCommandLineClass {
    pub parent_class: GObjectClass,
    pub print_literal: ::std::option::Option<unsafe extern "C" fn(cmdline:
                                                                      *mut GApplicationCommandLine,
                                                                  message:
                                                                      *const gchar)>,
    pub printerr_literal: ::std::option::Option<unsafe extern "C" fn(cmdline:
                                                                         *mut GApplicationCommandLine,
                                                                     message:
                                                                         *const gchar)>,
    pub get_stdin: ::std::option::Option<unsafe extern "C" fn(cmdline:
                                                                  *mut GApplicationCommandLine)
                                             -> *mut GInputStream>,
    pub padding: [gpointer; 11usize],
}
impl ::std::clone::Clone for Struct__GApplicationCommandLineClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GApplicationCommandLineClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GInitableIface = Struct__GInitableIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInitableIface {
    pub g_iface: GTypeInterface,
    pub init: ::std::option::Option<unsafe extern "C" fn(initable:
                                                             *mut GInitable,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
                                        -> gboolean>,
}
impl ::std::clone::Clone for Struct__GInitableIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInitableIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GAsyncInitableIface = Struct__GAsyncInitableIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GAsyncInitableIface {
    pub g_iface: GTypeInterface,
    pub init_async: ::std::option::Option<unsafe extern "C" fn(initable:
                                                                   *mut GAsyncInitable,
                                                               io_priority:
                                                                   ::std::os::raw::c_int,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               callback:
                                                                   GAsyncReadyCallback,
                                                               user_data:
                                                                   gpointer)>,
    pub init_finish: ::std::option::Option<unsafe extern "C" fn(initable:
                                                                    *mut GAsyncInitable,
                                                                res:
                                                                    *mut GAsyncResult,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gboolean>,
}
impl ::std::clone::Clone for Struct__GAsyncInitableIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GAsyncInitableIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GAsyncResultIface = Struct__GAsyncResultIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GAsyncResultIface {
    pub g_iface: GTypeInterface,
    pub get_user_data: ::std::option::Option<unsafe extern "C" fn(res:
                                                                      *mut GAsyncResult)
                                                 -> gpointer>,
    pub get_source_object: ::std::option::Option<unsafe extern "C" fn(res:
                                                                          *mut GAsyncResult)
                                                     -> *mut GObject>,
    pub is_tagged: ::std::option::Option<unsafe extern "C" fn(res:
                                                                  *mut GAsyncResult,
                                                              source_tag:
                                                                  gpointer)
                                             -> gboolean>,
}
impl ::std::clone::Clone for Struct__GAsyncResultIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GAsyncResultIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GInputStreamClass = Struct__GInputStreamClass;
pub enum Struct__GInputStreamPrivate { }
pub type GInputStreamPrivate = Struct__GInputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInputStream {
    pub parent_instance: GObject,
    pub _priv: *mut GInputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GInputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInputStreamClass {
    pub parent_class: GObjectClass,
    pub read_fn: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                *mut GInputStream,
                                                            buffer:
                                                                *mut ::std::os::raw::c_void,
                                                            count: gsize,
                                                            cancellable:
                                                                *mut GCancellable,
                                                            error:
                                                                *mut *mut GError)
                                           -> gssize>,
    pub skip: ::std::option::Option<unsafe extern "C" fn(stream:
                                                             *mut GInputStream,
                                                         count: gsize,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
                                        -> gssize>,
    pub close_fn: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GInputStream,
                                                             cancellable:
                                                                 *mut GCancellable,
                                                             error:
                                                                 *mut *mut GError)
                                            -> gboolean>,
    pub read_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                   *mut GInputStream,
                                                               buffer:
                                                                   *mut ::std::os::raw::c_void,
                                                               count: gsize,
                                                               io_priority:
                                                                   ::std::os::raw::c_int,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               callback:
                                                                   GAsyncReadyCallback,
                                                               user_data:
                                                                   gpointer)>,
    pub read_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GInputStream,
                                                                result:
                                                                    *mut GAsyncResult,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gssize>,
    pub skip_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                   *mut GInputStream,
                                                               count: gsize,
                                                               io_priority:
                                                                   ::std::os::raw::c_int,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               callback:
                                                                   GAsyncReadyCallback,
                                                               user_data:
                                                                   gpointer)>,
    pub skip_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GInputStream,
                                                                result:
                                                                    *mut GAsyncResult,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gssize>,
    pub close_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GInputStream,
                                                                io_priority:
                                                                    ::std::os::raw::c_int,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                callback:
                                                                    GAsyncReadyCallback,
                                                                user_data:
                                                                    gpointer)>,
    pub close_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                     *mut GInputStream,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GInputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GFilterInputStreamClass = Struct__GFilterInputStreamClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFilterInputStream {
    pub parent_instance: GInputStream,
    pub base_stream: *mut GInputStream,
}
impl ::std::clone::Clone for Struct__GFilterInputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFilterInputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFilterInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GFilterInputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFilterInputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GBufferedInputStreamClass = Struct__GBufferedInputStreamClass;
pub enum Struct__GBufferedInputStreamPrivate { }
pub type GBufferedInputStreamPrivate = Struct__GBufferedInputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GBufferedInputStream {
    pub parent_instance: GFilterInputStream,
    pub _priv: *mut GBufferedInputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GBufferedInputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GBufferedInputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GBufferedInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub fill: ::std::option::Option<unsafe extern "C" fn(stream:
                                                             *mut GBufferedInputStream,
                                                         count: gssize,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
                                        -> gssize>,
    pub fill_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                   *mut GBufferedInputStream,
                                                               count: gssize,
                                                               io_priority:
                                                                   ::std::os::raw::c_int,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               callback:
                                                                   GAsyncReadyCallback,
                                                               user_data:
                                                                   gpointer)>,
    pub fill_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GBufferedInputStream,
                                                                result:
                                                                    *mut GAsyncResult,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gssize>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GBufferedInputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GBufferedInputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GOutputStreamClass = Struct__GOutputStreamClass;
pub enum Struct__GOutputStreamPrivate { }
pub type GOutputStreamPrivate = Struct__GOutputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GOutputStream {
    pub parent_instance: GObject,
    pub _priv: *mut GOutputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GOutputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GOutputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GOutputStreamClass {
    pub parent_class: GObjectClass,
    pub write_fn: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GOutputStream,
                                                             buffer:
                                                                 *const ::std::os::raw::c_void,
                                                             count: gsize,
                                                             cancellable:
                                                                 *mut GCancellable,
                                                             error:
                                                                 *mut *mut GError)
                                            -> gssize>,
    pub splice: ::std::option::Option<unsafe extern "C" fn(stream:
                                                               *mut GOutputStream,
                                                           source:
                                                               *mut GInputStream,
                                                           flags:
                                                               GOutputStreamSpliceFlags,
                                                           cancellable:
                                                               *mut GCancellable,
                                                           error:
                                                               *mut *mut GError)
                                          -> gssize>,
    pub flush: ::std::option::Option<unsafe extern "C" fn(stream:
                                                              *mut GOutputStream,
                                                          cancellable:
                                                              *mut GCancellable,
                                                          error:
                                                              *mut *mut GError)
                                         -> gboolean>,
    pub close_fn: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GOutputStream,
                                                             cancellable:
                                                                 *mut GCancellable,
                                                             error:
                                                                 *mut *mut GError)
                                            -> gboolean>,
    pub write_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GOutputStream,
                                                                buffer:
                                                                    *const ::std::os::raw::c_void,
                                                                count: gsize,
                                                                io_priority:
                                                                    ::std::os::raw::c_int,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                callback:
                                                                    GAsyncReadyCallback,
                                                                user_data:
                                                                    gpointer)>,
    pub write_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                     *mut GOutputStream,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gssize>,
    pub splice_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                     *mut GOutputStream,
                                                                 source:
                                                                     *mut GInputStream,
                                                                 flags:
                                                                     GOutputStreamSpliceFlags,
                                                                 io_priority:
                                                                     ::std::os::raw::c_int,
                                                                 cancellable:
                                                                     *mut GCancellable,
                                                                 callback:
                                                                     GAsyncReadyCallback,
                                                                 user_data:
                                                                     gpointer)>,
    pub splice_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                      *mut GOutputStream,
                                                                  result:
                                                                      *mut GAsyncResult,
                                                                  error:
                                                                      *mut *mut GError)
                                                 -> gssize>,
    pub flush_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GOutputStream,
                                                                io_priority:
                                                                    ::std::os::raw::c_int,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                callback:
                                                                    GAsyncReadyCallback,
                                                                user_data:
                                                                    gpointer)>,
    pub flush_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                     *mut GOutputStream,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub close_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GOutputStream,
                                                                io_priority:
                                                                    ::std::os::raw::c_int,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                callback:
                                                                    GAsyncReadyCallback,
                                                                user_data:
                                                                    gpointer)>,
    pub close_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                     *mut GOutputStream,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GOutputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GOutputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GFilterOutputStreamClass = Struct__GFilterOutputStreamClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFilterOutputStream {
    pub parent_instance: GOutputStream,
    pub base_stream: *mut GOutputStream,
}
impl ::std::clone::Clone for Struct__GFilterOutputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFilterOutputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFilterOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GFilterOutputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFilterOutputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GBufferedOutputStreamClass = Struct__GBufferedOutputStreamClass;
pub enum Struct__GBufferedOutputStreamPrivate { }
pub type GBufferedOutputStreamPrivate = Struct__GBufferedOutputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GBufferedOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub _priv: *mut GBufferedOutputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GBufferedOutputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GBufferedOutputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GBufferedOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GBufferedOutputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GBufferedOutputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GCancellableClass = Struct__GCancellableClass;
pub enum Struct__GCancellablePrivate { }
pub type GCancellablePrivate = Struct__GCancellablePrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GCancellable {
    pub parent_instance: GObject,
    pub _priv: *mut GCancellablePrivate,
}
impl ::std::clone::Clone for Struct__GCancellable {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GCancellable {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GCancellableClass {
    pub parent_class: GObjectClass,
    pub cancelled: ::std::option::Option<unsafe extern "C" fn(cancellable:
                                                                  *mut GCancellable)>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GCancellableClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GCancellableClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GConverterIface = Struct__GConverterIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GConverterIface {
    pub g_iface: GTypeInterface,
    pub convert: ::std::option::Option<unsafe extern "C" fn(converter:
                                                                *mut GConverter,
                                                            inbuf:
                                                                *const ::std::os::raw::c_void,
                                                            inbuf_size: gsize,
                                                            outbuf:
                                                                *mut ::std::os::raw::c_void,
                                                            outbuf_size:
                                                                gsize,
                                                            flags:
                                                                GConverterFlags,
                                                            bytes_read:
                                                                *mut gsize,
                                                            bytes_written:
                                                                *mut gsize,
                                                            error:
                                                                *mut *mut GError)
                                           -> GConverterResult>,
    pub reset: ::std::option::Option<unsafe extern "C" fn(converter:
                                                              *mut GConverter)>,
}
impl ::std::clone::Clone for Struct__GConverterIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GConverterIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GCharsetConverterClass = Struct__GCharsetConverterClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GCharsetConverterClass {
    pub parent_class: GObjectClass,
}
impl ::std::clone::Clone for Struct__GCharsetConverterClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GCharsetConverterClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GConverterInputStreamClass = Struct__GConverterInputStreamClass;
pub enum Struct__GConverterInputStreamPrivate { }
pub type GConverterInputStreamPrivate = Struct__GConverterInputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GConverterInputStream {
    pub parent_instance: GFilterInputStream,
    pub _priv: *mut GConverterInputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GConverterInputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GConverterInputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GConverterInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GConverterInputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GConverterInputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GConverterOutputStreamClass = Struct__GConverterOutputStreamClass;
pub enum Struct__GConverterOutputStreamPrivate { }
pub type GConverterOutputStreamPrivate =
    Struct__GConverterOutputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GConverterOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub _priv: *mut GConverterOutputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GConverterOutputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GConverterOutputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GConverterOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GConverterOutputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GConverterOutputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type useconds_t = __useconds_t;
pub type intptr_t = __intptr_t;
pub type socklen_t = __socklen_t;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed198 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20,
}
pub const _SC_IOV_MAX: Enum_Unnamed199 = Enum_Unnamed199::_SC_UIO_MAXIOV;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed199 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed200 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149,
}
pub enum Struct__GCredentialsClass { }
pub type GCredentialsClass = Struct__GCredentialsClass;
pub type GDataInputStreamClass = Struct__GDataInputStreamClass;
pub enum Struct__GDataInputStreamPrivate { }
pub type GDataInputStreamPrivate = Struct__GDataInputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDataInputStream {
    pub parent_instance: GBufferedInputStream,
    pub _priv: *mut GDataInputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GDataInputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDataInputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDataInputStreamClass {
    pub parent_class: GBufferedInputStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GDataInputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDataInputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDataOutputStream = Struct__GDataOutputStream;
pub type GDataOutputStreamClass = Struct__GDataOutputStreamClass;
pub enum Struct__GDataOutputStreamPrivate { }
pub type GDataOutputStreamPrivate = Struct__GDataOutputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDataOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub _priv: *mut GDataOutputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GDataOutputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDataOutputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDataOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GDataOutputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDataOutputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusInterfaceMethodCallFunc =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               sender: *const gchar,
                                               object_path: *const gchar,
                                               interface_name: *const gchar,
                                               method_name: *const gchar,
                                               parameters: *mut GVariant,
                                               invocation:
                                                   *mut GDBusMethodInvocation,
                                               user_data: gpointer)>;
pub type GDBusInterfaceGetPropertyFunc =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               sender: *const gchar,
                                               object_path: *const gchar,
                                               interface_name: *const gchar,
                                               property_name: *const gchar,
                                               error: *mut *mut GError,
                                               user_data: gpointer)
                              -> *mut GVariant>;
pub type GDBusInterfaceSetPropertyFunc =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               sender: *const gchar,
                                               object_path: *const gchar,
                                               interface_name: *const gchar,
                                               property_name: *const gchar,
                                               value: *mut GVariant,
                                               error: *mut *mut GError,
                                               user_data: gpointer)
                              -> gboolean>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusInterfaceVTable {
    pub method_call: GDBusInterfaceMethodCallFunc,
    pub get_property: GDBusInterfaceGetPropertyFunc,
    pub set_property: GDBusInterfaceSetPropertyFunc,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GDBusInterfaceVTable {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusInterfaceVTable {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusSubtreeEnumerateFunc =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               sender: *const gchar,
                                               object_path: *const gchar,
                                               user_data: gpointer)
                              -> *mut *mut gchar>;
pub type GDBusSubtreeIntrospectFunc =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               sender: *const gchar,
                                               object_path: *const gchar,
                                               node: *const gchar,
                                               user_data: gpointer)
                              -> *mut *mut GDBusInterfaceInfo>;
pub type GDBusSubtreeDispatchFunc =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               sender: *const gchar,
                                               object_path: *const gchar,
                                               interface_name: *const gchar,
                                               node: *const gchar,
                                               out_user_data: *mut gpointer,
                                               user_data: gpointer)
                              -> *const GDBusInterfaceVTable>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusSubtreeVTable {
    pub enumerate: GDBusSubtreeEnumerateFunc,
    pub introspect: GDBusSubtreeIntrospectFunc,
    pub dispatch: GDBusSubtreeDispatchFunc,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GDBusSubtreeVTable {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusSubtreeVTable {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusSignalCallback =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               sender_name: *const gchar,
                                               object_path: *const gchar,
                                               interface_name: *const gchar,
                                               signal_name: *const gchar,
                                               parameters: *mut GVariant,
                                               user_data: gpointer)>;
pub type GDBusMessageFilterFunction =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               message: *mut GDBusMessage,
                                               incoming: gboolean,
                                               user_data: gpointer)
                              -> *mut GDBusMessage>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusErrorEntry {
    pub error_code: gint,
    pub dbus_error_name: *const gchar,
}
impl ::std::clone::Clone for Struct__GDBusErrorEntry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusErrorEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusAnnotationInfo {
    pub ref_count: gint,
    pub key: *mut gchar,
    pub value: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
impl ::std::clone::Clone for Struct__GDBusAnnotationInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusAnnotationInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusArgInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
impl ::std::clone::Clone for Struct__GDBusArgInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusArgInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusMethodInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub in_args: *mut *mut GDBusArgInfo,
    pub out_args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
impl ::std::clone::Clone for Struct__GDBusMethodInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusMethodInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusSignalInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
impl ::std::clone::Clone for Struct__GDBusSignalInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusSignalInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusPropertyInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub flags: GDBusPropertyInfoFlags,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
impl ::std::clone::Clone for Struct__GDBusPropertyInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusPropertyInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusInterfaceInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub methods: *mut *mut GDBusMethodInfo,
    pub signals: *mut *mut GDBusSignalInfo,
    pub properties: *mut *mut GDBusPropertyInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
impl ::std::clone::Clone for Struct__GDBusInterfaceInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusInterfaceInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusNodeInfo {
    pub ref_count: gint,
    pub path: *mut gchar,
    pub interfaces: *mut *mut GDBusInterfaceInfo,
    pub nodes: *mut *mut GDBusNodeInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
impl ::std::clone::Clone for Struct__GDBusNodeInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusNodeInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GBusAcquiredCallback =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               name: *const gchar,
                                               user_data: gpointer)>;
pub type GBusNameAcquiredCallback =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               name: *const gchar,
                                               user_data: gpointer)>;
pub type GBusNameLostCallback =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               name: *const gchar,
                                               user_data: gpointer)>;
pub type GBusNameAppearedCallback =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               name: *const gchar,
                                               name_owner: *const gchar,
                                               user_data: gpointer)>;
pub type GBusNameVanishedCallback =
    ::std::option::Option<unsafe extern "C" fn(connection:
                                                   *mut GDBusConnection,
                                               name: *const gchar,
                                               user_data: gpointer)>;
pub type GDBusProxyClass = Struct__GDBusProxyClass;
pub enum Struct__GDBusProxyPrivate { }
pub type GDBusProxyPrivate = Struct__GDBusProxyPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusProxy {
    pub parent_instance: GObject,
    pub _priv: *mut GDBusProxyPrivate,
}
impl ::std::clone::Clone for Struct__GDBusProxy {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusProxy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusProxyClass {
    pub parent_class: GObjectClass,
    pub g_properties_changed: ::std::option::Option<unsafe extern "C" fn(proxy:
                                                                             *mut GDBusProxy,
                                                                         changed_properties:
                                                                             *mut GVariant,
                                                                         invalidated_properties:
                                                                             *const *const gchar)>,
    pub g_signal: ::std::option::Option<unsafe extern "C" fn(proxy:
                                                                 *mut GDBusProxy,
                                                             sender_name:
                                                                 *const gchar,
                                                             signal_name:
                                                                 *const gchar,
                                                             parameters:
                                                                 *mut GVariant)>,
    pub padding: [gpointer; 32usize],
}
impl ::std::clone::Clone for Struct__GDBusProxyClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusProxyClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDriveIface = Struct__GDriveIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDriveIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                *mut GDrive)>,
    pub disconnected: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                     *mut GDrive)>,
    pub eject_button: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                     *mut GDrive)>,
    pub get_name: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                 *mut GDrive)
                                            -> *mut ::std::os::raw::c_char>,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                 *mut GDrive)
                                            -> *mut GIcon>,
    pub has_volumes: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                    *mut GDrive)
                                               -> gboolean>,
    pub get_volumes: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                    *mut GDrive)
                                               -> *mut GList>,
    pub is_media_removable: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                           *mut GDrive)
                                                      -> gboolean>,
    pub has_media: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                  *mut GDrive)
                                             -> gboolean>,
    pub is_media_check_automatic: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                                 *mut GDrive)
                                                            -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                  *mut GDrive)
                                             -> gboolean>,
    pub can_poll_for_media: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                           *mut GDrive)
                                                      -> gboolean>,
    pub eject: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive,
                                                          flags:
                                                              GMountUnmountFlags,
                                                          cancellable:
                                                              *mut GCancellable,
                                                          callback:
                                                              GAsyncReadyCallback,
                                                          user_data:
                                                              gpointer)>,
    pub eject_finish: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                     *mut GDrive,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub poll_for_media: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                       *mut GDrive,
                                                                   cancellable:
                                                                       *mut GCancellable,
                                                                   callback:
                                                                       GAsyncReadyCallback,
                                                                   user_data:
                                                                       gpointer)>,
    pub poll_for_media_finish: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                              *mut GDrive,
                                                                          result:
                                                                              *mut GAsyncResult,
                                                                          error:
                                                                              *mut *mut GError)
                                                         -> gboolean>,
    pub get_identifier: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                       *mut GDrive,
                                                                   kind:
                                                                       *const ::std::os::raw::c_char)
                                                  ->
                                                      *mut ::std::os::raw::c_char>,
    pub enumerate_identifiers: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                              *mut GDrive)
                                                         ->
                                                             *mut *mut ::std::os::raw::c_char>,
    pub get_start_stop_type: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                            *mut GDrive)
                                                       ->
                                                           GDriveStartStopType>,
    pub can_start: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                  *mut GDrive)
                                             -> gboolean>,
    pub can_start_degraded: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                           *mut GDrive)
                                                      -> gboolean>,
    pub start: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive,
                                                          flags:
                                                              GDriveStartFlags,
                                                          mount_operation:
                                                              *mut GMountOperation,
                                                          cancellable:
                                                              *mut GCancellable,
                                                          callback:
                                                              GAsyncReadyCallback,
                                                          user_data:
                                                              gpointer)>,
    pub start_finish: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                     *mut GDrive,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub can_stop: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                 *mut GDrive)
                                            -> gboolean>,
    pub stop: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive,
                                                         flags:
                                                             GMountUnmountFlags,
                                                         mount_operation:
                                                             *mut GMountOperation,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         callback:
                                                             GAsyncReadyCallback,
                                                         user_data:
                                                             gpointer)>,
    pub stop_finish: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                    *mut GDrive,
                                                                result:
                                                                    *mut GAsyncResult,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gboolean>,
    pub stop_button: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                    *mut GDrive)>,
    pub eject_with_operation: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                             *mut GDrive,
                                                                         flags:
                                                                             GMountUnmountFlags,
                                                                         mount_operation:
                                                                             *mut GMountOperation,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         callback:
                                                                             GAsyncReadyCallback,
                                                                         user_data:
                                                                             gpointer)>,
    pub eject_with_operation_finish: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                                    *mut GDrive,
                                                                                result:
                                                                                    *mut GAsyncResult,
                                                                                error:
                                                                                    *mut *mut GError)
                                                               -> gboolean>,
    pub get_sort_key: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                     *mut GDrive)
                                                -> *const gchar>,
    pub get_symbolic_icon: ::std::option::Option<unsafe extern "C" fn(drive:
                                                                          *mut GDrive)
                                                     -> *mut GIcon>,
}
impl ::std::clone::Clone for Struct__GDriveIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDriveIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GIconIface = Struct__GIconIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GIconIface {
    pub g_iface: GTypeInterface,
    pub hash: ::std::option::Option<unsafe extern "C" fn(icon: *mut GIcon)
                                        -> guint>,
    pub equal: ::std::option::Option<unsafe extern "C" fn(icon1: *mut GIcon,
                                                          icon2: *mut GIcon)
                                         -> gboolean>,
    pub to_tokens: ::std::option::Option<unsafe extern "C" fn(icon:
                                                                  *mut GIcon,
                                                              tokens:
                                                                  *mut GPtrArray,
                                                              out_version:
                                                                  *mut gint)
                                             -> gboolean>,
    pub from_tokens: ::std::option::Option<unsafe extern "C" fn(tokens:
                                                                    *mut *mut gchar,
                                                                num_tokens:
                                                                    gint,
                                                                version: gint,
                                                                error:
                                                                    *mut *mut GError)
                                               -> *mut GIcon>,
    pub serialize: ::std::option::Option<unsafe extern "C" fn(icon:
                                                                  *mut GIcon)
                                             -> *mut GVariant>,
}
impl ::std::clone::Clone for Struct__GIconIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GIconIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GEmblem { }
pub type GEmblem = Struct__GEmblem;
pub enum Struct__GEmblemClass { }
pub type GEmblemClass = Struct__GEmblemClass;
pub type GEmblemedIcon = Struct__GEmblemedIcon;
pub type GEmblemedIconClass = Struct__GEmblemedIconClass;
pub enum Struct__GEmblemedIconPrivate { }
pub type GEmblemedIconPrivate = Struct__GEmblemedIconPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GEmblemedIcon {
    pub parent_instance: GObject,
    pub _priv: *mut GEmblemedIconPrivate,
}
impl ::std::clone::Clone for Struct__GEmblemedIcon {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GEmblemedIcon {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GEmblemedIconClass {
    pub parent_class: GObjectClass,
}
impl ::std::clone::Clone for Struct__GEmblemedIconClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GEmblemedIconClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileAttributeInfo {
    pub name: *mut ::std::os::raw::c_char,
    pub _type: GFileAttributeType,
    pub flags: GFileAttributeInfoFlags,
}
impl ::std::clone::Clone for Struct__GFileAttributeInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileAttributeInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileAttributeInfoList {
    pub infos: *mut GFileAttributeInfo,
    pub n_infos: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct__GFileAttributeInfoList {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileAttributeInfoList {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GFileEnumeratorClass = Struct__GFileEnumeratorClass;
pub enum Struct__GFileEnumeratorPrivate { }
pub type GFileEnumeratorPrivate = Struct__GFileEnumeratorPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileEnumerator {
    pub parent_instance: GObject,
    pub _priv: *mut GFileEnumeratorPrivate,
}
impl ::std::clone::Clone for Struct__GFileEnumerator {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileEnumerator {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next_file: ::std::option::Option<unsafe extern "C" fn(enumerator:
                                                                  *mut GFileEnumerator,
                                                              cancellable:
                                                                  *mut GCancellable,
                                                              error:
                                                                  *mut *mut GError)
                                             -> *mut GFileInfo>,
    pub close_fn: ::std::option::Option<unsafe extern "C" fn(enumerator:
                                                                 *mut GFileEnumerator,
                                                             cancellable:
                                                                 *mut GCancellable,
                                                             error:
                                                                 *mut *mut GError)
                                            -> gboolean>,
    pub next_files_async: ::std::option::Option<unsafe extern "C" fn(enumerator:
                                                                         *mut GFileEnumerator,
                                                                     num_files:
                                                                         ::std::os::raw::c_int,
                                                                     io_priority:
                                                                         ::std::os::raw::c_int,
                                                                     cancellable:
                                                                         *mut GCancellable,
                                                                     callback:
                                                                         GAsyncReadyCallback,
                                                                     user_data:
                                                                         gpointer)>,
    pub next_files_finish: ::std::option::Option<unsafe extern "C" fn(enumerator:
                                                                          *mut GFileEnumerator,
                                                                      result:
                                                                          *mut GAsyncResult,
                                                                      error:
                                                                          *mut *mut GError)
                                                     -> *mut GList>,
    pub close_async: ::std::option::Option<unsafe extern "C" fn(enumerator:
                                                                    *mut GFileEnumerator,
                                                                io_priority:
                                                                    ::std::os::raw::c_int,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                callback:
                                                                    GAsyncReadyCallback,
                                                                user_data:
                                                                    gpointer)>,
    pub close_finish: ::std::option::Option<unsafe extern "C" fn(enumerator:
                                                                     *mut GFileEnumerator,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GFileEnumeratorClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileEnumeratorClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GFileIface = Struct__GFileIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile)
                                       -> *mut GFile>,
    pub hash: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile)
                                        -> guint>,
    pub equal: ::std::option::Option<unsafe extern "C" fn(file1: *mut GFile,
                                                          file2: *mut GFile)
                                         -> gboolean>,
    pub is_native: ::std::option::Option<unsafe extern "C" fn(file:
                                                                  *mut GFile)
                                             -> gboolean>,
    pub has_uri_scheme: ::std::option::Option<unsafe extern "C" fn(file:
                                                                       *mut GFile,
                                                                   uri_scheme:
                                                                       *const ::std::os::raw::c_char)
                                                  -> gboolean>,
    pub get_uri_scheme: ::std::option::Option<unsafe extern "C" fn(file:
                                                                       *mut GFile)
                                                  ->
                                                      *mut ::std::os::raw::c_char>,
    pub get_basename: ::std::option::Option<unsafe extern "C" fn(file:
                                                                     *mut GFile)
                                                ->
                                                    *mut ::std::os::raw::c_char>,
    pub get_path: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile)
                                            -> *mut ::std::os::raw::c_char>,
    pub get_uri: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile)
                                           -> *mut ::std::os::raw::c_char>,
    pub get_parse_name: ::std::option::Option<unsafe extern "C" fn(file:
                                                                       *mut GFile)
                                                  ->
                                                      *mut ::std::os::raw::c_char>,
    pub get_parent: ::std::option::Option<unsafe extern "C" fn(file:
                                                                   *mut GFile)
                                              -> *mut GFile>,
    pub prefix_matches: ::std::option::Option<unsafe extern "C" fn(prefix:
                                                                       *mut GFile,
                                                                   file:
                                                                       *mut GFile)
                                                  -> gboolean>,
    pub get_relative_path: ::std::option::Option<unsafe extern "C" fn(parent:
                                                                          *mut GFile,
                                                                      descendant:
                                                                          *mut GFile)
                                                     ->
                                                         *mut ::std::os::raw::c_char>,
    pub resolve_relative_path: ::std::option::Option<unsafe extern "C" fn(file:
                                                                              *mut GFile,
                                                                          relative_path:
                                                                              *const ::std::os::raw::c_char)
                                                         -> *mut GFile>,
    pub get_child_for_display_name: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                   *mut GFile,
                                                                               display_name:
                                                                                   *const ::std::os::raw::c_char,
                                                                               error:
                                                                                   *mut *mut GError)
                                                              -> *mut GFile>,
    pub enumerate_children: ::std::option::Option<unsafe extern "C" fn(file:
                                                                           *mut GFile,
                                                                       attributes:
                                                                           *const ::std::os::raw::c_char,
                                                                       flags:
                                                                           GFileQueryInfoFlags,
                                                                       cancellable:
                                                                           *mut GCancellable,
                                                                       error:
                                                                           *mut *mut GError)
                                                      ->
                                                          *mut GFileEnumerator>,
    pub enumerate_children_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                 *mut GFile,
                                                                             attributes:
                                                                                 *const ::std::os::raw::c_char,
                                                                             flags:
                                                                                 GFileQueryInfoFlags,
                                                                             io_priority:
                                                                                 ::std::os::raw::c_int,
                                                                             cancellable:
                                                                                 *mut GCancellable,
                                                                             callback:
                                                                                 GAsyncReadyCallback,
                                                                             user_data:
                                                                                 gpointer)>,
    pub enumerate_children_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                  *mut GFile,
                                                                              res:
                                                                                  *mut GAsyncResult,
                                                                              error:
                                                                                  *mut *mut GError)
                                                             ->
                                                                 *mut GFileEnumerator>,
    pub query_info: ::std::option::Option<unsafe extern "C" fn(file:
                                                                   *mut GFile,
                                                               attributes:
                                                                   *const ::std::os::raw::c_char,
                                                               flags:
                                                                   GFileQueryInfoFlags,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               error:
                                                                   *mut *mut GError)
                                              -> *mut GFileInfo>,
    pub query_info_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                         *mut GFile,
                                                                     attributes:
                                                                         *const ::std::os::raw::c_char,
                                                                     flags:
                                                                         GFileQueryInfoFlags,
                                                                     io_priority:
                                                                         ::std::os::raw::c_int,
                                                                     cancellable:
                                                                         *mut GCancellable,
                                                                     callback:
                                                                         GAsyncReadyCallback,
                                                                     user_data:
                                                                         gpointer)>,
    pub query_info_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                          *mut GFile,
                                                                      res:
                                                                          *mut GAsyncResult,
                                                                      error:
                                                                          *mut *mut GError)
                                                     -> *mut GFileInfo>,
    pub query_filesystem_info: ::std::option::Option<unsafe extern "C" fn(file:
                                                                              *mut GFile,
                                                                          attributes:
                                                                              *const ::std::os::raw::c_char,
                                                                          cancellable:
                                                                              *mut GCancellable,
                                                                          error:
                                                                              *mut *mut GError)
                                                         -> *mut GFileInfo>,
    pub query_filesystem_info_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                    *mut GFile,
                                                                                attributes:
                                                                                    *const ::std::os::raw::c_char,
                                                                                io_priority:
                                                                                    ::std::os::raw::c_int,
                                                                                cancellable:
                                                                                    *mut GCancellable,
                                                                                callback:
                                                                                    GAsyncReadyCallback,
                                                                                user_data:
                                                                                    gpointer)>,
    pub query_filesystem_info_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                     *mut GFile,
                                                                                 res:
                                                                                     *mut GAsyncResult,
                                                                                 error:
                                                                                     *mut *mut GError)
                                                                ->
                                                                    *mut GFileInfo>,
    pub find_enclosing_mount: ::std::option::Option<unsafe extern "C" fn(file:
                                                                             *mut GFile,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         error:
                                                                             *mut *mut GError)
                                                        -> *mut GMount>,
    pub find_enclosing_mount_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                   *mut GFile,
                                                                               io_priority:
                                                                                   ::std::os::raw::c_int,
                                                                               cancellable:
                                                                                   *mut GCancellable,
                                                                               callback:
                                                                                   GAsyncReadyCallback,
                                                                               user_data:
                                                                                   gpointer)>,
    pub find_enclosing_mount_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                    *mut GFile,
                                                                                res:
                                                                                    *mut GAsyncResult,
                                                                                error:
                                                                                    *mut *mut GError)
                                                               ->
                                                                   *mut GMount>,
    pub set_display_name: ::std::option::Option<unsafe extern "C" fn(file:
                                                                         *mut GFile,
                                                                     display_name:
                                                                         *const ::std::os::raw::c_char,
                                                                     cancellable:
                                                                         *mut GCancellable,
                                                                     error:
                                                                         *mut *mut GError)
                                                    -> *mut GFile>,
    pub set_display_name_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                               *mut GFile,
                                                                           display_name:
                                                                               *const ::std::os::raw::c_char,
                                                                           io_priority:
                                                                               ::std::os::raw::c_int,
                                                                           cancellable:
                                                                               *mut GCancellable,
                                                                           callback:
                                                                               GAsyncReadyCallback,
                                                                           user_data:
                                                                               gpointer)>,
    pub set_display_name_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                *mut GFile,
                                                                            res:
                                                                                *mut GAsyncResult,
                                                                            error:
                                                                                *mut *mut GError)
                                                           -> *mut GFile>,
    pub query_settable_attributes: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                  *mut GFile,
                                                                              cancellable:
                                                                                  *mut GCancellable,
                                                                              error:
                                                                                  *mut *mut GError)
                                                             ->
                                                                 *mut GFileAttributeInfoList>,
    pub _query_settable_attributes_async: ::std::option::Option<extern "C" fn()>,
    pub _query_settable_attributes_finish: ::std::option::Option<extern "C" fn()>,
    pub query_writable_namespaces: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                  *mut GFile,
                                                                              cancellable:
                                                                                  *mut GCancellable,
                                                                              error:
                                                                                  *mut *mut GError)
                                                             ->
                                                                 *mut GFileAttributeInfoList>,
    pub _query_writable_namespaces_async: ::std::option::Option<extern "C" fn()>,
    pub _query_writable_namespaces_finish: ::std::option::Option<extern "C" fn()>,
    pub set_attribute: ::std::option::Option<unsafe extern "C" fn(file:
                                                                      *mut GFile,
                                                                  attribute:
                                                                      *const ::std::os::raw::c_char,
                                                                  _type:
                                                                      GFileAttributeType,
                                                                  value_p:
                                                                      gpointer,
                                                                  flags:
                                                                      GFileQueryInfoFlags,
                                                                  cancellable:
                                                                      *mut GCancellable,
                                                                  error:
                                                                      *mut *mut GError)
                                                 -> gboolean>,
    pub set_attributes_from_info: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                 *mut GFile,
                                                                             info:
                                                                                 *mut GFileInfo,
                                                                             flags:
                                                                                 GFileQueryInfoFlags,
                                                                             cancellable:
                                                                                 *mut GCancellable,
                                                                             error:
                                                                                 *mut *mut GError)
                                                            -> gboolean>,
    pub set_attributes_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                             *mut GFile,
                                                                         info:
                                                                             *mut GFileInfo,
                                                                         flags:
                                                                             GFileQueryInfoFlags,
                                                                         io_priority:
                                                                             ::std::os::raw::c_int,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         callback:
                                                                             GAsyncReadyCallback,
                                                                         user_data:
                                                                             gpointer)>,
    pub set_attributes_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                              *mut GFile,
                                                                          result:
                                                                              *mut GAsyncResult,
                                                                          info:
                                                                              *mut *mut GFileInfo,
                                                                          error:
                                                                              *mut *mut GError)
                                                         -> gboolean>,
    pub read_fn: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile,
                                                            cancellable:
                                                                *mut GCancellable,
                                                            error:
                                                                *mut *mut GError)
                                           -> *mut GFileInputStream>,
    pub read_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                   *mut GFile,
                                                               io_priority:
                                                                   ::std::os::raw::c_int,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               callback:
                                                                   GAsyncReadyCallback,
                                                               user_data:
                                                                   gpointer)>,
    pub read_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                    *mut GFile,
                                                                res:
                                                                    *mut GAsyncResult,
                                                                error:
                                                                    *mut *mut GError)
                                               -> *mut GFileInputStream>,
    pub append_to: ::std::option::Option<unsafe extern "C" fn(file:
                                                                  *mut GFile,
                                                              flags:
                                                                  GFileCreateFlags,
                                                              cancellable:
                                                                  *mut GCancellable,
                                                              error:
                                                                  *mut *mut GError)
                                             -> *mut GFileOutputStream>,
    pub append_to_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                        *mut GFile,
                                                                    flags:
                                                                        GFileCreateFlags,
                                                                    io_priority:
                                                                        ::std::os::raw::c_int,
                                                                    cancellable:
                                                                        *mut GCancellable,
                                                                    callback:
                                                                        GAsyncReadyCallback,
                                                                    user_data:
                                                                        gpointer)>,
    pub append_to_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                         *mut GFile,
                                                                     res:
                                                                         *mut GAsyncResult,
                                                                     error:
                                                                         *mut *mut GError)
                                                    ->
                                                        *mut GFileOutputStream>,
    pub create: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile,
                                                           flags:
                                                               GFileCreateFlags,
                                                           cancellable:
                                                               *mut GCancellable,
                                                           error:
                                                               *mut *mut GError)
                                          -> *mut GFileOutputStream>,
    pub create_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                     *mut GFile,
                                                                 flags:
                                                                     GFileCreateFlags,
                                                                 io_priority:
                                                                     ::std::os::raw::c_int,
                                                                 cancellable:
                                                                     *mut GCancellable,
                                                                 callback:
                                                                     GAsyncReadyCallback,
                                                                 user_data:
                                                                     gpointer)>,
    pub create_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                      *mut GFile,
                                                                  res:
                                                                      *mut GAsyncResult,
                                                                  error:
                                                                      *mut *mut GError)
                                                 -> *mut GFileOutputStream>,
    pub replace: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile,
                                                            etag:
                                                                *const ::std::os::raw::c_char,
                                                            make_backup:
                                                                gboolean,
                                                            flags:
                                                                GFileCreateFlags,
                                                            cancellable:
                                                                *mut GCancellable,
                                                            error:
                                                                *mut *mut GError)
                                           -> *mut GFileOutputStream>,
    pub replace_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                      *mut GFile,
                                                                  etag:
                                                                      *const ::std::os::raw::c_char,
                                                                  make_backup:
                                                                      gboolean,
                                                                  flags:
                                                                      GFileCreateFlags,
                                                                  io_priority:
                                                                      ::std::os::raw::c_int,
                                                                  cancellable:
                                                                      *mut GCancellable,
                                                                  callback:
                                                                      GAsyncReadyCallback,
                                                                  user_data:
                                                                      gpointer)>,
    pub replace_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                       *mut GFile,
                                                                   res:
                                                                       *mut GAsyncResult,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> *mut GFileOutputStream>,
    pub delete_file: ::std::option::Option<unsafe extern "C" fn(file:
                                                                    *mut GFile,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gboolean>,
    pub delete_file_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                          *mut GFile,
                                                                      io_priority:
                                                                          ::std::os::raw::c_int,
                                                                      cancellable:
                                                                          *mut GCancellable,
                                                                      callback:
                                                                          GAsyncReadyCallback,
                                                                      user_data:
                                                                          gpointer)>,
    pub delete_file_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                           *mut GFile,
                                                                       result:
                                                                           *mut GAsyncResult,
                                                                       error:
                                                                           *mut *mut GError)
                                                      -> gboolean>,
    pub trash: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile,
                                                          cancellable:
                                                              *mut GCancellable,
                                                          error:
                                                              *mut *mut GError)
                                         -> gboolean>,
    pub trash_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                    *mut GFile,
                                                                io_priority:
                                                                    ::std::os::raw::c_int,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                callback:
                                                                    GAsyncReadyCallback,
                                                                user_data:
                                                                    gpointer)>,
    pub trash_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                     *mut GFile,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub make_directory: ::std::option::Option<unsafe extern "C" fn(file:
                                                                       *mut GFile,
                                                                   cancellable:
                                                                       *mut GCancellable,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> gboolean>,
    pub make_directory_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                             *mut GFile,
                                                                         io_priority:
                                                                             ::std::os::raw::c_int,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         callback:
                                                                             GAsyncReadyCallback,
                                                                         user_data:
                                                                             gpointer)>,
    pub make_directory_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                              *mut GFile,
                                                                          result:
                                                                              *mut GAsyncResult,
                                                                          error:
                                                                              *mut *mut GError)
                                                         -> gboolean>,
    pub make_symbolic_link: ::std::option::Option<unsafe extern "C" fn(file:
                                                                           *mut GFile,
                                                                       symlink_value:
                                                                           *const ::std::os::raw::c_char,
                                                                       cancellable:
                                                                           *mut GCancellable,
                                                                       error:
                                                                           *mut *mut GError)
                                                      -> gboolean>,
    pub _make_symbolic_link_async: ::std::option::Option<extern "C" fn()>,
    pub _make_symbolic_link_finish: ::std::option::Option<extern "C" fn()>,
    pub copy: ::std::option::Option<unsafe extern "C" fn(source: *mut GFile,
                                                         destination:
                                                             *mut GFile,
                                                         flags:
                                                             GFileCopyFlags,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         progress_callback:
                                                             GFileProgressCallback,
                                                         progress_callback_data:
                                                             gpointer,
                                                         error:
                                                             *mut *mut GError)
                                        -> gboolean>,
    pub copy_async: ::std::option::Option<unsafe extern "C" fn(source:
                                                                   *mut GFile,
                                                               destination:
                                                                   *mut GFile,
                                                               flags:
                                                                   GFileCopyFlags,
                                                               io_priority:
                                                                   ::std::os::raw::c_int,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               progress_callback:
                                                                   GFileProgressCallback,
                                                               progress_callback_data:
                                                                   gpointer,
                                                               callback:
                                                                   GAsyncReadyCallback,
                                                               user_data:
                                                                   gpointer)>,
    pub copy_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                    *mut GFile,
                                                                res:
                                                                    *mut GAsyncResult,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gboolean>,
    pub _move: ::std::option::Option<unsafe extern "C" fn(source: *mut GFile,
                                                          destination:
                                                              *mut GFile,
                                                          flags:
                                                              GFileCopyFlags,
                                                          cancellable:
                                                              *mut GCancellable,
                                                          progress_callback:
                                                              GFileProgressCallback,
                                                          progress_callback_data:
                                                              gpointer,
                                                          error:
                                                              *mut *mut GError)
                                         -> gboolean>,
    pub _move_async: ::std::option::Option<extern "C" fn()>,
    pub _move_finish: ::std::option::Option<extern "C" fn()>,
    pub mount_mountable: ::std::option::Option<unsafe extern "C" fn(file:
                                                                        *mut GFile,
                                                                    flags:
                                                                        GMountMountFlags,
                                                                    mount_operation:
                                                                        *mut GMountOperation,
                                                                    cancellable:
                                                                        *mut GCancellable,
                                                                    callback:
                                                                        GAsyncReadyCallback,
                                                                    user_data:
                                                                        gpointer)>,
    pub mount_mountable_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                               *mut GFile,
                                                                           result:
                                                                               *mut GAsyncResult,
                                                                           error:
                                                                               *mut *mut GError)
                                                          -> *mut GFile>,
    pub unmount_mountable: ::std::option::Option<unsafe extern "C" fn(file:
                                                                          *mut GFile,
                                                                      flags:
                                                                          GMountUnmountFlags,
                                                                      cancellable:
                                                                          *mut GCancellable,
                                                                      callback:
                                                                          GAsyncReadyCallback,
                                                                      user_data:
                                                                          gpointer)>,
    pub unmount_mountable_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                 *mut GFile,
                                                                             result:
                                                                                 *mut GAsyncResult,
                                                                             error:
                                                                                 *mut *mut GError)
                                                            -> gboolean>,
    pub eject_mountable: ::std::option::Option<unsafe extern "C" fn(file:
                                                                        *mut GFile,
                                                                    flags:
                                                                        GMountUnmountFlags,
                                                                    cancellable:
                                                                        *mut GCancellable,
                                                                    callback:
                                                                        GAsyncReadyCallback,
                                                                    user_data:
                                                                        gpointer)>,
    pub eject_mountable_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                               *mut GFile,
                                                                           result:
                                                                               *mut GAsyncResult,
                                                                           error:
                                                                               *mut *mut GError)
                                                          -> gboolean>,
    pub mount_enclosing_volume: ::std::option::Option<unsafe extern "C" fn(location:
                                                                               *mut GFile,
                                                                           flags:
                                                                               GMountMountFlags,
                                                                           mount_operation:
                                                                               *mut GMountOperation,
                                                                           cancellable:
                                                                               *mut GCancellable,
                                                                           callback:
                                                                               GAsyncReadyCallback,
                                                                           user_data:
                                                                               gpointer)>,
    pub mount_enclosing_volume_finish: ::std::option::Option<unsafe extern "C" fn(location:
                                                                                      *mut GFile,
                                                                                  result:
                                                                                      *mut GAsyncResult,
                                                                                  error:
                                                                                      *mut *mut GError)
                                                                 -> gboolean>,
    pub monitor_dir: ::std::option::Option<unsafe extern "C" fn(file:
                                                                    *mut GFile,
                                                                flags:
                                                                    GFileMonitorFlags,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                error:
                                                                    *mut *mut GError)
                                               -> *mut GFileMonitor>,
    pub monitor_file: ::std::option::Option<unsafe extern "C" fn(file:
                                                                     *mut GFile,
                                                                 flags:
                                                                     GFileMonitorFlags,
                                                                 cancellable:
                                                                     *mut GCancellable,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> *mut GFileMonitor>,
    pub open_readwrite: ::std::option::Option<unsafe extern "C" fn(file:
                                                                       *mut GFile,
                                                                   cancellable:
                                                                       *mut GCancellable,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> *mut GFileIOStream>,
    pub open_readwrite_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                             *mut GFile,
                                                                         io_priority:
                                                                             ::std::os::raw::c_int,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         callback:
                                                                             GAsyncReadyCallback,
                                                                         user_data:
                                                                             gpointer)>,
    pub open_readwrite_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                              *mut GFile,
                                                                          res:
                                                                              *mut GAsyncResult,
                                                                          error:
                                                                              *mut *mut GError)
                                                         ->
                                                             *mut GFileIOStream>,
    pub create_readwrite: ::std::option::Option<unsafe extern "C" fn(file:
                                                                         *mut GFile,
                                                                     flags:
                                                                         GFileCreateFlags,
                                                                     cancellable:
                                                                         *mut GCancellable,
                                                                     error:
                                                                         *mut *mut GError)
                                                    -> *mut GFileIOStream>,
    pub create_readwrite_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                               *mut GFile,
                                                                           flags:
                                                                               GFileCreateFlags,
                                                                           io_priority:
                                                                               ::std::os::raw::c_int,
                                                                           cancellable:
                                                                               *mut GCancellable,
                                                                           callback:
                                                                               GAsyncReadyCallback,
                                                                           user_data:
                                                                               gpointer)>,
    pub create_readwrite_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                *mut GFile,
                                                                            res:
                                                                                *mut GAsyncResult,
                                                                            error:
                                                                                *mut *mut GError)
                                                           ->
                                                               *mut GFileIOStream>,
    pub replace_readwrite: ::std::option::Option<unsafe extern "C" fn(file:
                                                                          *mut GFile,
                                                                      etag:
                                                                          *const ::std::os::raw::c_char,
                                                                      make_backup:
                                                                          gboolean,
                                                                      flags:
                                                                          GFileCreateFlags,
                                                                      cancellable:
                                                                          *mut GCancellable,
                                                                      error:
                                                                          *mut *mut GError)
                                                     -> *mut GFileIOStream>,
    pub replace_readwrite_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                *mut GFile,
                                                                            etag:
                                                                                *const ::std::os::raw::c_char,
                                                                            make_backup:
                                                                                gboolean,
                                                                            flags:
                                                                                GFileCreateFlags,
                                                                            io_priority:
                                                                                ::std::os::raw::c_int,
                                                                            cancellable:
                                                                                *mut GCancellable,
                                                                            callback:
                                                                                GAsyncReadyCallback,
                                                                            user_data:
                                                                                gpointer)>,
    pub replace_readwrite_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                 *mut GFile,
                                                                             res:
                                                                                 *mut GAsyncResult,
                                                                             error:
                                                                                 *mut *mut GError)
                                                            ->
                                                                *mut GFileIOStream>,
    pub start_mountable: ::std::option::Option<unsafe extern "C" fn(file:
                                                                        *mut GFile,
                                                                    flags:
                                                                        GDriveStartFlags,
                                                                    start_operation:
                                                                        *mut GMountOperation,
                                                                    cancellable:
                                                                        *mut GCancellable,
                                                                    callback:
                                                                        GAsyncReadyCallback,
                                                                    user_data:
                                                                        gpointer)>,
    pub start_mountable_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                               *mut GFile,
                                                                           result:
                                                                               *mut GAsyncResult,
                                                                           error:
                                                                               *mut *mut GError)
                                                          -> gboolean>,
    pub stop_mountable: ::std::option::Option<unsafe extern "C" fn(file:
                                                                       *mut GFile,
                                                                   flags:
                                                                       GMountUnmountFlags,
                                                                   mount_operation:
                                                                       *mut GMountOperation,
                                                                   cancellable:
                                                                       *mut GCancellable,
                                                                   callback:
                                                                       GAsyncReadyCallback,
                                                                   user_data:
                                                                       gpointer)>,
    pub stop_mountable_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                              *mut GFile,
                                                                          result:
                                                                              *mut GAsyncResult,
                                                                          error:
                                                                              *mut *mut GError)
                                                         -> gboolean>,
    pub supports_thread_contexts: gboolean,
    pub unmount_mountable_with_operation: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                         *mut GFile,
                                                                                     flags:
                                                                                         GMountUnmountFlags,
                                                                                     mount_operation:
                                                                                         *mut GMountOperation,
                                                                                     cancellable:
                                                                                         *mut GCancellable,
                                                                                     callback:
                                                                                         GAsyncReadyCallback,
                                                                                     user_data:
                                                                                         gpointer)>,
    pub unmount_mountable_with_operation_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                                *mut GFile,
                                                                                            result:
                                                                                                *mut GAsyncResult,
                                                                                            error:
                                                                                                *mut *mut GError)
                                                                           ->
                                                                               gboolean>,
    pub eject_mountable_with_operation: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                       *mut GFile,
                                                                                   flags:
                                                                                       GMountUnmountFlags,
                                                                                   mount_operation:
                                                                                       *mut GMountOperation,
                                                                                   cancellable:
                                                                                       *mut GCancellable,
                                                                                   callback:
                                                                                       GAsyncReadyCallback,
                                                                                   user_data:
                                                                                       gpointer)>,
    pub eject_mountable_with_operation_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                              *mut GFile,
                                                                                          result:
                                                                                              *mut GAsyncResult,
                                                                                          error:
                                                                                              *mut *mut GError)
                                                                         ->
                                                                             gboolean>,
    pub poll_mountable: ::std::option::Option<unsafe extern "C" fn(file:
                                                                       *mut GFile,
                                                                   cancellable:
                                                                       *mut GCancellable,
                                                                   callback:
                                                                       GAsyncReadyCallback,
                                                                   user_data:
                                                                       gpointer)>,
    pub poll_mountable_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                              *mut GFile,
                                                                          result:
                                                                              *mut GAsyncResult,
                                                                          error:
                                                                              *mut *mut GError)
                                                         -> gboolean>,
    pub measure_disk_usage: ::std::option::Option<unsafe extern "C" fn(file:
                                                                           *mut GFile,
                                                                       flags:
                                                                           GFileMeasureFlags,
                                                                       cancellable:
                                                                           *mut GCancellable,
                                                                       progress_callback:
                                                                           GFileMeasureProgressCallback,
                                                                       progress_data:
                                                                           gpointer,
                                                                       disk_usage:
                                                                           *mut guint64,
                                                                       num_dirs:
                                                                           *mut guint64,
                                                                       num_files:
                                                                           *mut guint64,
                                                                       error:
                                                                           *mut *mut GError)
                                                      -> gboolean>,
    pub measure_disk_usage_async: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                 *mut GFile,
                                                                             flags:
                                                                                 GFileMeasureFlags,
                                                                             io_priority:
                                                                                 gint,
                                                                             cancellable:
                                                                                 *mut GCancellable,
                                                                             progress_callback:
                                                                                 GFileMeasureProgressCallback,
                                                                             progress_data:
                                                                                 gpointer,
                                                                             callback:
                                                                                 GAsyncReadyCallback,
                                                                             user_data:
                                                                                 gpointer)>,
    pub measure_disk_usage_finish: ::std::option::Option<unsafe extern "C" fn(file:
                                                                                  *mut GFile,
                                                                              result:
                                                                                  *mut GAsyncResult,
                                                                              disk_usage:
                                                                                  *mut guint64,
                                                                              num_dirs:
                                                                                  *mut guint64,
                                                                              num_files:
                                                                                  *mut guint64,
                                                                              error:
                                                                                  *mut *mut GError)
                                                             -> gboolean>,
}
impl ::std::clone::Clone for Struct__GFileIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GFileIconClass { }
pub type GFileIconClass = Struct__GFileIconClass;
pub enum Struct__GFileInfoClass { }
pub type GFileInfoClass = Struct__GFileInfoClass;
pub type GFileInputStreamClass = Struct__GFileInputStreamClass;
pub enum Struct__GFileInputStreamPrivate { }
pub type GFileInputStreamPrivate = Struct__GFileInputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileInputStream {
    pub parent_instance: GInputStream,
    pub _priv: *mut GFileInputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GFileInputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileInputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream:
                                                             *mut GFileInputStream)
                                        -> goffset>,
    pub can_seek: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GFileInputStream)
                                            -> gboolean>,
    pub seek: ::std::option::Option<unsafe extern "C" fn(stream:
                                                             *mut GFileInputStream,
                                                         offset: goffset,
                                                         _type: GSeekType,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
                                        -> gboolean>,
    pub query_info: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                   *mut GFileInputStream,
                                                               attributes:
                                                                   *const ::std::os::raw::c_char,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               error:
                                                                   *mut *mut GError)
                                              -> *mut GFileInfo>,
    pub query_info_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                         *mut GFileInputStream,
                                                                     attributes:
                                                                         *const ::std::os::raw::c_char,
                                                                     io_priority:
                                                                         ::std::os::raw::c_int,
                                                                     cancellable:
                                                                         *mut GCancellable,
                                                                     callback:
                                                                         GAsyncReadyCallback,
                                                                     user_data:
                                                                         gpointer)>,
    pub query_info_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                          *mut GFileInputStream,
                                                                      result:
                                                                          *mut GAsyncResult,
                                                                      error:
                                                                          *mut *mut GError)
                                                     -> *mut GFileInfo>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GFileInputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileInputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GIOStreamPrivate { }
pub type GIOStreamPrivate = Struct__GIOStreamPrivate;
pub type GIOStreamClass = Struct__GIOStreamClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GIOStream {
    pub parent_instance: GObject,
    pub _priv: *mut GIOStreamPrivate,
}
impl ::std::clone::Clone for Struct__GIOStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GIOStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GIOStreamClass {
    pub parent_class: GObjectClass,
    pub get_input_stream: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                         *mut GIOStream)
                                                    -> *mut GInputStream>,
    pub get_output_stream: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                          *mut GIOStream)
                                                     -> *mut GOutputStream>,
    pub close_fn: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GIOStream,
                                                             cancellable:
                                                                 *mut GCancellable,
                                                             error:
                                                                 *mut *mut GError)
                                            -> gboolean>,
    pub close_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GIOStream,
                                                                io_priority:
                                                                    ::std::os::raw::c_int,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                callback:
                                                                    GAsyncReadyCallback,
                                                                user_data:
                                                                    gpointer)>,
    pub close_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                     *mut GIOStream,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GIOStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GIOStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GFileIOStreamClass = Struct__GFileIOStreamClass;
pub enum Struct__GFileIOStreamPrivate { }
pub type GFileIOStreamPrivate = Struct__GFileIOStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileIOStream {
    pub parent_instance: GIOStream,
    pub _priv: *mut GFileIOStreamPrivate,
}
impl ::std::clone::Clone for Struct__GFileIOStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileIOStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileIOStreamClass {
    pub parent_class: GIOStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream:
                                                             *mut GFileIOStream)
                                        -> goffset>,
    pub can_seek: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GFileIOStream)
                                            -> gboolean>,
    pub seek: ::std::option::Option<unsafe extern "C" fn(stream:
                                                             *mut GFileIOStream,
                                                         offset: goffset,
                                                         _type: GSeekType,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
                                        -> gboolean>,
    pub can_truncate: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                     *mut GFileIOStream)
                                                -> gboolean>,
    pub truncate_fn: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GFileIOStream,
                                                                size: goffset,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gboolean>,
    pub query_info: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                   *mut GFileIOStream,
                                                               attributes:
                                                                   *const ::std::os::raw::c_char,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               error:
                                                                   *mut *mut GError)
                                              -> *mut GFileInfo>,
    pub query_info_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                         *mut GFileIOStream,
                                                                     attributes:
                                                                         *const ::std::os::raw::c_char,
                                                                     io_priority:
                                                                         ::std::os::raw::c_int,
                                                                     cancellable:
                                                                         *mut GCancellable,
                                                                     callback:
                                                                         GAsyncReadyCallback,
                                                                     user_data:
                                                                         gpointer)>,
    pub query_info_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                          *mut GFileIOStream,
                                                                      result:
                                                                          *mut GAsyncResult,
                                                                      error:
                                                                          *mut *mut GError)
                                                     -> *mut GFileInfo>,
    pub get_etag: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GFileIOStream)
                                            -> *mut ::std::os::raw::c_char>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GFileIOStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileIOStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GFileMonitorClass = Struct__GFileMonitorClass;
pub enum Struct__GFileMonitorPrivate { }
pub type GFileMonitorPrivate = Struct__GFileMonitorPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileMonitor {
    pub parent_instance: GObject,
    pub _priv: *mut GFileMonitorPrivate,
}
impl ::std::clone::Clone for Struct__GFileMonitor {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileMonitor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileMonitorClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<unsafe extern "C" fn(monitor:
                                                                *mut GFileMonitor,
                                                            file: *mut GFile,
                                                            other_file:
                                                                *mut GFile,
                                                            event_type:
                                                                GFileMonitorEvent)>,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(monitor:
                                                               *mut GFileMonitor)
                                          -> gboolean>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GFileMonitorClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileMonitorClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GFilenameCompleterClass = Struct__GFilenameCompleterClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFilenameCompleterClass {
    pub parent_class: GObjectClass,
    pub got_completion_data: ::std::option::Option<unsafe extern "C" fn(filename_completer:
                                                                            *mut GFilenameCompleter)>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GFilenameCompleterClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFilenameCompleterClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GFileOutputStreamClass = Struct__GFileOutputStreamClass;
pub enum Struct__GFileOutputStreamPrivate { }
pub type GFileOutputStreamPrivate = Struct__GFileOutputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileOutputStream {
    pub parent_instance: GOutputStream,
    pub _priv: *mut GFileOutputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GFileOutputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileOutputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GFileOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream:
                                                             *mut GFileOutputStream)
                                        -> goffset>,
    pub can_seek: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GFileOutputStream)
                                            -> gboolean>,
    pub seek: ::std::option::Option<unsafe extern "C" fn(stream:
                                                             *mut GFileOutputStream,
                                                         offset: goffset,
                                                         _type: GSeekType,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
                                        -> gboolean>,
    pub can_truncate: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                     *mut GFileOutputStream)
                                                -> gboolean>,
    pub truncate_fn: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GFileOutputStream,
                                                                size: goffset,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gboolean>,
    pub query_info: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                   *mut GFileOutputStream,
                                                               attributes:
                                                                   *const ::std::os::raw::c_char,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               error:
                                                                   *mut *mut GError)
                                              -> *mut GFileInfo>,
    pub query_info_async: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                         *mut GFileOutputStream,
                                                                     attributes:
                                                                         *const ::std::os::raw::c_char,
                                                                     io_priority:
                                                                         ::std::os::raw::c_int,
                                                                     cancellable:
                                                                         *mut GCancellable,
                                                                     callback:
                                                                         GAsyncReadyCallback,
                                                                     user_data:
                                                                         gpointer)>,
    pub query_info_finish: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                          *mut GFileOutputStream,
                                                                      result:
                                                                          *mut GAsyncResult,
                                                                      error:
                                                                          *mut *mut GError)
                                                     -> *mut GFileInfo>,
    pub get_etag: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GFileOutputStream)
                                            -> *mut ::std::os::raw::c_char>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GFileOutputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GFileOutputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GInetAddressClass = Struct__GInetAddressClass;
pub enum Struct__GInetAddressPrivate { }
pub type GInetAddressPrivate = Struct__GInetAddressPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInetAddress {
    pub parent_instance: GObject,
    pub _priv: *mut GInetAddressPrivate,
}
impl ::std::clone::Clone for Struct__GInetAddress {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInetAddress {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInetAddressClass {
    pub parent_class: GObjectClass,
    pub to_string: ::std::option::Option<unsafe extern "C" fn(address:
                                                                  *mut GInetAddress)
                                             -> *mut gchar>,
    pub to_bytes: ::std::option::Option<unsafe extern "C" fn(address:
                                                                 *mut GInetAddress)
                                            -> *const guint8>,
}
impl ::std::clone::Clone for Struct__GInetAddressClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInetAddressClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GInetAddressMaskClass = Struct__GInetAddressMaskClass;
pub enum Struct__GInetAddressMaskPrivate { }
pub type GInetAddressMaskPrivate = Struct__GInetAddressMaskPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInetAddressMask {
    pub parent_instance: GObject,
    pub _priv: *mut GInetAddressMaskPrivate,
}
impl ::std::clone::Clone for Struct__GInetAddressMask {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInetAddressMask {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInetAddressMaskClass {
    pub parent_class: GObjectClass,
}
impl ::std::clone::Clone for Struct__GInetAddressMaskClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInetAddressMaskClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSocketAddressClass = Struct__GSocketAddressClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketAddress {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__GSocketAddress {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketAddress {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketAddressClass {
    pub parent_class: GObjectClass,
    pub get_family: ::std::option::Option<unsafe extern "C" fn(address:
                                                                   *mut GSocketAddress)
                                              -> GSocketFamily>,
    pub get_native_size: ::std::option::Option<unsafe extern "C" fn(address:
                                                                        *mut GSocketAddress)
                                                   -> gssize>,
    pub to_native: ::std::option::Option<unsafe extern "C" fn(address:
                                                                  *mut GSocketAddress,
                                                              dest: gpointer,
                                                              destlen: gsize,
                                                              error:
                                                                  *mut *mut GError)
                                             -> gboolean>,
}
impl ::std::clone::Clone for Struct__GSocketAddressClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketAddressClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GInetSocketAddressClass = Struct__GInetSocketAddressClass;
pub enum Struct__GInetSocketAddressPrivate { }
pub type GInetSocketAddressPrivate = Struct__GInetSocketAddressPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInetSocketAddress {
    pub parent_instance: GSocketAddress,
    pub _priv: *mut GInetSocketAddressPrivate,
}
impl ::std::clone::Clone for Struct__GInetSocketAddress {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInetSocketAddress {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GInetSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
impl ::std::clone::Clone for Struct__GInetSocketAddressClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GInetSocketAddressClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed201 {
    G_MODULE_BIND_LAZY = 1,
    G_MODULE_BIND_LOCAL = 2,
    G_MODULE_BIND_MASK = 3,
}
pub type GModuleFlags = Enum_Unnamed201;
pub enum Struct__GModule { }
pub type GModule = Struct__GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)
                              -> *const gchar>;
pub type GModuleUnload =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
pub enum Struct__GIOModuleScope { }
pub type GIOModuleScope = Struct__GIOModuleScope;
pub enum Struct__GIOModuleClass { }
pub type GIOModuleClass = Struct__GIOModuleClass;
pub type GLoadableIconIface = Struct__GLoadableIconIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GLoadableIconIface {
    pub g_iface: GTypeInterface,
    pub load: ::std::option::Option<unsafe extern "C" fn(icon:
                                                             *mut GLoadableIcon,
                                                         size:
                                                             ::std::os::raw::c_int,
                                                         _type:
                                                             *mut *mut ::std::os::raw::c_char,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
                                        -> *mut GInputStream>,
    pub load_async: ::std::option::Option<unsafe extern "C" fn(icon:
                                                                   *mut GLoadableIcon,
                                                               size:
                                                                   ::std::os::raw::c_int,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               callback:
                                                                   GAsyncReadyCallback,
                                                               user_data:
                                                                   gpointer)>,
    pub load_finish: ::std::option::Option<unsafe extern "C" fn(icon:
                                                                    *mut GLoadableIcon,
                                                                res:
                                                                    *mut GAsyncResult,
                                                                _type:
                                                                    *mut *mut ::std::os::raw::c_char,
                                                                error:
                                                                    *mut *mut GError)
                                               -> *mut GInputStream>,
}
impl ::std::clone::Clone for Struct__GLoadableIconIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GLoadableIconIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GMemoryInputStreamClass = Struct__GMemoryInputStreamClass;
pub enum Struct__GMemoryInputStreamPrivate { }
pub type GMemoryInputStreamPrivate = Struct__GMemoryInputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMemoryInputStream {
    pub parent_instance: GInputStream,
    pub _priv: *mut GMemoryInputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GMemoryInputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMemoryInputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMemoryInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GMemoryInputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMemoryInputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GMemoryOutputStreamClass = Struct__GMemoryOutputStreamClass;
pub enum Struct__GMemoryOutputStreamPrivate { }
pub type GMemoryOutputStreamPrivate = Struct__GMemoryOutputStreamPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMemoryOutputStream {
    pub parent_instance: GOutputStream,
    pub _priv: *mut GMemoryOutputStreamPrivate,
}
impl ::std::clone::Clone for Struct__GMemoryOutputStream {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMemoryOutputStream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMemoryOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GMemoryOutputStreamClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMemoryOutputStreamClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GReallocFunc =
    ::std::option::Option<extern "C" fn(data: gpointer, size: gsize)
                              -> gpointer>;
pub type GMountIface = Struct__GMountIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMountIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                *mut GMount)>,
    pub unmounted: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                  *mut GMount)>,
    pub get_root: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                 *mut GMount)
                                            -> *mut GFile>,
    pub get_name: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                 *mut GMount)
                                            -> *mut ::std::os::raw::c_char>,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                 *mut GMount)
                                            -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                 *mut GMount)
                                            -> *mut ::std::os::raw::c_char>,
    pub get_volume: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                   *mut GMount)
                                              -> *mut GVolume>,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                  *mut GMount)
                                             -> *mut GDrive>,
    pub can_unmount: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                    *mut GMount)
                                               -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                  *mut GMount)
                                             -> gboolean>,
    pub unmount: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                *mut GMount,
                                                            flags:
                                                                GMountUnmountFlags,
                                                            cancellable:
                                                                *mut GCancellable,
                                                            callback:
                                                                GAsyncReadyCallback,
                                                            user_data:
                                                                gpointer)>,
    pub unmount_finish: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                       *mut GMount,
                                                                   result:
                                                                       *mut GAsyncResult,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> gboolean>,
    pub eject: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount,
                                                          flags:
                                                              GMountUnmountFlags,
                                                          cancellable:
                                                              *mut GCancellable,
                                                          callback:
                                                              GAsyncReadyCallback,
                                                          user_data:
                                                              gpointer)>,
    pub eject_finish: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                     *mut GMount,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub remount: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                *mut GMount,
                                                            flags:
                                                                GMountMountFlags,
                                                            mount_operation:
                                                                *mut GMountOperation,
                                                            cancellable:
                                                                *mut GCancellable,
                                                            callback:
                                                                GAsyncReadyCallback,
                                                            user_data:
                                                                gpointer)>,
    pub remount_finish: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                       *mut GMount,
                                                                   result:
                                                                       *mut GAsyncResult,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> gboolean>,
    pub guess_content_type: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                           *mut GMount,
                                                                       force_rescan:
                                                                           gboolean,
                                                                       cancellable:
                                                                           *mut GCancellable,
                                                                       callback:
                                                                           GAsyncReadyCallback,
                                                                       user_data:
                                                                           gpointer)>,
    pub guess_content_type_finish: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                                  *mut GMount,
                                                                              result:
                                                                                  *mut GAsyncResult,
                                                                              error:
                                                                                  *mut *mut GError)
                                                             ->
                                                                 *mut *mut gchar>,
    pub guess_content_type_sync: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                                *mut GMount,
                                                                            force_rescan:
                                                                                gboolean,
                                                                            cancellable:
                                                                                *mut GCancellable,
                                                                            error:
                                                                                *mut *mut GError)
                                                           ->
                                                               *mut *mut gchar>,
    pub pre_unmount: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                    *mut GMount)>,
    pub unmount_with_operation: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                               *mut GMount,
                                                                           flags:
                                                                               GMountUnmountFlags,
                                                                           mount_operation:
                                                                               *mut GMountOperation,
                                                                           cancellable:
                                                                               *mut GCancellable,
                                                                           callback:
                                                                               GAsyncReadyCallback,
                                                                           user_data:
                                                                               gpointer)>,
    pub unmount_with_operation_finish: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                                      *mut GMount,
                                                                                  result:
                                                                                      *mut GAsyncResult,
                                                                                  error:
                                                                                      *mut *mut GError)
                                                                 -> gboolean>,
    pub eject_with_operation: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                             *mut GMount,
                                                                         flags:
                                                                             GMountUnmountFlags,
                                                                         mount_operation:
                                                                             *mut GMountOperation,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         callback:
                                                                             GAsyncReadyCallback,
                                                                         user_data:
                                                                             gpointer)>,
    pub eject_with_operation_finish: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                                    *mut GMount,
                                                                                result:
                                                                                    *mut GAsyncResult,
                                                                                error:
                                                                                    *mut *mut GError)
                                                               -> gboolean>,
    pub get_default_location: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                             *mut GMount)
                                                        -> *mut GFile>,
    pub get_sort_key: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                     *mut GMount)
                                                -> *const gchar>,
    pub get_symbolic_icon: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                          *mut GMount)
                                                     -> *mut GIcon>,
}
impl ::std::clone::Clone for Struct__GMountIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMountIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GMountOperationClass = Struct__GMountOperationClass;
pub enum Struct__GMountOperationPrivate { }
pub type GMountOperationPrivate = Struct__GMountOperationPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMountOperation {
    pub parent_instance: GObject,
    pub _priv: *mut GMountOperationPrivate,
}
impl ::std::clone::Clone for Struct__GMountOperation {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMountOperation {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMountOperationClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<unsafe extern "C" fn(op:
                                                                     *mut GMountOperation,
                                                                 message:
                                                                     *const ::std::os::raw::c_char,
                                                                 default_user:
                                                                     *const ::std::os::raw::c_char,
                                                                 default_domain:
                                                                     *const ::std::os::raw::c_char,
                                                                 flags:
                                                                     GAskPasswordFlags)>,
    pub ask_question: ::std::option::Option<unsafe extern "C" fn(op:
                                                                     *mut GMountOperation,
                                                                 message:
                                                                     *const ::std::os::raw::c_char,
                                                                 choices:
                                                                     *mut *const ::std::os::raw::c_char)>,
    pub reply: ::std::option::Option<unsafe extern "C" fn(op:
                                                              *mut GMountOperation,
                                                          result:
                                                              GMountOperationResult)>,
    pub aborted: ::std::option::Option<unsafe extern "C" fn(op:
                                                                *mut GMountOperation)>,
    pub show_processes: ::std::option::Option<unsafe extern "C" fn(op:
                                                                       *mut GMountOperation,
                                                                   message:
                                                                       *const gchar,
                                                                   processes:
                                                                       *mut GArray,
                                                                   choices:
                                                                       *mut *const gchar)>,
    pub show_unmount_progress: ::std::option::Option<unsafe extern "C" fn(op:
                                                                              *mut GMountOperation,
                                                                          message:
                                                                              *const gchar,
                                                                          time_left:
                                                                              gint64,
                                                                          bytes_left:
                                                                              gint64)>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GMountOperationClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMountOperationClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GVolumeMonitorClass = Struct__GVolumeMonitorClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVolumeMonitor {
    pub parent_instance: GObject,
    pub _priv: gpointer,
}
impl ::std::clone::Clone for Struct__GVolumeMonitor {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GVolumeMonitor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVolumeMonitorClass {
    pub parent_class: GObjectClass,
    pub volume_added: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                     *mut GVolumeMonitor,
                                                                 volume:
                                                                     *mut GVolume)>,
    pub volume_removed: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                       *mut GVolumeMonitor,
                                                                   volume:
                                                                       *mut GVolume)>,
    pub volume_changed: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                       *mut GVolumeMonitor,
                                                                   volume:
                                                                       *mut GVolume)>,
    pub mount_added: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                    *mut GVolumeMonitor,
                                                                mount:
                                                                    *mut GMount)>,
    pub mount_removed: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                      *mut GVolumeMonitor,
                                                                  mount:
                                                                      *mut GMount)>,
    pub mount_pre_unmount: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                          *mut GVolumeMonitor,
                                                                      mount:
                                                                          *mut GMount)>,
    pub mount_changed: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                      *mut GVolumeMonitor,
                                                                  mount:
                                                                      *mut GMount)>,
    pub drive_connected: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                        *mut GVolumeMonitor,
                                                                    drive:
                                                                        *mut GDrive)>,
    pub drive_disconnected: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                           *mut GVolumeMonitor,
                                                                       drive:
                                                                           *mut GDrive)>,
    pub drive_changed: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                      *mut GVolumeMonitor,
                                                                  drive:
                                                                      *mut GDrive)>,
    pub is_supported: ::std::option::Option<extern "C" fn() -> gboolean>,
    pub get_connected_drives: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                             *mut GVolumeMonitor)
                                                        -> *mut GList>,
    pub get_volumes: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                    *mut GVolumeMonitor)
                                               -> *mut GList>,
    pub get_mounts: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                   *mut GVolumeMonitor)
                                              -> *mut GList>,
    pub get_volume_for_uuid: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                            *mut GVolumeMonitor,
                                                                        uuid:
                                                                            *const ::std::os::raw::c_char)
                                                       -> *mut GVolume>,
    pub get_mount_for_uuid: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                           *mut GVolumeMonitor,
                                                                       uuid:
                                                                           *const ::std::os::raw::c_char)
                                                      -> *mut GMount>,
    pub adopt_orphan_mount: ::std::option::Option<unsafe extern "C" fn(mount:
                                                                           *mut GMount,
                                                                       volume_monitor:
                                                                           *mut GVolumeMonitor)
                                                      -> *mut GVolume>,
    pub drive_eject_button: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                           *mut GVolumeMonitor,
                                                                       drive:
                                                                           *mut GDrive)>,
    pub drive_stop_button: ::std::option::Option<unsafe extern "C" fn(volume_monitor:
                                                                          *mut GVolumeMonitor,
                                                                      drive:
                                                                          *mut GDrive)>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GVolumeMonitorClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GVolumeMonitorClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GNativeVolumeMonitor = Struct__GNativeVolumeMonitor;
pub type GNativeVolumeMonitorClass = Struct__GNativeVolumeMonitorClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GNativeVolumeMonitor {
    pub parent_instance: GVolumeMonitor,
}
impl ::std::clone::Clone for Struct__GNativeVolumeMonitor {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GNativeVolumeMonitor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GNativeVolumeMonitorClass {
    pub parent_class: GVolumeMonitorClass,
    pub get_mount_for_mount_path: ::std::option::Option<unsafe extern "C" fn(mount_path:
                                                                                 *const ::std::os::raw::c_char,
                                                                             cancellable:
                                                                                 *mut GCancellable)
                                                            -> *mut GMount>,
}
impl ::std::clone::Clone for Struct__GNativeVolumeMonitorClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GNativeVolumeMonitorClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GNetworkAddressClass = Struct__GNetworkAddressClass;
pub enum Struct__GNetworkAddressPrivate { }
pub type GNetworkAddressPrivate = Struct__GNetworkAddressPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GNetworkAddress {
    pub parent_instance: GObject,
    pub _priv: *mut GNetworkAddressPrivate,
}
impl ::std::clone::Clone for Struct__GNetworkAddress {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GNetworkAddress {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GNetworkAddressClass {
    pub parent_class: GObjectClass,
}
impl ::std::clone::Clone for Struct__GNetworkAddressClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GNetworkAddressClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GNetworkMonitorInterface = Struct__GNetworkMonitorInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GNetworkMonitorInterface {
    pub g_iface: GTypeInterface,
    pub network_changed: ::std::option::Option<unsafe extern "C" fn(monitor:
                                                                        *mut GNetworkMonitor,
                                                                    available:
                                                                        gboolean)>,
    pub can_reach: ::std::option::Option<unsafe extern "C" fn(monitor:
                                                                  *mut GNetworkMonitor,
                                                              connectable:
                                                                  *mut GSocketConnectable,
                                                              cancellable:
                                                                  *mut GCancellable,
                                                              error:
                                                                  *mut *mut GError)
                                             -> gboolean>,
    pub can_reach_async: ::std::option::Option<unsafe extern "C" fn(monitor:
                                                                        *mut GNetworkMonitor,
                                                                    connectable:
                                                                        *mut GSocketConnectable,
                                                                    cancellable:
                                                                        *mut GCancellable,
                                                                    callback:
                                                                        GAsyncReadyCallback,
                                                                    user_data:
                                                                        gpointer)>,
    pub can_reach_finish: ::std::option::Option<unsafe extern "C" fn(monitor:
                                                                         *mut GNetworkMonitor,
                                                                     result:
                                                                         *mut GAsyncResult,
                                                                     error:
                                                                         *mut *mut GError)
                                                    -> gboolean>,
}
impl ::std::clone::Clone for Struct__GNetworkMonitorInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GNetworkMonitorInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GNetworkServiceClass = Struct__GNetworkServiceClass;
pub enum Struct__GNetworkServicePrivate { }
pub type GNetworkServicePrivate = Struct__GNetworkServicePrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GNetworkService {
    pub parent_instance: GObject,
    pub _priv: *mut GNetworkServicePrivate,
}
impl ::std::clone::Clone for Struct__GNetworkService {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GNetworkService {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GNetworkServiceClass {
    pub parent_class: GObjectClass,
}
impl ::std::clone::Clone for Struct__GNetworkServiceClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GNetworkServiceClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GPermissionPrivate { }
pub type GPermissionPrivate = Struct__GPermissionPrivate;
pub type GPermissionClass = Struct__GPermissionClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPermission {
    pub parent_instance: GObject,
    pub _priv: *mut GPermissionPrivate,
}
impl ::std::clone::Clone for Struct__GPermission {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GPermission {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPermissionClass {
    pub parent_class: GObjectClass,
    pub acquire: ::std::option::Option<unsafe extern "C" fn(permission:
                                                                *mut GPermission,
                                                            cancellable:
                                                                *mut GCancellable,
                                                            error:
                                                                *mut *mut GError)
                                           -> gboolean>,
    pub acquire_async: ::std::option::Option<unsafe extern "C" fn(permission:
                                                                      *mut GPermission,
                                                                  cancellable:
                                                                      *mut GCancellable,
                                                                  callback:
                                                                      GAsyncReadyCallback,
                                                                  user_data:
                                                                      gpointer)>,
    pub acquire_finish: ::std::option::Option<unsafe extern "C" fn(permission:
                                                                       *mut GPermission,
                                                                   result:
                                                                       *mut GAsyncResult,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> gboolean>,
    pub release: ::std::option::Option<unsafe extern "C" fn(permission:
                                                                *mut GPermission,
                                                            cancellable:
                                                                *mut GCancellable,
                                                            error:
                                                                *mut *mut GError)
                                           -> gboolean>,
    pub release_async: ::std::option::Option<unsafe extern "C" fn(permission:
                                                                      *mut GPermission,
                                                                  cancellable:
                                                                      *mut GCancellable,
                                                                  callback:
                                                                      GAsyncReadyCallback,
                                                                  user_data:
                                                                      gpointer)>,
    pub release_finish: ::std::option::Option<unsafe extern "C" fn(permission:
                                                                       *mut GPermission,
                                                                   result:
                                                                       *mut GAsyncResult,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> gboolean>,
    pub reserved: [gpointer; 16usize],
}
impl ::std::clone::Clone for Struct__GPermissionClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GPermissionClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GPollableInputStreamInterface =
    Struct__GPollableInputStreamInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPollableInputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GPollableInputStream)
                                            -> gboolean>,
    pub is_readable: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GPollableInputStream)
                                               -> gboolean>,
    pub create_source: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                      *mut GPollableInputStream,
                                                                  cancellable:
                                                                      *mut GCancellable)
                                                 -> *mut GSource>,
    pub read_nonblocking: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                         *mut GPollableInputStream,
                                                                     buffer:
                                                                         *mut ::std::os::raw::c_void,
                                                                     count:
                                                                         gsize,
                                                                     error:
                                                                         *mut *mut GError)
                                                    -> gssize>,
}
impl ::std::clone::Clone for Struct__GPollableInputStreamInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GPollableInputStreamInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GPollableOutputStreamInterface =
    Struct__GPollableOutputStreamInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GPollableOutputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                 *mut GPollableOutputStream)
                                            -> gboolean>,
    pub is_writable: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                    *mut GPollableOutputStream)
                                               -> gboolean>,
    pub create_source: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                      *mut GPollableOutputStream,
                                                                  cancellable:
                                                                      *mut GCancellable)
                                                 -> *mut GSource>,
    pub write_nonblocking: ::std::option::Option<unsafe extern "C" fn(stream:
                                                                          *mut GPollableOutputStream,
                                                                      buffer:
                                                                          *const ::std::os::raw::c_void,
                                                                      count:
                                                                          gsize,
                                                                      error:
                                                                          *mut *mut GError)
                                                     -> gssize>,
}
impl ::std::clone::Clone for Struct__GPollableOutputStreamInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GPollableOutputStreamInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GProxyInterface = Struct__GProxyInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GProxyInterface {
    pub g_iface: GTypeInterface,
    pub connect: ::std::option::Option<unsafe extern "C" fn(proxy:
                                                                *mut GProxy,
                                                            connection:
                                                                *mut GIOStream,
                                                            proxy_address:
                                                                *mut GProxyAddress,
                                                            cancellable:
                                                                *mut GCancellable,
                                                            error:
                                                                *mut *mut GError)
                                           -> *mut GIOStream>,
    pub connect_async: ::std::option::Option<unsafe extern "C" fn(proxy:
                                                                      *mut GProxy,
                                                                  connection:
                                                                      *mut GIOStream,
                                                                  proxy_address:
                                                                      *mut GProxyAddress,
                                                                  cancellable:
                                                                      *mut GCancellable,
                                                                  callback:
                                                                      GAsyncReadyCallback,
                                                                  user_data:
                                                                      gpointer)>,
    pub connect_finish: ::std::option::Option<unsafe extern "C" fn(proxy:
                                                                       *mut GProxy,
                                                                   result:
                                                                       *mut GAsyncResult,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> *mut GIOStream>,
    pub supports_hostname: ::std::option::Option<unsafe extern "C" fn(proxy:
                                                                          *mut GProxy)
                                                     -> gboolean>,
}
impl ::std::clone::Clone for Struct__GProxyInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GProxyInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GProxyAddressClass = Struct__GProxyAddressClass;
pub enum Struct__GProxyAddressPrivate { }
pub type GProxyAddressPrivate = Struct__GProxyAddressPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GProxyAddress {
    pub parent_instance: GInetSocketAddress,
    pub _priv: *mut GProxyAddressPrivate,
}
impl ::std::clone::Clone for Struct__GProxyAddress {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GProxyAddress {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GProxyAddressClass {
    pub parent_class: GInetSocketAddressClass,
}
impl ::std::clone::Clone for Struct__GProxyAddressClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GProxyAddressClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSocketAddressEnumeratorClass =
    Struct__GSocketAddressEnumeratorClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketAddressEnumerator {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__GSocketAddressEnumerator {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketAddressEnumerator {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketAddressEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next: ::std::option::Option<unsafe extern "C" fn(enumerator:
                                                             *mut GSocketAddressEnumerator,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
                                        -> *mut GSocketAddress>,
    pub next_async: ::std::option::Option<unsafe extern "C" fn(enumerator:
                                                                   *mut GSocketAddressEnumerator,
                                                               cancellable:
                                                                   *mut GCancellable,
                                                               callback:
                                                                   GAsyncReadyCallback,
                                                               user_data:
                                                                   gpointer)>,
    pub next_finish: ::std::option::Option<unsafe extern "C" fn(enumerator:
                                                                    *mut GSocketAddressEnumerator,
                                                                result:
                                                                    *mut GAsyncResult,
                                                                error:
                                                                    *mut *mut GError)
                                               -> *mut GSocketAddress>,
}
impl ::std::clone::Clone for Struct__GSocketAddressEnumeratorClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketAddressEnumeratorClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GProxyAddressEnumeratorClass = Struct__GProxyAddressEnumeratorClass;
pub enum Struct__GProxyAddressEnumeratorPrivate { }
pub type GProxyAddressEnumeratorPrivate =
    Struct__GProxyAddressEnumeratorPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GProxyAddressEnumerator {
    pub parent_instance: GSocketAddressEnumerator,
    pub _priv: *mut GProxyAddressEnumeratorPrivate,
}
impl ::std::clone::Clone for Struct__GProxyAddressEnumerator {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GProxyAddressEnumerator {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GProxyAddressEnumeratorClass {
    pub parent_class: GSocketAddressEnumeratorClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GProxyAddressEnumeratorClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GProxyAddressEnumeratorClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GProxyResolverInterface = Struct__GProxyResolverInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GProxyResolverInterface {
    pub g_iface: GTypeInterface,
    pub is_supported: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                     *mut GProxyResolver)
                                                -> gboolean>,
    pub lookup: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                               *mut GProxyResolver,
                                                           uri: *const gchar,
                                                           cancellable:
                                                               *mut GCancellable,
                                                           error:
                                                               *mut *mut GError)
                                          -> *mut *mut gchar>,
    pub lookup_async: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                     *mut GProxyResolver,
                                                                 uri:
                                                                     *const gchar,
                                                                 cancellable:
                                                                     *mut GCancellable,
                                                                 callback:
                                                                     GAsyncReadyCallback,
                                                                 user_data:
                                                                     gpointer)>,
    pub lookup_finish: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                      *mut GProxyResolver,
                                                                  result:
                                                                      *mut GAsyncResult,
                                                                  error:
                                                                      *mut *mut GError)
                                                 -> *mut *mut gchar>,
}
impl ::std::clone::Clone for Struct__GProxyResolverInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GProxyResolverInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GResolverPrivate { }
pub type GResolverPrivate = Struct__GResolverPrivate;
pub type GResolverClass = Struct__GResolverClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GResolver {
    pub parent_instance: GObject,
    pub _priv: *mut GResolverPrivate,
}
impl ::std::clone::Clone for Struct__GResolver {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GResolver {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GResolverClass {
    pub parent_class: GObjectClass,
    pub reload: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                               *mut GResolver)>,
    pub lookup_by_name: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                       *mut GResolver,
                                                                   hostname:
                                                                       *const gchar,
                                                                   cancellable:
                                                                       *mut GCancellable,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> *mut GList>,
    pub lookup_by_name_async: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                             *mut GResolver,
                                                                         hostname:
                                                                             *const gchar,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         callback:
                                                                             GAsyncReadyCallback,
                                                                         user_data:
                                                                             gpointer)>,
    pub lookup_by_name_finish: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                              *mut GResolver,
                                                                          result:
                                                                              *mut GAsyncResult,
                                                                          error:
                                                                              *mut *mut GError)
                                                         -> *mut GList>,
    pub lookup_by_address: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                          *mut GResolver,
                                                                      address:
                                                                          *mut GInetAddress,
                                                                      cancellable:
                                                                          *mut GCancellable,
                                                                      error:
                                                                          *mut *mut GError)
                                                     -> *mut gchar>,
    pub lookup_by_address_async: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                                *mut GResolver,
                                                                            address:
                                                                                *mut GInetAddress,
                                                                            cancellable:
                                                                                *mut GCancellable,
                                                                            callback:
                                                                                GAsyncReadyCallback,
                                                                            user_data:
                                                                                gpointer)>,
    pub lookup_by_address_finish: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                                 *mut GResolver,
                                                                             result:
                                                                                 *mut GAsyncResult,
                                                                             error:
                                                                                 *mut *mut GError)
                                                            -> *mut gchar>,
    pub lookup_service: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                       *mut GResolver,
                                                                   rrname:
                                                                       *const gchar,
                                                                   cancellable:
                                                                       *mut GCancellable,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> *mut GList>,
    pub lookup_service_async: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                             *mut GResolver,
                                                                         rrname:
                                                                             *const gchar,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         callback:
                                                                             GAsyncReadyCallback,
                                                                         user_data:
                                                                             gpointer)>,
    pub lookup_service_finish: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                              *mut GResolver,
                                                                          result:
                                                                              *mut GAsyncResult,
                                                                          error:
                                                                              *mut *mut GError)
                                                         -> *mut GList>,
    pub lookup_records: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                       *mut GResolver,
                                                                   rrname:
                                                                       *const gchar,
                                                                   record_type:
                                                                       GResolverRecordType,
                                                                   cancellable:
                                                                       *mut GCancellable,
                                                                   error:
                                                                       *mut *mut GError)
                                                  -> *mut GList>,
    pub lookup_records_async: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                             *mut GResolver,
                                                                         rrname:
                                                                             *const gchar,
                                                                         record_type:
                                                                             GResolverRecordType,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         callback:
                                                                             GAsyncReadyCallback,
                                                                         user_data:
                                                                             gpointer)>,
    pub lookup_records_finish: ::std::option::Option<unsafe extern "C" fn(resolver:
                                                                              *mut GResolver,
                                                                          result:
                                                                              *mut GAsyncResult,
                                                                          error:
                                                                              *mut *mut GError)
                                                         -> *mut GList>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GResolverClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GResolverClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GStaticResource = Struct__GStaticResource;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GStaticResource {
    pub data: *const guint8,
    pub data_len: gsize,
    pub resource: *mut GResource,
    pub next: *mut GStaticResource,
    pub padding: gpointer,
}
impl ::std::clone::Clone for Struct__GStaticResource {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GStaticResource {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSeekableIface = Struct__GSeekableIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSeekableIface {
    pub g_iface: GTypeInterface,
    pub tell: ::std::option::Option<unsafe extern "C" fn(seekable:
                                                             *mut GSeekable)
                                        -> goffset>,
    pub can_seek: ::std::option::Option<unsafe extern "C" fn(seekable:
                                                                 *mut GSeekable)
                                            -> gboolean>,
    pub seek: ::std::option::Option<unsafe extern "C" fn(seekable:
                                                             *mut GSeekable,
                                                         offset: goffset,
                                                         _type: GSeekType,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
                                        -> gboolean>,
    pub can_truncate: ::std::option::Option<unsafe extern "C" fn(seekable:
                                                                     *mut GSeekable)
                                                -> gboolean>,
    pub truncate_fn: ::std::option::Option<unsafe extern "C" fn(seekable:
                                                                    *mut GSeekable,
                                                                offset:
                                                                    goffset,
                                                                cancellable:
                                                                    *mut GCancellable,
                                                                error:
                                                                    *mut *mut GError)
                                               -> gboolean>,
}
impl ::std::clone::Clone for Struct__GSeekableIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSeekableIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GSettingsSchemaSource { }
pub type GSettingsSchemaSource = Struct__GSettingsSchemaSource;
pub enum Struct__GSettingsSchema { }
pub type GSettingsSchema = Struct__GSettingsSchema;
pub enum Struct__GSettingsSchemaKey { }
pub type GSettingsSchemaKey = Struct__GSettingsSchemaKey;
pub enum Struct__GSettingsPrivate { }
pub type GSettingsPrivate = Struct__GSettingsPrivate;
pub type GSettingsClass = Struct__GSettingsClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSettingsClass {
    pub parent_class: GObjectClass,
    pub writable_changed: ::std::option::Option<unsafe extern "C" fn(settings:
                                                                         *mut GSettings,
                                                                     key:
                                                                         *const gchar)>,
    pub changed: ::std::option::Option<unsafe extern "C" fn(settings:
                                                                *mut GSettings,
                                                            key:
                                                                *const gchar)>,
    pub writable_change_event: ::std::option::Option<unsafe extern "C" fn(settings:
                                                                              *mut GSettings,
                                                                          key:
                                                                              GQuark)
                                                         -> gboolean>,
    pub change_event: ::std::option::Option<unsafe extern "C" fn(settings:
                                                                     *mut GSettings,
                                                                 keys:
                                                                     *const GQuark,
                                                                 n_keys: gint)
                                                -> gboolean>,
    pub padding: [gpointer; 20usize],
}
impl ::std::clone::Clone for Struct__GSettingsClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSettingsClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSettings {
    pub parent_instance: GObject,
    pub _priv: *mut GSettingsPrivate,
}
impl ::std::clone::Clone for Struct__GSettings {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSettings {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSettingsBindSetMapping =
    ::std::option::Option<unsafe extern "C" fn(value: *const GValue,
                                               expected_type:
                                                   *const GVariantType,
                                               user_data: gpointer)
                              -> *mut GVariant>;
pub type GSettingsBindGetMapping =
    ::std::option::Option<unsafe extern "C" fn(value: *mut GValue,
                                               variant: *mut GVariant,
                                               user_data: gpointer)
                              -> gboolean>;
pub type GSettingsGetMapping =
    ::std::option::Option<unsafe extern "C" fn(value: *mut GVariant,
                                               result: *mut gpointer,
                                               user_data: gpointer)
                              -> gboolean>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed202 {
    G_SETTINGS_BIND_DEFAULT = 0,
    G_SETTINGS_BIND_GET = 1,
    G_SETTINGS_BIND_SET = 2,
    G_SETTINGS_BIND_NO_SENSITIVITY = 4,
    G_SETTINGS_BIND_GET_NO_CHANGES = 8,
    G_SETTINGS_BIND_INVERT_BOOLEAN = 16,
}
pub type GSettingsBindFlags = Enum_Unnamed202;
pub enum Struct__GSimpleActionGroupPrivate { }
pub type GSimpleActionGroupPrivate = Struct__GSimpleActionGroupPrivate;
pub type GSimpleActionGroupClass = Struct__GSimpleActionGroupClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSimpleActionGroup {
    pub parent_instance: GObject,
    pub _priv: *mut GSimpleActionGroupPrivate,
}
impl ::std::clone::Clone for Struct__GSimpleActionGroup {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSimpleActionGroup {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSimpleActionGroupClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 12usize],
}
impl ::std::clone::Clone for Struct__GSimpleActionGroupClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSimpleActionGroupClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GSimpleAsyncResultClass { }
pub type GSimpleAsyncResultClass = Struct__GSimpleAsyncResultClass;
pub enum Struct__GSocketClientPrivate { }
pub type GSocketClientPrivate = Struct__GSocketClientPrivate;
pub type GSocketClientClass = Struct__GSocketClientClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketClientClass {
    pub parent_class: GObjectClass,
    pub event: ::std::option::Option<unsafe extern "C" fn(client:
                                                              *mut GSocketClient,
                                                          event:
                                                              GSocketClientEvent,
                                                          connectable:
                                                              *mut GSocketConnectable,
                                                          connection:
                                                              *mut GIOStream)>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GSocketClientClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketClientClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketClient {
    pub parent_instance: GObject,
    pub _priv: *mut GSocketClientPrivate,
}
impl ::std::clone::Clone for Struct__GSocketClient {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketClient {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSocketConnectableIface = Struct__GSocketConnectableIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketConnectableIface {
    pub g_iface: GTypeInterface,
    pub enumerate: ::std::option::Option<unsafe extern "C" fn(connectable:
                                                                  *mut GSocketConnectable)
                                             ->
                                                 *mut GSocketAddressEnumerator>,
    pub proxy_enumerate: ::std::option::Option<unsafe extern "C" fn(connectable:
                                                                        *mut GSocketConnectable)
                                                   ->
                                                       *mut GSocketAddressEnumerator>,
}
impl ::std::clone::Clone for Struct__GSocketConnectableIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketConnectableIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GSocketPrivate { }
pub type GSocketPrivate = Struct__GSocketPrivate;
pub type GSocketClass = Struct__GSocketClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GSocketClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocket {
    pub parent_instance: GObject,
    pub _priv: *mut GSocketPrivate,
}
impl ::std::clone::Clone for Struct__GSocket {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocket {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GSocketConnectionPrivate { }
pub type GSocketConnectionPrivate = Struct__GSocketConnectionPrivate;
pub type GSocketConnectionClass = Struct__GSocketConnectionClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketConnectionClass {
    pub parent_class: GIOStreamClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GSocketConnectionClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketConnectionClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketConnection {
    pub parent_instance: GIOStream,
    pub _priv: *mut GSocketConnectionPrivate,
}
impl ::std::clone::Clone for Struct__GSocketConnection {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketConnection {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GSocketControlMessagePrivate { }
pub type GSocketControlMessagePrivate = Struct__GSocketControlMessagePrivate;
pub type GSocketControlMessageClass = Struct__GSocketControlMessageClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketControlMessageClass {
    pub parent_class: GObjectClass,
    pub get_size: ::std::option::Option<unsafe extern "C" fn(message:
                                                                 *mut GSocketControlMessage)
                                            -> gsize>,
    pub get_level: ::std::option::Option<unsafe extern "C" fn(message:
                                                                  *mut GSocketControlMessage)
                                             -> ::std::os::raw::c_int>,
    pub get_type: ::std::option::Option<unsafe extern "C" fn(message:
                                                                 *mut GSocketControlMessage)
                                            -> ::std::os::raw::c_int>,
    pub serialize: ::std::option::Option<unsafe extern "C" fn(message:
                                                                  *mut GSocketControlMessage,
                                                              data:
                                                                  gpointer)>,
    pub deserialize: ::std::option::Option<extern "C" fn(level:
                                                             ::std::os::raw::c_int,
                                                         _type:
                                                             ::std::os::raw::c_int,
                                                         size: gsize,
                                                         data: gpointer)
                                               -> *mut GSocketControlMessage>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GSocketControlMessageClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketControlMessageClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketControlMessage {
    pub parent_instance: GObject,
    pub _priv: *mut GSocketControlMessagePrivate,
}
impl ::std::clone::Clone for Struct__GSocketControlMessage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketControlMessage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GSocketListenerPrivate { }
pub type GSocketListenerPrivate = Struct__GSocketListenerPrivate;
pub type GSocketListenerClass = Struct__GSocketListenerClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketListenerClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<unsafe extern "C" fn(listener:
                                                                *mut GSocketListener)>,
    pub event: ::std::option::Option<unsafe extern "C" fn(listener:
                                                              *mut GSocketListener,
                                                          event:
                                                              *mut GSocketListenerEvent,
                                                          socket:
                                                              *mut GSocket)>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GSocketListenerClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketListenerClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketListener {
    pub parent_instance: GObject,
    pub _priv: *mut GSocketListenerPrivate,
}
impl ::std::clone::Clone for Struct__GSocketListener {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketListener {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GSocketServicePrivate { }
pub type GSocketServicePrivate = Struct__GSocketServicePrivate;
pub type GSocketServiceClass = Struct__GSocketServiceClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketServiceClass {
    pub parent_class: GSocketListenerClass,
    pub incoming: ::std::option::Option<unsafe extern "C" fn(service:
                                                                 *mut GSocketService,
                                                             connection:
                                                                 *mut GSocketConnection,
                                                             source_object:
                                                                 *mut GObject)
                                            -> gboolean>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GSocketServiceClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketServiceClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSocketService {
    pub parent_instance: GSocketListener,
    pub _priv: *mut GSocketServicePrivate,
}
impl ::std::clone::Clone for Struct__GSocketService {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSocketService {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSimpleProxyResolver = Struct__GSimpleProxyResolver;
pub enum Struct__GSimpleProxyResolverPrivate { }
pub type GSimpleProxyResolverPrivate = Struct__GSimpleProxyResolverPrivate;
pub type GSimpleProxyResolverClass = Struct__GSimpleProxyResolverClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSimpleProxyResolver {
    pub parent_instance: GObject,
    pub _priv: *mut GSimpleProxyResolverPrivate,
}
impl ::std::clone::Clone for Struct__GSimpleProxyResolver {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSimpleProxyResolver {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GSimpleProxyResolverClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GSimpleProxyResolverClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GSimpleProxyResolverClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GTaskClass { }
pub type GTaskClass = Struct__GTaskClass;
pub type GTaskThreadFunc =
    ::std::option::Option<unsafe extern "C" fn(task: *mut GTask,
                                               source_object: gpointer,
                                               task_data: gpointer,
                                               cancellable:
                                                   *mut GCancellable)>;
pub enum Struct__GTcpConnectionPrivate { }
pub type GTcpConnectionPrivate = Struct__GTcpConnectionPrivate;
pub type GTcpConnectionClass = Struct__GTcpConnectionClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTcpConnectionClass {
    pub parent_class: GSocketConnectionClass,
}
impl ::std::clone::Clone for Struct__GTcpConnectionClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTcpConnectionClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTcpConnection {
    pub parent_instance: GSocketConnection,
    pub _priv: *mut GTcpConnectionPrivate,
}
impl ::std::clone::Clone for Struct__GTcpConnection {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTcpConnection {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GTcpWrapperConnectionPrivate { }
pub type GTcpWrapperConnectionPrivate = Struct__GTcpWrapperConnectionPrivate;
pub type GTcpWrapperConnectionClass = Struct__GTcpWrapperConnectionClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTcpWrapperConnectionClass {
    pub parent_class: GTcpConnectionClass,
}
impl ::std::clone::Clone for Struct__GTcpWrapperConnectionClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTcpWrapperConnectionClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTcpWrapperConnection {
    pub parent_instance: GTcpConnection,
    pub _priv: *mut GTcpWrapperConnectionPrivate,
}
impl ::std::clone::Clone for Struct__GTcpWrapperConnection {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTcpWrapperConnection {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GThemedIconClass { }
pub type GThemedIconClass = Struct__GThemedIconClass;
pub enum Struct__GThreadedSocketServicePrivate { }
pub type GThreadedSocketServicePrivate =
    Struct__GThreadedSocketServicePrivate;
pub type GThreadedSocketServiceClass = Struct__GThreadedSocketServiceClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GThreadedSocketServiceClass {
    pub parent_class: GSocketServiceClass,
    pub run: ::std::option::Option<unsafe extern "C" fn(service:
                                                            *mut GThreadedSocketService,
                                                        connection:
                                                            *mut GSocketConnection,
                                                        source_object:
                                                            *mut GObject)
                                       -> gboolean>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GThreadedSocketServiceClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GThreadedSocketServiceClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GThreadedSocketService {
    pub parent_instance: GSocketService,
    pub _priv: *mut GThreadedSocketServicePrivate,
}
impl ::std::clone::Clone for Struct__GThreadedSocketService {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GThreadedSocketService {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GTlsBackend { }
pub type GTlsBackend = Struct__GTlsBackend;
pub type GTlsBackendInterface = Struct__GTlsBackendInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsBackendInterface {
    pub g_iface: GTypeInterface,
    pub supports_tls: ::std::option::Option<unsafe extern "C" fn(backend:
                                                                     *mut GTlsBackend)
                                                -> gboolean>,
    pub get_certificate_type: ::std::option::Option<extern "C" fn() -> GType>,
    pub get_client_connection_type: ::std::option::Option<extern "C" fn()
                                                              -> GType>,
    pub get_server_connection_type: ::std::option::Option<extern "C" fn()
                                                              -> GType>,
    pub get_file_database_type: ::std::option::Option<extern "C" fn()
                                                          -> GType>,
    pub get_default_database: ::std::option::Option<unsafe extern "C" fn(backend:
                                                                             *mut GTlsBackend)
                                                        -> *mut GTlsDatabase>,
}
impl ::std::clone::Clone for Struct__GTlsBackendInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsBackendInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTlsCertificateClass = Struct__GTlsCertificateClass;
pub enum Struct__GTlsCertificatePrivate { }
pub type GTlsCertificatePrivate = Struct__GTlsCertificatePrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsCertificate {
    pub parent_instance: GObject,
    pub _priv: *mut GTlsCertificatePrivate,
}
impl ::std::clone::Clone for Struct__GTlsCertificate {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsCertificate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsCertificateClass {
    pub parent_class: GObjectClass,
    pub verify: ::std::option::Option<unsafe extern "C" fn(cert:
                                                               *mut GTlsCertificate,
                                                           identity:
                                                               *mut GSocketConnectable,
                                                           trusted_ca:
                                                               *mut GTlsCertificate)
                                          -> GTlsCertificateFlags>,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GTlsCertificateClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsCertificateClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTlsConnectionClass = Struct__GTlsConnectionClass;
pub enum Struct__GTlsConnectionPrivate { }
pub type GTlsConnectionPrivate = Struct__GTlsConnectionPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsConnection {
    pub parent_instance: GIOStream,
    pub _priv: *mut GTlsConnectionPrivate,
}
impl ::std::clone::Clone for Struct__GTlsConnection {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsConnection {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsConnectionClass {
    pub parent_class: GIOStreamClass,
    pub accept_certificate: ::std::option::Option<unsafe extern "C" fn(connection:
                                                                           *mut GTlsConnection,
                                                                       peer_cert:
                                                                           *mut GTlsCertificate,
                                                                       errors:
                                                                           GTlsCertificateFlags)
                                                      -> gboolean>,
    pub handshake: ::std::option::Option<unsafe extern "C" fn(conn:
                                                                  *mut GTlsConnection,
                                                              cancellable:
                                                                  *mut GCancellable,
                                                              error:
                                                                  *mut *mut GError)
                                             -> gboolean>,
    pub handshake_async: ::std::option::Option<unsafe extern "C" fn(conn:
                                                                        *mut GTlsConnection,
                                                                    io_priority:
                                                                        ::std::os::raw::c_int,
                                                                    cancellable:
                                                                        *mut GCancellable,
                                                                    callback:
                                                                        GAsyncReadyCallback,
                                                                    user_data:
                                                                        gpointer)>,
    pub handshake_finish: ::std::option::Option<unsafe extern "C" fn(conn:
                                                                         *mut GTlsConnection,
                                                                     result:
                                                                         *mut GAsyncResult,
                                                                     error:
                                                                         *mut *mut GError)
                                                    -> gboolean>,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GTlsConnectionClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsConnectionClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTlsClientConnectionInterface =
    Struct__GTlsClientConnectionInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsClientConnectionInterface {
    pub g_iface: GTypeInterface,
    pub copy_session_state: ::std::option::Option<unsafe extern "C" fn(conn:
                                                                           *mut GTlsClientConnection,
                                                                       source:
                                                                           *mut GTlsClientConnection)>,
}
impl ::std::clone::Clone for Struct__GTlsClientConnectionInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsClientConnectionInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTlsDatabaseClass = Struct__GTlsDatabaseClass;
pub enum Struct__GTlsDatabasePrivate { }
pub type GTlsDatabasePrivate = Struct__GTlsDatabasePrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsDatabase {
    pub parent_instance: GObject,
    pub _priv: *mut GTlsDatabasePrivate,
}
impl ::std::clone::Clone for Struct__GTlsDatabase {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsDatabase {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsDatabaseClass {
    pub parent_class: GObjectClass,
    pub verify_chain: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                     *mut GTlsDatabase,
                                                                 chain:
                                                                     *mut GTlsCertificate,
                                                                 purpose:
                                                                     *const gchar,
                                                                 identity:
                                                                     *mut GSocketConnectable,
                                                                 interaction:
                                                                     *mut GTlsInteraction,
                                                                 flags:
                                                                     GTlsDatabaseVerifyFlags,
                                                                 cancellable:
                                                                     *mut GCancellable,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> GTlsCertificateFlags>,
    pub verify_chain_async: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                           *mut GTlsDatabase,
                                                                       chain:
                                                                           *mut GTlsCertificate,
                                                                       purpose:
                                                                           *const gchar,
                                                                       identity:
                                                                           *mut GSocketConnectable,
                                                                       interaction:
                                                                           *mut GTlsInteraction,
                                                                       flags:
                                                                           GTlsDatabaseVerifyFlags,
                                                                       cancellable:
                                                                           *mut GCancellable,
                                                                       callback:
                                                                           GAsyncReadyCallback,
                                                                       user_data:
                                                                           gpointer)>,
    pub verify_chain_finish: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                            *mut GTlsDatabase,
                                                                        result:
                                                                            *mut GAsyncResult,
                                                                        error:
                                                                            *mut *mut GError)
                                                       ->
                                                           GTlsCertificateFlags>,
    pub create_certificate_handle: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                  *mut GTlsDatabase,
                                                                              certificate:
                                                                                  *mut GTlsCertificate)
                                                             -> *mut gchar>,
    pub lookup_certificate_for_handle: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                      *mut GTlsDatabase,
                                                                                  handle:
                                                                                      *const gchar,
                                                                                  interaction:
                                                                                      *mut GTlsInteraction,
                                                                                  flags:
                                                                                      GTlsDatabaseLookupFlags,
                                                                                  cancellable:
                                                                                      *mut GCancellable,
                                                                                  error:
                                                                                      *mut *mut GError)
                                                                 ->
                                                                     *mut GTlsCertificate>,
    pub lookup_certificate_for_handle_async: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                            *mut GTlsDatabase,
                                                                                        handle:
                                                                                            *const gchar,
                                                                                        interaction:
                                                                                            *mut GTlsInteraction,
                                                                                        flags:
                                                                                            GTlsDatabaseLookupFlags,
                                                                                        cancellable:
                                                                                            *mut GCancellable,
                                                                                        callback:
                                                                                            GAsyncReadyCallback,
                                                                                        user_data:
                                                                                            gpointer)>,
    pub lookup_certificate_for_handle_finish: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                             *mut GTlsDatabase,
                                                                                         result:
                                                                                             *mut GAsyncResult,
                                                                                         error:
                                                                                             *mut *mut GError)
                                                                        ->
                                                                            *mut GTlsCertificate>,
    pub lookup_certificate_issuer: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                  *mut GTlsDatabase,
                                                                              certificate:
                                                                                  *mut GTlsCertificate,
                                                                              interaction:
                                                                                  *mut GTlsInteraction,
                                                                              flags:
                                                                                  GTlsDatabaseLookupFlags,
                                                                              cancellable:
                                                                                  *mut GCancellable,
                                                                              error:
                                                                                  *mut *mut GError)
                                                             ->
                                                                 *mut GTlsCertificate>,
    pub lookup_certificate_issuer_async: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                        *mut GTlsDatabase,
                                                                                    certificate:
                                                                                        *mut GTlsCertificate,
                                                                                    interaction:
                                                                                        *mut GTlsInteraction,
                                                                                    flags:
                                                                                        GTlsDatabaseLookupFlags,
                                                                                    cancellable:
                                                                                        *mut GCancellable,
                                                                                    callback:
                                                                                        GAsyncReadyCallback,
                                                                                    user_data:
                                                                                        gpointer)>,
    pub lookup_certificate_issuer_finish: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                         *mut GTlsDatabase,
                                                                                     result:
                                                                                         *mut GAsyncResult,
                                                                                     error:
                                                                                         *mut *mut GError)
                                                                    ->
                                                                        *mut GTlsCertificate>,
    pub lookup_certificates_issued_by: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                      *mut GTlsDatabase,
                                                                                  issuer_raw_dn:
                                                                                      *mut GByteArray,
                                                                                  interaction:
                                                                                      *mut GTlsInteraction,
                                                                                  flags:
                                                                                      GTlsDatabaseLookupFlags,
                                                                                  cancellable:
                                                                                      *mut GCancellable,
                                                                                  error:
                                                                                      *mut *mut GError)
                                                                 ->
                                                                     *mut GList>,
    pub lookup_certificates_issued_by_async: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                            *mut GTlsDatabase,
                                                                                        issuer_raw_dn:
                                                                                            *mut GByteArray,
                                                                                        interaction:
                                                                                            *mut GTlsInteraction,
                                                                                        flags:
                                                                                            GTlsDatabaseLookupFlags,
                                                                                        cancellable:
                                                                                            *mut GCancellable,
                                                                                        callback:
                                                                                            GAsyncReadyCallback,
                                                                                        user_data:
                                                                                            gpointer)>,
    pub lookup_certificates_issued_by_finish: ::std::option::Option<unsafe extern "C" fn(_self:
                                                                                             *mut GTlsDatabase,
                                                                                         result:
                                                                                             *mut GAsyncResult,
                                                                                         error:
                                                                                             *mut *mut GError)
                                                                        ->
                                                                            *mut GList>,
    pub padding: [gpointer; 16usize],
}
impl ::std::clone::Clone for Struct__GTlsDatabaseClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsDatabaseClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTlsFileDatabaseInterface = Struct__GTlsFileDatabaseInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsFileDatabaseInterface {
    pub g_iface: GTypeInterface,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GTlsFileDatabaseInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsFileDatabaseInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTlsInteractionClass = Struct__GTlsInteractionClass;
pub enum Struct__GTlsInteractionPrivate { }
pub type GTlsInteractionPrivate = Struct__GTlsInteractionPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsInteraction {
    pub parent_instance: GObject,
    pub _priv: *mut GTlsInteractionPrivate,
}
impl ::std::clone::Clone for Struct__GTlsInteraction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsInteraction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsInteractionClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<unsafe extern "C" fn(interaction:
                                                                     *mut GTlsInteraction,
                                                                 password:
                                                                     *mut GTlsPassword,
                                                                 cancellable:
                                                                     *mut GCancellable,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> GTlsInteractionResult>,
    pub ask_password_async: ::std::option::Option<unsafe extern "C" fn(interaction:
                                                                           *mut GTlsInteraction,
                                                                       password:
                                                                           *mut GTlsPassword,
                                                                       cancellable:
                                                                           *mut GCancellable,
                                                                       callback:
                                                                           GAsyncReadyCallback,
                                                                       user_data:
                                                                           gpointer)>,
    pub ask_password_finish: ::std::option::Option<unsafe extern "C" fn(interaction:
                                                                            *mut GTlsInteraction,
                                                                        result:
                                                                            *mut GAsyncResult,
                                                                        error:
                                                                            *mut *mut GError)
                                                       ->
                                                           GTlsInteractionResult>,
    pub request_certificate: ::std::option::Option<unsafe extern "C" fn(interaction:
                                                                            *mut GTlsInteraction,
                                                                        connection:
                                                                            *mut GTlsConnection,
                                                                        flags:
                                                                            GTlsCertificateRequestFlags,
                                                                        cancellable:
                                                                            *mut GCancellable,
                                                                        error:
                                                                            *mut *mut GError)
                                                       ->
                                                           GTlsInteractionResult>,
    pub request_certificate_async: ::std::option::Option<unsafe extern "C" fn(interaction:
                                                                                  *mut GTlsInteraction,
                                                                              connection:
                                                                                  *mut GTlsConnection,
                                                                              flags:
                                                                                  GTlsCertificateRequestFlags,
                                                                              cancellable:
                                                                                  *mut GCancellable,
                                                                              callback:
                                                                                  GAsyncReadyCallback,
                                                                              user_data:
                                                                                  gpointer)>,
    pub request_certificate_finish: ::std::option::Option<unsafe extern "C" fn(interaction:
                                                                                   *mut GTlsInteraction,
                                                                               result:
                                                                                   *mut GAsyncResult,
                                                                               error:
                                                                                   *mut *mut GError)
                                                              ->
                                                                  GTlsInteractionResult>,
    pub padding: [gpointer; 21usize],
}
impl ::std::clone::Clone for Struct__GTlsInteractionClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsInteractionClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTlsServerConnectionInterface =
    Struct__GTlsServerConnectionInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsServerConnectionInterface {
    pub g_iface: GTypeInterface,
}
impl ::std::clone::Clone for Struct__GTlsServerConnectionInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsServerConnectionInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GTlsPasswordClass = Struct__GTlsPasswordClass;
pub enum Struct__GTlsPasswordPrivate { }
pub type GTlsPasswordPrivate = Struct__GTlsPasswordPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsPassword {
    pub parent_instance: GObject,
    pub _priv: *mut GTlsPasswordPrivate,
}
impl ::std::clone::Clone for Struct__GTlsPassword {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsPassword {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GTlsPasswordClass {
    pub parent_class: GObjectClass,
    pub get_value: ::std::option::Option<unsafe extern "C" fn(password:
                                                                  *mut GTlsPassword,
                                                              length:
                                                                  *mut gsize)
                                             -> *const guchar>,
    pub set_value: ::std::option::Option<unsafe extern "C" fn(password:
                                                                  *mut GTlsPassword,
                                                              value:
                                                                  *mut guchar,
                                                              length: gssize,
                                                              destroy:
                                                                  GDestroyNotify)>,
    pub get_default_warning: ::std::option::Option<unsafe extern "C" fn(password:
                                                                            *mut GTlsPassword)
                                                       -> *const gchar>,
    pub padding: [gpointer; 4usize],
}
impl ::std::clone::Clone for Struct__GTlsPasswordClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GTlsPasswordClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GVfsClass = Struct__GVfsClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVfs {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__GVfs {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GVfs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVfsClass {
    pub parent_class: GObjectClass,
    pub is_active: ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs)
                                             -> gboolean>,
    pub get_file_for_path: ::std::option::Option<unsafe extern "C" fn(vfs:
                                                                          *mut GVfs,
                                                                      path:
                                                                          *const ::std::os::raw::c_char)
                                                     -> *mut GFile>,
    pub get_file_for_uri: ::std::option::Option<unsafe extern "C" fn(vfs:
                                                                         *mut GVfs,
                                                                     uri:
                                                                         *const ::std::os::raw::c_char)
                                                    -> *mut GFile>,
    pub get_supported_uri_schemes: ::std::option::Option<unsafe extern "C" fn(vfs:
                                                                                  *mut GVfs)
                                                             ->
                                                                 *const *const gchar>,
    pub parse_name: ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs,
                                                               parse_name:
                                                                   *const ::std::os::raw::c_char)
                                              -> *mut GFile>,
    pub local_file_add_info: ::std::option::Option<unsafe extern "C" fn(vfs:
                                                                            *mut GVfs,
                                                                        filename:
                                                                            *const ::std::os::raw::c_char,
                                                                        device:
                                                                            guint64,
                                                                        attribute_matcher:
                                                                            *mut GFileAttributeMatcher,
                                                                        info:
                                                                            *mut GFileInfo,
                                                                        cancellable:
                                                                            *mut GCancellable,
                                                                        extra_data:
                                                                            *mut gpointer,
                                                                        free_extra_data:
                                                                            *mut GDestroyNotify)>,
    pub add_writable_namespaces: ::std::option::Option<unsafe extern "C" fn(vfs:
                                                                                *mut GVfs,
                                                                            list:
                                                                                *mut GFileAttributeInfoList)>,
    pub local_file_set_attributes: ::std::option::Option<unsafe extern "C" fn(vfs:
                                                                                  *mut GVfs,
                                                                              filename:
                                                                                  *const ::std::os::raw::c_char,
                                                                              info:
                                                                                  *mut GFileInfo,
                                                                              flags:
                                                                                  GFileQueryInfoFlags,
                                                                              cancellable:
                                                                                  *mut GCancellable,
                                                                              error:
                                                                                  *mut *mut GError)
                                                             -> gboolean>,
    pub local_file_removed: ::std::option::Option<unsafe extern "C" fn(vfs:
                                                                           *mut GVfs,
                                                                       filename:
                                                                           *const ::std::os::raw::c_char)>,
    pub local_file_moved: ::std::option::Option<unsafe extern "C" fn(vfs:
                                                                         *mut GVfs,
                                                                     source:
                                                                         *const ::std::os::raw::c_char,
                                                                     dest:
                                                                         *const ::std::os::raw::c_char)>,
    pub deserialize_icon: ::std::option::Option<unsafe extern "C" fn(vfs:
                                                                         *mut GVfs,
                                                                     value:
                                                                         *mut GVariant)
                                                    -> *mut GIcon>,
    pub _g_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__GVfsClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GVfsClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GVolumeIface = Struct__GVolumeIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GVolumeIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                *mut GVolume)>,
    pub removed: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                *mut GVolume)>,
    pub get_name: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                 *mut GVolume)
                                            -> *mut ::std::os::raw::c_char>,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                 *mut GVolume)
                                            -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                 *mut GVolume)
                                            -> *mut ::std::os::raw::c_char>,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                  *mut GVolume)
                                             -> *mut GDrive>,
    pub get_mount: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                  *mut GVolume)
                                             -> *mut GMount>,
    pub can_mount: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                  *mut GVolume)
                                             -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                  *mut GVolume)
                                             -> gboolean>,
    pub mount_fn: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                 *mut GVolume,
                                                             flags:
                                                                 GMountMountFlags,
                                                             mount_operation:
                                                                 *mut GMountOperation,
                                                             cancellable:
                                                                 *mut GCancellable,
                                                             callback:
                                                                 GAsyncReadyCallback,
                                                             user_data:
                                                                 gpointer)>,
    pub mount_finish: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                     *mut GVolume,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub eject: ::std::option::Option<unsafe extern "C" fn(volume:
                                                              *mut GVolume,
                                                          flags:
                                                              GMountUnmountFlags,
                                                          cancellable:
                                                              *mut GCancellable,
                                                          callback:
                                                              GAsyncReadyCallback,
                                                          user_data:
                                                              gpointer)>,
    pub eject_finish: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                     *mut GVolume,
                                                                 result:
                                                                     *mut GAsyncResult,
                                                                 error:
                                                                     *mut *mut GError)
                                                -> gboolean>,
    pub get_identifier: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                       *mut GVolume,
                                                                   kind:
                                                                       *const ::std::os::raw::c_char)
                                                  ->
                                                      *mut ::std::os::raw::c_char>,
    pub enumerate_identifiers: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                              *mut GVolume)
                                                         ->
                                                             *mut *mut ::std::os::raw::c_char>,
    pub should_automount: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                         *mut GVolume)
                                                    -> gboolean>,
    pub get_activation_root: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                            *mut GVolume)
                                                       -> *mut GFile>,
    pub eject_with_operation: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                             *mut GVolume,
                                                                         flags:
                                                                             GMountUnmountFlags,
                                                                         mount_operation:
                                                                             *mut GMountOperation,
                                                                         cancellable:
                                                                             *mut GCancellable,
                                                                         callback:
                                                                             GAsyncReadyCallback,
                                                                         user_data:
                                                                             gpointer)>,
    pub eject_with_operation_finish: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                                    *mut GVolume,
                                                                                result:
                                                                                    *mut GAsyncResult,
                                                                                error:
                                                                                    *mut *mut GError)
                                                               -> gboolean>,
    pub get_sort_key: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                     *mut GVolume)
                                                -> *const gchar>,
    pub get_symbolic_icon: ::std::option::Option<unsafe extern "C" fn(volume:
                                                                          *mut GVolume)
                                                     -> *mut GIcon>,
}
impl ::std::clone::Clone for Struct__GVolumeIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GVolumeIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GZlibCompressorClass = Struct__GZlibCompressorClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GZlibCompressorClass {
    pub parent_class: GObjectClass,
}
impl ::std::clone::Clone for Struct__GZlibCompressorClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GZlibCompressorClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GZlibDecompressorClass = Struct__GZlibDecompressorClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GZlibDecompressorClass {
    pub parent_class: GObjectClass,
}
impl ::std::clone::Clone for Struct__GZlibDecompressorClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GZlibDecompressorClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusInterfaceIface = Struct__GDBusInterfaceIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusInterfaceIface {
    pub parent_iface: GTypeInterface,
    pub get_info: ::std::option::Option<unsafe extern "C" fn(interface_:
                                                                 *mut GDBusInterface)
                                            -> *mut GDBusInterfaceInfo>,
    pub get_object: ::std::option::Option<unsafe extern "C" fn(interface_:
                                                                   *mut GDBusInterface)
                                              -> *mut GDBusObject>,
    pub set_object: ::std::option::Option<unsafe extern "C" fn(interface_:
                                                                   *mut GDBusInterface,
                                                               object:
                                                                   *mut GDBusObject)>,
    pub dup_object: ::std::option::Option<unsafe extern "C" fn(interface_:
                                                                   *mut GDBusInterface)
                                              -> *mut GDBusObject>,
}
impl ::std::clone::Clone for Struct__GDBusInterfaceIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusInterfaceIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusInterfaceSkeletonClass = Struct__GDBusInterfaceSkeletonClass;
pub enum Struct__GDBusInterfaceSkeletonPrivate { }
pub type GDBusInterfaceSkeletonPrivate =
    Struct__GDBusInterfaceSkeletonPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusInterfaceSkeleton {
    pub parent_instance: GObject,
    pub _priv: *mut GDBusInterfaceSkeletonPrivate,
}
impl ::std::clone::Clone for Struct__GDBusInterfaceSkeleton {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusInterfaceSkeleton {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusInterfaceSkeletonClass {
    pub parent_class: GObjectClass,
    pub get_info: ::std::option::Option<unsafe extern "C" fn(interface_:
                                                                 *mut GDBusInterfaceSkeleton)
                                            -> *mut GDBusInterfaceInfo>,
    pub get_vtable: ::std::option::Option<unsafe extern "C" fn(interface_:
                                                                   *mut GDBusInterfaceSkeleton)
                                              -> *mut GDBusInterfaceVTable>,
    pub get_properties: ::std::option::Option<unsafe extern "C" fn(interface_:
                                                                       *mut GDBusInterfaceSkeleton)
                                                  -> *mut GVariant>,
    pub flush: ::std::option::Option<unsafe extern "C" fn(interface_:
                                                              *mut GDBusInterfaceSkeleton)>,
    pub vfunc_padding: [gpointer; 8usize],
    pub g_authorize_method: ::std::option::Option<unsafe extern "C" fn(interface_:
                                                                           *mut GDBusInterfaceSkeleton,
                                                                       invocation:
                                                                           *mut GDBusMethodInvocation)
                                                      -> gboolean>,
    pub signal_padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GDBusInterfaceSkeletonClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusInterfaceSkeletonClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusObjectIface = Struct__GDBusObjectIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path: ::std::option::Option<unsafe extern "C" fn(object:
                                                                        *mut GDBusObject)
                                                   -> *const gchar>,
    pub get_interfaces: ::std::option::Option<unsafe extern "C" fn(object:
                                                                       *mut GDBusObject)
                                                  -> *mut GList>,
    pub get_interface: ::std::option::Option<unsafe extern "C" fn(object:
                                                                      *mut GDBusObject,
                                                                  interface_name:
                                                                      *const gchar)
                                                 -> *mut GDBusInterface>,
    pub interface_added: ::std::option::Option<unsafe extern "C" fn(object:
                                                                        *mut GDBusObject,
                                                                    interface_:
                                                                        *mut GDBusInterface)>,
    pub interface_removed: ::std::option::Option<unsafe extern "C" fn(object:
                                                                          *mut GDBusObject,
                                                                      interface_:
                                                                          *mut GDBusInterface)>,
}
impl ::std::clone::Clone for Struct__GDBusObjectIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusObjectSkeletonClass = Struct__GDBusObjectSkeletonClass;
pub enum Struct__GDBusObjectSkeletonPrivate { }
pub type GDBusObjectSkeletonPrivate = Struct__GDBusObjectSkeletonPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectSkeleton {
    pub parent_instance: GObject,
    pub _priv: *mut GDBusObjectSkeletonPrivate,
}
impl ::std::clone::Clone for Struct__GDBusObjectSkeleton {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectSkeleton {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectSkeletonClass {
    pub parent_class: GObjectClass,
    pub authorize_method: ::std::option::Option<unsafe extern "C" fn(object:
                                                                         *mut GDBusObjectSkeleton,
                                                                     interface_:
                                                                         *mut GDBusInterfaceSkeleton,
                                                                     invocation:
                                                                         *mut GDBusMethodInvocation)
                                                    -> gboolean>,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GDBusObjectSkeletonClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectSkeletonClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusObjectProxyClass = Struct__GDBusObjectProxyClass;
pub enum Struct__GDBusObjectProxyPrivate { }
pub type GDBusObjectProxyPrivate = Struct__GDBusObjectProxyPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectProxy {
    pub parent_instance: GObject,
    pub _priv: *mut GDBusObjectProxyPrivate,
}
impl ::std::clone::Clone for Struct__GDBusObjectProxy {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectProxy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectProxyClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GDBusObjectProxyClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectProxyClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusObjectManagerIface = Struct__GDBusObjectManagerIface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectManagerIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                        *mut GDBusObjectManager)
                                                   -> *const gchar>,
    pub get_objects: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                    *mut GDBusObjectManager)
                                               -> *mut GList>,
    pub get_object: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                   *mut GDBusObjectManager,
                                                               object_path:
                                                                   *const gchar)
                                              -> *mut GDBusObject>,
    pub get_interface: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                      *mut GDBusObjectManager,
                                                                  object_path:
                                                                      *const gchar,
                                                                  interface_name:
                                                                      *const gchar)
                                                 -> *mut GDBusInterface>,
    pub object_added: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                     *mut GDBusObjectManager,
                                                                 object:
                                                                     *mut GDBusObject)>,
    pub object_removed: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                       *mut GDBusObjectManager,
                                                                   object:
                                                                       *mut GDBusObject)>,
    pub interface_added: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                        *mut GDBusObjectManager,
                                                                    object:
                                                                        *mut GDBusObject,
                                                                    interface_:
                                                                        *mut GDBusInterface)>,
    pub interface_removed: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                          *mut GDBusObjectManager,
                                                                      object:
                                                                          *mut GDBusObject,
                                                                      interface_:
                                                                          *mut GDBusInterface)>,
}
impl ::std::clone::Clone for Struct__GDBusObjectManagerIface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectManagerIface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusObjectManagerClientClass =
    Struct__GDBusObjectManagerClientClass;
pub enum Struct__GDBusObjectManagerClientPrivate { }
pub type GDBusObjectManagerClientPrivate =
    Struct__GDBusObjectManagerClientPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectManagerClient {
    pub parent_instance: GObject,
    pub _priv: *mut GDBusObjectManagerClientPrivate,
}
impl ::std::clone::Clone for Struct__GDBusObjectManagerClient {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectManagerClient {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectManagerClientClass {
    pub parent_class: GObjectClass,
    pub interface_proxy_signal: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                               *mut GDBusObjectManagerClient,
                                                                           object_proxy:
                                                                               *mut GDBusObjectProxy,
                                                                           interface_proxy:
                                                                               *mut GDBusProxy,
                                                                           sender_name:
                                                                               *const gchar,
                                                                           signal_name:
                                                                               *const gchar,
                                                                           parameters:
                                                                               *mut GVariant)>,
    pub interface_proxy_properties_changed: ::std::option::Option<unsafe extern "C" fn(manager:
                                                                                           *mut GDBusObjectManagerClient,
                                                                                       object_proxy:
                                                                                           *mut GDBusObjectProxy,
                                                                                       interface_proxy:
                                                                                           *mut GDBusProxy,
                                                                                       changed_properties:
                                                                                           *mut GVariant,
                                                                                       invalidated_properties:
                                                                                           *const *const gchar)>,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GDBusObjectManagerClientClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectManagerClientClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GDBusObjectManagerServerClass =
    Struct__GDBusObjectManagerServerClass;
pub enum Struct__GDBusObjectManagerServerPrivate { }
pub type GDBusObjectManagerServerPrivate =
    Struct__GDBusObjectManagerServerPrivate;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectManagerServer {
    pub parent_instance: GObject,
    pub _priv: *mut GDBusObjectManagerServerPrivate,
}
impl ::std::clone::Clone for Struct__GDBusObjectManagerServer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectManagerServer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GDBusObjectManagerServerClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
impl ::std::clone::Clone for Struct__GDBusObjectManagerServerClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GDBusObjectManagerServerClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GRemoteActionGroupInterface = Struct__GRemoteActionGroupInterface;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GRemoteActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub activate_action_full: ::std::option::Option<unsafe extern "C" fn(remote:
                                                                             *mut GRemoteActionGroup,
                                                                         action_name:
                                                                             *const gchar,
                                                                         parameter:
                                                                             *mut GVariant,
                                                                         platform_data:
                                                                             *mut GVariant)>,
    pub change_action_state_full: ::std::option::Option<unsafe extern "C" fn(remote:
                                                                                 *mut GRemoteActionGroup,
                                                                             action_name:
                                                                                 *const gchar,
                                                                             value:
                                                                                 *mut GVariant,
                                                                             platform_data:
                                                                                 *mut GVariant)>,
}
impl ::std::clone::Clone for Struct__GRemoteActionGroupInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GRemoteActionGroupInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GMenuModelPrivate { }
pub type GMenuModelPrivate = Struct__GMenuModelPrivate;
pub type GMenuModelClass = Struct__GMenuModelClass;
pub enum Struct__GMenuAttributeIterPrivate { }
pub type GMenuAttributeIterPrivate = Struct__GMenuAttributeIterPrivate;
pub type GMenuAttributeIterClass = Struct__GMenuAttributeIterClass;
pub type GMenuAttributeIter = Struct__GMenuAttributeIter;
pub enum Struct__GMenuLinkIterPrivate { }
pub type GMenuLinkIterPrivate = Struct__GMenuLinkIterPrivate;
pub type GMenuLinkIterClass = Struct__GMenuLinkIterClass;
pub type GMenuLinkIter = Struct__GMenuLinkIter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMenuModel {
    pub parent_instance: GObject,
    pub _priv: *mut GMenuModelPrivate,
}
impl ::std::clone::Clone for Struct__GMenuModel {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMenuModel {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMenuModelClass {
    pub parent_class: GObjectClass,
    pub is_mutable: ::std::option::Option<unsafe extern "C" fn(model:
                                                                   *mut GMenuModel)
                                              -> gboolean>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(model:
                                                                    *mut GMenuModel)
                                               -> gint>,
    pub get_item_attributes: ::std::option::Option<unsafe extern "C" fn(model:
                                                                            *mut GMenuModel,
                                                                        item_index:
                                                                            gint,
                                                                        attributes:
                                                                            *mut *mut GHashTable)>,
    pub iterate_item_attributes: ::std::option::Option<unsafe extern "C" fn(model:
                                                                                *mut GMenuModel,
                                                                            item_index:
                                                                                gint)
                                                           ->
                                                               *mut GMenuAttributeIter>,
    pub get_item_attribute_value: ::std::option::Option<unsafe extern "C" fn(model:
                                                                                 *mut GMenuModel,
                                                                             item_index:
                                                                                 gint,
                                                                             attribute:
                                                                                 *const gchar,
                                                                             expected_type:
                                                                                 *const GVariantType)
                                                            -> *mut GVariant>,
    pub get_item_links: ::std::option::Option<unsafe extern "C" fn(model:
                                                                       *mut GMenuModel,
                                                                   item_index:
                                                                       gint,
                                                                   links:
                                                                       *mut *mut GHashTable)>,
    pub iterate_item_links: ::std::option::Option<unsafe extern "C" fn(model:
                                                                           *mut GMenuModel,
                                                                       item_index:
                                                                           gint)
                                                      -> *mut GMenuLinkIter>,
    pub get_item_link: ::std::option::Option<unsafe extern "C" fn(model:
                                                                      *mut GMenuModel,
                                                                  item_index:
                                                                      gint,
                                                                  link:
                                                                      *const gchar)
                                                 -> *mut GMenuModel>,
}
impl ::std::clone::Clone for Struct__GMenuModelClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMenuModelClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMenuAttributeIter {
    pub parent_instance: GObject,
    pub _priv: *mut GMenuAttributeIterPrivate,
}
impl ::std::clone::Clone for Struct__GMenuAttributeIter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMenuAttributeIter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMenuAttributeIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<unsafe extern "C" fn(iter:
                                                                 *mut GMenuAttributeIter,
                                                             out_name:
                                                                 *mut *const gchar,
                                                             value:
                                                                 *mut *mut GVariant)
                                            -> gboolean>,
}
impl ::std::clone::Clone for Struct__GMenuAttributeIterClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMenuAttributeIterClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMenuLinkIter {
    pub parent_instance: GObject,
    pub _priv: *mut GMenuLinkIterPrivate,
}
impl ::std::clone::Clone for Struct__GMenuLinkIter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMenuLinkIter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GMenuLinkIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<unsafe extern "C" fn(iter:
                                                                 *mut GMenuLinkIter,
                                                             out_link:
                                                                 *mut *const gchar,
                                                             value:
                                                                 *mut *mut GMenuModel)
                                            -> gboolean>,
}
impl ::std::clone::Clone for Struct__GMenuLinkIterClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GMenuLinkIterClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GMenuItem { }
pub type GMenuItem = Struct__GMenuItem;
pub enum Struct__GMenu { }
pub type GMenu = Struct__GMenu;
pub enum Struct__GDBusMenuModel { }
pub type GDBusMenuModel = Struct__GDBusMenuModel;
pub enum Struct__GListModel { }
pub type GListModel = Struct__GListModel;
pub type GListModelInterface = Struct__GListModelInterface;
pub type GListModel_autoptr = *mut GListModel;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__GListModelInterface {
    pub g_iface: GTypeInterface,
    pub get_item_type: ::std::option::Option<unsafe extern "C" fn(list:
                                                                      *mut GListModel)
                                                 -> GType>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(list:
                                                                    *mut GListModel)
                                               -> guint>,
    pub get_item: ::std::option::Option<unsafe extern "C" fn(list:
                                                                 *mut GListModel,
                                                             position: guint)
                                            -> gpointer>,
}
impl ::std::clone::Clone for Struct__GListModelInterface {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__GListModelInterface {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__GListStore { }
pub type GListStore = Struct__GListStore;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed203 {
    pub parent_class: GObjectClass,
}
impl ::std::clone::Clone for Struct_Unnamed203 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed203 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GListStoreClass = Struct_Unnamed203;
pub type GListStore_autoptr = *mut GListStore;
pub type GAction_autoptr = *mut GAction;
pub type GActionMap_autoptr = *mut GActionMap;
pub type GAppInfo_autoptr = *mut GAppInfo;
pub type GAppLaunchContext_autoptr = *mut GAppLaunchContext;
pub type GAppInfoMonitor_autoptr = *mut GAppInfoMonitor;
pub type GApplicationCommandLine_autoptr = *mut GApplicationCommandLine;
pub type GApplication_autoptr = *mut GApplication;
pub type GAsyncInitable_autoptr = *mut GAsyncInitable;
pub type GAsyncResult_autoptr = *mut GAsyncResult;
pub type GBufferedInputStream_autoptr = *mut GBufferedInputStream;
pub type GBufferedOutputStream_autoptr = *mut GBufferedOutputStream;
pub type GBytesIcon_autoptr = *mut GBytesIcon;
pub type GCancellable_autoptr = *mut GCancellable;
pub type GCharsetConverter_autoptr = *mut GCharsetConverter;
pub type GConverter_autoptr = *mut GConverter;
pub type GConverterInputStream_autoptr = *mut GConverterInputStream;
pub type GConverterOutputStream_autoptr = *mut GConverterOutputStream;
pub type GCredentials_autoptr = *mut GCredentials;
pub type GDataInputStream_autoptr = *mut GDataInputStream;
pub type GDataOutputStream_autoptr = *mut GDataOutputStream;
pub type GDBusActionGroup_autoptr = *mut GDBusActionGroup;
pub type GDBusAuthObserver_autoptr = *mut GDBusAuthObserver;
pub type GDBusConnection_autoptr = *mut GDBusConnection;
pub type GDBusInterface_autoptr = *mut GDBusInterface;
pub type GDBusInterfaceSkeleton_autoptr = *mut GDBusInterfaceSkeleton;
pub type GDBusMenuModel_autoptr = *mut GDBusMenuModel;
pub type GDBusMessage_autoptr = *mut GDBusMessage;
pub type GDBusMethodInvocation_autoptr = *mut GDBusMethodInvocation;
pub type GDBusNodeInfo_autoptr = *mut GDBusNodeInfo;
pub type GDBusObject_autoptr = *mut GDBusObject;
pub type GDBusObjectManagerClient_autoptr = *mut GDBusObjectManagerClient;
pub type GDBusObjectManager_autoptr = *mut GDBusObjectManager;
pub type GDBusObjectManagerServer_autoptr = *mut GDBusObjectManagerServer;
pub type GDBusObjectProxy_autoptr = *mut GDBusObjectProxy;
pub type GDBusObjectSkeleton_autoptr = *mut GDBusObjectSkeleton;
pub type GDBusProxy_autoptr = *mut GDBusProxy;
pub type GDBusServer_autoptr = *mut GDBusServer;
pub type GDrive_autoptr = *mut GDrive;
pub type GEmblemedIcon_autoptr = *mut GEmblemedIcon;
pub type GEmblem_autoptr = *mut GEmblem;
pub type GFileEnumerator_autoptr = *mut GFileEnumerator;
pub type GFile_autoptr = *mut GFile;
pub type GFileIcon_autoptr = *mut GFileIcon;
pub type GFileInfo_autoptr = *mut GFileInfo;
pub type GFileInputStream_autoptr = *mut GFileInputStream;
pub type GFileIOStream_autoptr = *mut GFileIOStream;
pub type GFileMonitor_autoptr = *mut GFileMonitor;
pub type GFilenameCompleter_autoptr = *mut GFilenameCompleter;
pub type GFileOutputStream_autoptr = *mut GFileOutputStream;
pub type GFilterInputStream_autoptr = *mut GFilterInputStream;
pub type GFilterOutputStream_autoptr = *mut GFilterOutputStream;
pub type GIcon_autoptr = *mut GIcon;
pub type GInetAddress_autoptr = *mut GInetAddress;
pub type GInetAddressMask_autoptr = *mut GInetAddressMask;
pub type GInetSocketAddress_autoptr = *mut GInetSocketAddress;
pub type GInitable_autoptr = *mut GInitable;
pub type GInputStream_autoptr = *mut GInputStream;
pub type GIOModule_autoptr = *mut GIOModule;
pub type GIOStream_autoptr = *mut GIOStream;
pub type GLoadableIcon_autoptr = *mut GLoadableIcon;
pub type GMemoryInputStream_autoptr = *mut GMemoryInputStream;
pub type GMemoryOutputStream_autoptr = *mut GMemoryOutputStream;
pub type GMenu_autoptr = *mut GMenu;
pub type GMenuItem_autoptr = *mut GMenuItem;
pub type GMenuModel_autoptr = *mut GMenuModel;
pub type GMenuAttributeIter_autoptr = *mut GMenuAttributeIter;
pub type GMenuLinkIter_autoptr = *mut GMenuLinkIter;
pub type GMount_autoptr = *mut GMount;
pub type GMountOperation_autoptr = *mut GMountOperation;
pub type GNativeVolumeMonitor_autoptr = *mut GNativeVolumeMonitor;
pub type GNetworkAddress_autoptr = *mut GNetworkAddress;
pub type GNetworkMonitor_autoptr = *mut GNetworkMonitor;
pub type GNetworkService_autoptr = *mut GNetworkService;
pub type GNotification_autoptr = *mut GNotification;
pub type GOutputStream_autoptr = *mut GOutputStream;
pub type GPermission_autoptr = *mut GPermission;
pub type GPollableInputStream_autoptr = *mut GPollableInputStream;
pub type GPollableOutputStream_autoptr = *mut GPollableOutputStream;
pub type GPropertyAction_autoptr = *mut GPropertyAction;
pub type GProxyAddressEnumerator_autoptr = *mut GProxyAddressEnumerator;
pub type GProxyAddress_autoptr = *mut GProxyAddress;
pub type GProxy_autoptr = *mut GProxy;
pub type GProxyResolver_autoptr = *mut GProxyResolver;
pub type GRemoteActionGroup_autoptr = *mut GRemoteActionGroup;
pub type GResolver_autoptr = *mut GResolver;
pub type GSeekable_autoptr = *mut GSeekable;
pub type GSettingsBackend_autoptr = *mut GSettingsBackend;
pub type GSettingsSchema_autoptr = *mut GSettingsSchema;
pub type GSettings_autoptr = *mut GSettings;
pub type GSimpleActionGroup_autoptr = *mut GSimpleActionGroup;
pub type GSimpleAction_autoptr = *mut GSimpleAction;
pub type GSimpleAsyncResult_autoptr = *mut GSimpleAsyncResult;
pub type GSimplePermission_autoptr = *mut GSimplePermission;
pub type GSimpleProxyResolver_autoptr = *mut GSimpleProxyResolver;
pub type GSocketAddressEnumerator_autoptr = *mut GSocketAddressEnumerator;
pub type GSocketAddress_autoptr = *mut GSocketAddress;
pub type GSocketClient_autoptr = *mut GSocketClient;
pub type GSocketConnectable_autoptr = *mut GSocketConnectable;
pub type GSocketConnection_autoptr = *mut GSocketConnection;
pub type GSocketControlMessage_autoptr = *mut GSocketControlMessage;
pub type GSocket_autoptr = *mut GSocket;
pub type GSocketListener_autoptr = *mut GSocketListener;
pub type GSocketService_autoptr = *mut GSocketService;
pub type GSubprocess_autoptr = *mut GSubprocess;
pub type GSubprocessLauncher_autoptr = *mut GSubprocessLauncher;
pub type GTask_autoptr = *mut GTask;
pub type GTcpConnection_autoptr = *mut GTcpConnection;
pub type GTcpWrapperConnection_autoptr = *mut GTcpWrapperConnection;
pub type GTestDBus_autoptr = *mut GTestDBus;
pub type GThemedIcon_autoptr = *mut GThemedIcon;
pub type GThreadedSocketService_autoptr = *mut GThreadedSocketService;
pub type GTlsBackend_autoptr = *mut GTlsBackend;
pub type GTlsCertificate_autoptr = *mut GTlsCertificate;
pub type GTlsClientConnection_autoptr = *mut GTlsClientConnection;
pub type GTlsConnection_autoptr = *mut GTlsConnection;
pub type GTlsDatabase_autoptr = *mut GTlsDatabase;
pub type GTlsFileDatabase_autoptr = *mut GTlsFileDatabase;
pub type GTlsInteraction_autoptr = *mut GTlsInteraction;
pub type GTlsPassword_autoptr = *mut GTlsPassword;
pub type GTlsServerConnection_autoptr = *mut GTlsServerConnection;
pub type GVfs_autoptr = *mut GVfs;
pub type GVolume_autoptr = *mut GVolume;
pub type GVolumeMonitor_autoptr = *mut GVolumeMonitor;
pub type GZlibCompressor_autoptr = *mut GZlibCompressor;
pub type GZlibDecompressor_autoptr = *mut GZlibDecompressor;
pub type HifContext = Struct__HifContext;
pub type HifDb = Struct__HifDb;
pub type HifTransaction = Struct__HifTransaction;
pub type HifRepos = Struct__HifRepos;
pub type HifRepo = Struct__HifRepo;
pub type HifState = Struct__HifState;
pub type HifSack = Struct__HifSack;
pub type HifPackageSet = Struct__HifPackageSet;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed204 {
    HIF_ERROR_FAILED = 1,
    HIF_ERROR_INTERNAL_ERROR = 4,
    HIF_ERROR_CANNOT_GET_LOCK = 26,
    HIF_ERROR_CANCELLED = 17,
    HIF_ERROR_REPO_NOT_AVAILABLE = 37,
    HIF_ERROR_CANNOT_FETCH_SOURCE = 64,
    HIF_ERROR_CANNOT_WRITE_REPO_CONFIG = 28,
    HIF_ERROR_PACKAGE_CONFLICTS = 36,
    HIF_ERROR_NO_PACKAGES_TO_UPDATE = 27,
    HIF_ERROR_PACKAGE_INSTALL_BLOCKED = 39,
    HIF_ERROR_FILE_NOT_FOUND = 42,
    HIF_ERROR_UNFINISHED_TRANSACTION = 66,
    HIF_ERROR_GPG_SIGNATURE_INVALID = 30,
    HIF_ERROR_FILE_INVALID = 38,
    HIF_ERROR_REPO_NOT_FOUND = 19,
    HIF_ERROR_FAILED_CONFIG_PARSING = 24,
    HIF_ERROR_PACKAGE_NOT_FOUND = 8,
    HIF_ERROR_INVALID_ARCHITECTURE = 9,
    HIF_ERROR_BAD_SELECTOR = 10,
    HIF_ERROR_NO_SOLUTION = 11,
    HIF_ERROR_BAD_QUERY = 12,
    HIF_ERROR_CANNOT_WRITE_CACHE = 13,
    HIF_ERROR_NO_CAPABILITY = 14,
    HIF_ERROR_LAST = 15,
}
pub type HifError = Enum_Unnamed204;
pub type HyForm = Enum__HyForm;
pub enum Struct__HyRepo { }
pub type HyRepo = *mut Struct__HyRepo;
pub enum Struct__HyGoal { }
pub type HyGoal = *mut Struct__HyGoal;
pub enum Struct__HyNevra { }
pub type HyNevra = *mut Struct__HyNevra;
pub type HyPossibilities = *mut Struct__HyPossibilities;
pub enum Struct__HyQuery { }
pub type HyQuery = *mut Struct__HyQuery;
pub enum Struct__HyReldep { }
pub type HyReldep = *mut Struct__HyReldep;
pub enum Struct__HyReldepList { }
pub type HyReldepList = *mut Struct__HyReldepList;
pub enum Struct__HySelector { }
pub type HySelector = *mut Struct__HySelector;
pub type HySubject = *mut ::std::os::raw::c_char;
pub type HyChecksum = ::std::os::raw::c_uchar;
pub type hy_solution_callback =
    ::std::option::Option<unsafe extern "C" fn(goal: HyGoal,
                                               callback_data:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum__hy_key_name_e {
    HY_PKG = 0,
    HY_PKG_ALL = 1,
    HY_PKG_ARCH = 2,
    HY_PKG_CONFLICTS = 3,
    HY_PKG_DESCRIPTION = 4,
    HY_PKG_EPOCH = 5,
    HY_PKG_EVR = 6,
    HY_PKG_FILE = 7,
    HY_PKG_NAME = 8,
    HY_PKG_NEVRA = 9,
    HY_PKG_OBSOLETES = 10,
    HY_PKG_PROVIDES = 11,
    HY_PKG_RELEASE = 12,
    HY_PKG_REPONAME = 13,
    HY_PKG_REQUIRES = 14,
    HY_PKG_SOURCERPM = 15,
    HY_PKG_SUMMARY = 16,
    HY_PKG_URL = 17,
    HY_PKG_VERSION = 18,
    HY_PKG_LOCATION = 19,
    HY_PKG_ENHANCES = 20,
    HY_PKG_RECOMMENDS = 21,
    HY_PKG_SUGGESTS = 22,
    HY_PKG_SUPPLEMENTS = 23,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum__hy_comparison_type_e {
    HY_ICASE = 1,
    HY_NOT = 2,
    HY_COMPARISON_FLAG_MASK = 3,
    HY_EQ = 256,
    HY_LT = 512,
    HY_GT = 1024,
    HY_SUBSTR = 2048,
    HY_GLOB = 4096,
    HY_NEQ = 258,
    HY_NAME_ONLY = 65536,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum__hy_repo_param_e {
    HY_REPO_NAME = 0,
    HY_REPO_MD_FN = 1,
    HY_REPO_PRESTO_FN = 2,
    HY_REPO_PRIMARY_FN = 3,
    HY_REPO_FILELISTS_FN = 4,
    HY_REPO_UPDATEINFO_FN = 5,
}
pub type FILE = Struct__IO_FILE;
pub type __FILE = Struct__IO_FILE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed205 {
    pub __count: ::std::os::raw::c_int,
    pub __value: Union_Unnamed206,
}
impl ::std::clone::Clone for Struct_Unnamed205 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed205 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed206 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed206 {
    pub unsafe fn __wch(&mut self) -> *mut ::std::os::raw::c_uint {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wchb(&mut self) -> *mut [::std::os::raw::c_char; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed206 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed206 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __mbstate_t = Struct_Unnamed205;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed207 {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
impl ::std::clone::Clone for Struct_Unnamed207 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed207 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _G_fpos_t = Struct_Unnamed207;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed208 {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
impl ::std::clone::Clone for Struct_Unnamed208 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed208 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _G_fpos64_t = Struct_Unnamed208;
pub enum Struct__IO_jump_t { }
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__IO_marker {
    pub _next: *mut Struct__IO_marker,
    pub _sbuf: *mut Struct__IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct__IO_marker {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__IO_marker {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum___codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut Struct__IO_marker,
    pub _chain: *mut Struct__IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_char,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
impl ::std::clone::Clone for Struct__IO_FILE {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__IO_FILE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _IO_FILE = Struct__IO_FILE;
pub enum Struct__IO_FILE_plus { }
pub type __io_read_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __buf: *mut ::std::os::raw::c_char, __nbytes: size_t)
        -> __ssize_t;
pub type __io_write_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __buf: *const ::std::os::raw::c_char, __n: size_t)
        -> __ssize_t;
pub type __io_seek_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void,
                         __pos: *mut __off64_t, __w: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
pub type __io_close_fn =
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
pub type fpos_t = _G_fpos_t;
pub type Stringpool = Struct__Stringpool;
pub type Pool = Struct__Pool;
pub type Id = ::std::os::raw::c_int;
pub type Offset = ::std::os::raw::c_uint;
pub type Hashval = ::std::os::raw::c_uint;
pub type Hashtable = *mut Id;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__Reldep {
    pub name: Id,
    pub evr: Id,
    pub flags: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct__Reldep {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__Reldep {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Reldep = Struct__Reldep;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__Queue {
    pub elements: *mut Id,
    pub count: ::std::os::raw::c_int,
    pub alloc: *mut Id,
    pub left: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct__Queue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__Queue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Queue = Struct__Queue;
pub enum Struct__Repo { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct__Solvable {
    pub name: Id,
    pub arch: Id,
    pub evr: Id,
    pub vendor: Id,
    pub repo: *mut Struct__Repo,
    pub provides: Offset,
    pub obsoletes: Offset,
    pub conflicts: Offset,
    pub requires: Offset,
    pub recommends: Offset,
    pub suggests: Offset,
    pub supplements: Offset,
    pub enhances: Offset,
}
impl ::std::clone::Clone for Struct__Solvable {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__Solvable {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Solvable = Struct__Solvable;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__Map {
    pub map: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct__Map {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__Map {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Map = Struct__Map;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__Stringpool {
    pub strings: *mut Offset,
    pub nstrings: ::std::os::raw::c_int,
    pub stringspace: *mut ::std::os::raw::c_char,
    pub sstrings: Offset,
    pub stringhashtbl: Hashtable,
    pub stringhashmask: Hashval,
}
impl ::std::clone::Clone for Struct__Stringpool {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__Stringpool {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_solv_knownid {
    ID_NULL = 0,
    ID_EMPTY = 1,
    SOLVABLE_NAME = 2,
    SOLVABLE_ARCH = 3,
    SOLVABLE_EVR = 4,
    SOLVABLE_VENDOR = 5,
    SOLVABLE_PROVIDES = 6,
    SOLVABLE_OBSOLETES = 7,
    SOLVABLE_CONFLICTS = 8,
    SOLVABLE_REQUIRES = 9,
    SOLVABLE_RECOMMENDS = 10,
    SOLVABLE_SUGGESTS = 11,
    SOLVABLE_SUPPLEMENTS = 12,
    SOLVABLE_ENHANCES = 13,
    RPM_RPMDBID = 14,
    SOLVABLE_PREREQMARKER = 15,
    SOLVABLE_FILEMARKER = 16,
    NAMESPACE_INSTALLED = 17,
    NAMESPACE_MODALIAS = 18,
    NAMESPACE_SPLITPROVIDES = 19,
    NAMESPACE_LANGUAGE = 20,
    NAMESPACE_FILESYSTEM = 21,
    NAMESPACE_OTHERPROVIDERS = 22,
    SYSTEM_SYSTEM = 23,
    ARCH_SRC = 24,
    ARCH_NOSRC = 25,
    ARCH_NOARCH = 26,
    ARCH_ALL = 27,
    ARCH_ANY = 28,
    REPOSITORY_SOLVABLES = 29,
    REPOSITORY_DELTAINFO = 30,
    REPOSITORY_EXTERNAL = 31,
    REPOSITORY_KEYS = 32,
    REPOSITORY_LOCATION = 33,
    REPOSITORY_ADDEDFILEPROVIDES = 34,
    REPOSITORY_RPMDBCOOKIE = 35,
    REPOKEY_TYPE_VOID = 36,
    REPOKEY_TYPE_CONSTANT = 37,
    REPOKEY_TYPE_CONSTANTID = 38,
    REPOKEY_TYPE_ID = 39,
    REPOKEY_TYPE_NUM = 40,
    REPOKEY_TYPE_U32 = 41,
    REPOKEY_TYPE_DIR = 42,
    REPOKEY_TYPE_STR = 43,
    REPOKEY_TYPE_BINARY = 44,
    REPOKEY_TYPE_IDARRAY = 45,
    REPOKEY_TYPE_REL_IDARRAY = 46,
    REPOKEY_TYPE_DIRSTRARRAY = 47,
    REPOKEY_TYPE_DIRNUMNUMARRAY = 48,
    REPOKEY_TYPE_MD5 = 49,
    REPOKEY_TYPE_SHA1 = 50,
    REPOKEY_TYPE_SHA224 = 51,
    REPOKEY_TYPE_SHA256 = 52,
    REPOKEY_TYPE_SHA384 = 53,
    REPOKEY_TYPE_SHA512 = 54,
    REPOKEY_TYPE_FIXARRAY = 55,
    REPOKEY_TYPE_FLEXARRAY = 56,
    REPOKEY_TYPE_DELETED = 57,
    SOLVABLE_SUMMARY = 58,
    SOLVABLE_DESCRIPTION = 59,
    SOLVABLE_DISTRIBUTION = 60,
    SOLVABLE_AUTHORS = 61,
    SOLVABLE_PACKAGER = 62,
    SOLVABLE_GROUP = 63,
    SOLVABLE_URL = 64,
    SOLVABLE_KEYWORDS = 65,
    SOLVABLE_LICENSE = 66,
    SOLVABLE_BUILDTIME = 67,
    SOLVABLE_BUILDHOST = 68,
    SOLVABLE_EULA = 69,
    SOLVABLE_CPEID = 70,
    SOLVABLE_MESSAGEINS = 71,
    SOLVABLE_MESSAGEDEL = 72,
    SOLVABLE_INSTALLSIZE = 73,
    SOLVABLE_DISKUSAGE = 74,
    SOLVABLE_FILELIST = 75,
    SOLVABLE_INSTALLTIME = 76,
    SOLVABLE_MEDIADIR = 77,
    SOLVABLE_MEDIAFILE = 78,
    SOLVABLE_MEDIANR = 79,
    SOLVABLE_MEDIABASE = 80,
    SOLVABLE_DOWNLOADSIZE = 81,
    SOLVABLE_SOURCEARCH = 82,
    SOLVABLE_SOURCENAME = 83,
    SOLVABLE_SOURCEEVR = 84,
    SOLVABLE_ISVISIBLE = 85,
    SOLVABLE_TRIGGERS = 86,
    SOLVABLE_CHECKSUM = 87,
    SOLVABLE_PKGID = 88,
    SOLVABLE_HDRID = 89,
    SOLVABLE_LEADSIGID = 90,
    SOLVABLE_PATCHCATEGORY = 91,
    SOLVABLE_HEADEREND = 92,
    SOLVABLE_CHANGELOG = 93,
    SOLVABLE_CHANGELOG_AUTHOR = 94,
    SOLVABLE_CHANGELOG_TIME = 95,
    SOLVABLE_CHANGELOG_TEXT = 96,
    SOLVABLE_CATEGORY = 97,
    SOLVABLE_INCLUDES = 98,
    SOLVABLE_EXTENDS = 99,
    SOLVABLE_ICON = 100,
    SOLVABLE_ORDER = 101,
    UPDATE_REBOOT = 102,
    UPDATE_RESTART = 103,
    UPDATE_RELOGIN = 104,
    UPDATE_MESSAGE = 105,
    UPDATE_SEVERITY = 106,
    UPDATE_RIGHTS = 107,
    UPDATE_COLLECTION = 108,
    UPDATE_COLLECTION_NAME = 109,
    UPDATE_COLLECTION_EVR = 110,
    UPDATE_COLLECTION_ARCH = 111,
    UPDATE_COLLECTION_FILENAME = 112,
    UPDATE_COLLECTION_FLAGS = 113,
    UPDATE_REFERENCE = 114,
    UPDATE_REFERENCE_TYPE = 115,
    UPDATE_REFERENCE_HREF = 116,
    UPDATE_REFERENCE_ID = 117,
    UPDATE_REFERENCE_TITLE = 118,
    PRODUCT_REFERENCEFILE = 119,
    PRODUCT_SHORTLABEL = 120,
    PRODUCT_DISTPRODUCT = 121,
    PRODUCT_DISTVERSION = 122,
    PRODUCT_TYPE = 123,
    PRODUCT_URL = 124,
    PRODUCT_URL_TYPE = 125,
    PRODUCT_FLAGS = 126,
    PRODUCT_PRODUCTLINE = 127,
    PRODUCT_REGISTER_TARGET = 128,
    PRODUCT_REGISTER_RELEASE = 129,
    PRODUCT_UPDATES_REPOID = 130,
    PRODUCT_UPDATES = 131,
    PRODUCT_ENDOFLIFE = 132,
    SUSETAGS_DATADIR = 133,
    SUSETAGS_DESCRDIR = 134,
    SUSETAGS_DEFAULTVENDOR = 135,
    SUSETAGS_FILE = 136,
    SUSETAGS_FILE_NAME = 137,
    SUSETAGS_FILE_TYPE = 138,
    SUSETAGS_FILE_CHECKSUM = 139,
    SUSETAGS_SHARE_NAME = 140,
    SUSETAGS_SHARE_EVR = 141,
    SUSETAGS_SHARE_ARCH = 142,
    REPOSITORY_TIMESTAMP = 143,
    REPOSITORY_EXPIRE = 144,
    REPOSITORY_UPDATES = 145,
    REPOSITORY_DISTROS = 146,
    REPOSITORY_PRODUCT_LABEL = 147,
    REPOSITORY_PRODUCT_CPEID = 148,
    REPOSITORY_REPOID = 149,
    REPOSITORY_KEYWORDS = 150,
    REPOSITORY_REVISION = 151,
    REPOSITORY_TOOLVERSION = 152,
    DELTA_PACKAGE_NAME = 153,
    DELTA_PACKAGE_EVR = 154,
    DELTA_PACKAGE_ARCH = 155,
    DELTA_LOCATION_DIR = 156,
    DELTA_LOCATION_NAME = 157,
    DELTA_LOCATION_EVR = 158,
    DELTA_LOCATION_SUFFIX = 159,
    DELTA_DOWNLOADSIZE = 160,
    DELTA_CHECKSUM = 161,
    DELTA_BASE_EVR = 162,
    DELTA_SEQ_NAME = 163,
    DELTA_SEQ_EVR = 164,
    DELTA_SEQ_NUM = 165,
    DELTA_LOCATION_BASE = 166,
    REPOSITORY_REPOMD = 167,
    REPOSITORY_REPOMD_TYPE = 168,
    REPOSITORY_REPOMD_LOCATION = 169,
    REPOSITORY_REPOMD_TIMESTAMP = 170,
    REPOSITORY_REPOMD_CHECKSUM = 171,
    REPOSITORY_REPOMD_OPENCHECKSUM = 172,
    REPOSITORY_REPOMD_SIZE = 173,
    PUBKEY_KEYID = 174,
    PUBKEY_FINGERPRINT = 175,
    PUBKEY_EXPIRES = 176,
    PUBKEY_SIGNATURES = 177,
    PUBKEY_DATA = 178,
    PUBKEY_SUBKEYOF = 179,
    SIGNATURE_ISSUER = 180,
    SIGNATURE_TIME = 181,
    SIGNATURE_EXPIRES = 182,
    SIGNATURE_DATA = 183,
    PRODUCT_REGISTER_FLAVOR = 184,
    SOLVABLE_INSTALLSTATUS = 185,
    ID_NUM_INTERNAL = 186,
}
pub enum Struct__Repodata { }
pub enum Struct__Repokey { }
pub enum Struct__KeyValue { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct__Datapos {
    pub repo: *mut Struct__Repo,
    pub solvid: Id,
    pub repodataid: Id,
    pub schema: Id,
    pub dp: Id,
}
impl ::std::clone::Clone for Struct__Datapos {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__Datapos {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Datapos = Struct__Datapos;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__Pool {
    pub appdata: *mut ::std::os::raw::c_void,
    pub ss: Struct__Stringpool,
    pub rels: *mut Reldep,
    pub nrels: ::std::os::raw::c_int,
    pub repos: *mut *mut Struct__Repo,
    pub nrepos: ::std::os::raw::c_int,
    pub urepos: ::std::os::raw::c_int,
    pub installed: *mut Struct__Repo,
    pub solvables: *mut Solvable,
    pub nsolvables: ::std::os::raw::c_int,
    pub languages: *mut *const ::std::os::raw::c_char,
    pub nlanguages: ::std::os::raw::c_int,
    pub disttype: ::std::os::raw::c_int,
    pub id2arch: *mut Id,
    pub id2color: *mut ::std::os::raw::c_uchar,
    pub lastarch: Id,
    pub vendormap: Queue,
    pub vendorclasses: *mut *const ::std::os::raw::c_char,
    pub whatprovides: *mut Offset,
    pub whatprovides_rel: *mut Offset,
    pub whatprovidesdata: *mut Id,
    pub whatprovidesdataoff: Offset,
    pub whatprovidesdataleft: ::std::os::raw::c_int,
    pub considered: *mut Map,
    pub nscallback: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut Struct__Pool,
                                                               data:
                                                                   *mut ::std::os::raw::c_void,
                                                               name: Id,
                                                               evr: Id)
                                              -> Id>,
    pub nscallbackdata: *mut ::std::os::raw::c_void,
    pub debugmask: ::std::os::raw::c_int,
    pub debugcallback: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut Struct__Pool,
                                                                  data:
                                                                      *mut ::std::os::raw::c_void,
                                                                  _type:
                                                                      ::std::os::raw::c_int,
                                                                  str:
                                                                      *const ::std::os::raw::c_char)>,
    pub debugcallbackdata: *mut ::std::os::raw::c_void,
    pub loadcallback: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut Struct__Pool,
                                                                 arg2:
                                                                     *mut Struct__Repodata,
                                                                 arg3:
                                                                     *mut ::std::os::raw::c_void)
                                                -> ::std::os::raw::c_int>,
    pub loadcallbackdata: *mut ::std::os::raw::c_void,
    pub pos: Datapos,
    pub pooljobs: Queue,
}
impl ::std::clone::Clone for Struct__Pool {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__Pool {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__DUChanges {
    pub path: *const ::std::os::raw::c_char,
    pub kbytes: ::std::os::raw::c_int,
    pub files: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct__DUChanges {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__DUChanges {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DUChanges = Struct__DUChanges;
pub type HifPackageDelta = Struct__HifPackageDelta;
pub type HifPackageDeltaClass = Struct__HifPackageDeltaClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifPackageDelta {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifPackageDelta {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifPackageDelta {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifPackageDelta_autoptr = *mut HifPackageDelta;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifPackageDeltaClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifPackageDeltaClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifPackageDeltaClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifPackage = Struct__HifPackage;
pub type HifPackageClass = Struct__HifPackageClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifPackage {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifPackage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifPackage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifPackage_autoptr = *mut HifPackage;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifPackageClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifPackageClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifPackageClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifLock = Struct__HifLock;
pub type HifLockClass = Struct__HifLockClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifLock {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifLock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifLock_autoptr = *mut HifLock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifLockClass {
    pub parent_class: GObjectClass,
    pub state_changed: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                      *mut HifLock,
                                                                  state_bitfield:
                                                                      guint)>,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifLockClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifLockClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed209 {
    HIF_LOCK_TYPE_RPMDB = 0,
    HIF_LOCK_TYPE_REPO = 1,
    HIF_LOCK_TYPE_METADATA = 2,
    HIF_LOCK_TYPE_CONFIG = 3,
    HIF_LOCK_TYPE_LAST = 4,
}
pub type HifLockType = Enum_Unnamed209;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed210 {
    HIF_LOCK_MODE_THREAD = 0,
    HIF_LOCK_MODE_PROCESS = 1,
    HIF_LOCK_MODE_LAST = 2,
}
pub type HifLockMode = Enum_Unnamed210;
pub type HifStateClass = Struct__HifStateClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifState {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifState {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifState_autoptr = *mut HifState;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed211 {
    HIF_STATE_ACTION_UNKNOWN = 0,
    HIF_STATE_ACTION_DOWNLOAD_PACKAGES = 8,
    HIF_STATE_ACTION_DOWNLOAD_METADATA = 20,
    HIF_STATE_ACTION_LOADING_CACHE = 27,
    HIF_STATE_ACTION_TEST_COMMIT = 15,
    HIF_STATE_ACTION_REQUEST = 17,
    HIF_STATE_ACTION_REMOVE = 6,
    HIF_STATE_ACTION_INSTALL = 9,
    HIF_STATE_ACTION_UPDATE = 10,
    HIF_STATE_ACTION_CLEANUP = 11,
    HIF_STATE_ACTION_OBSOLETE = 12,
    HIF_STATE_ACTION_REINSTALL = 13,
    HIF_STATE_ACTION_DOWNGRADE = 14,
    HIF_STATE_ACTION_QUERY = 4,
    HIF_STATE_ACTION_LAST = 5,
}
pub type HifStateAction = Enum_Unnamed211;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifStateClass {
    pub parent_class: GObjectClass,
    pub percentage_changed: ::std::option::Option<unsafe extern "C" fn(state:
                                                                           *mut HifState,
                                                                       value:
                                                                           guint)>,
    pub allow_cancel_changed: ::std::option::Option<unsafe extern "C" fn(state:
                                                                             *mut HifState,
                                                                         allow_cancel:
                                                                             gboolean)>,
    pub action_changed: ::std::option::Option<unsafe extern "C" fn(state:
                                                                       *mut HifState,
                                                                   action:
                                                                       HifStateAction,
                                                                   action_hint:
                                                                       *const gchar)>,
    pub package_progress_changed: ::std::option::Option<unsafe extern "C" fn(state:
                                                                                 *mut HifState,
                                                                             hif_package_get_id:
                                                                                 *const gchar,
                                                                             action:
                                                                                 HifStateAction,
                                                                             percentage:
                                                                                 guint)>,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifStateClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifStateClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifStateErrorHandlerCb =
    ::std::option::Option<unsafe extern "C" fn(error: *const GError,
                                               user_data: gpointer)
                              -> gboolean>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed212 {
    LR_CHECKSUM_UNKNOWN = 0,
    LR_CHECKSUM_MD5 = 1,
    LR_CHECKSUM_SHA1 = 2,
    LR_CHECKSUM_SHA224 = 3,
    LR_CHECKSUM_SHA256 = 4,
    LR_CHECKSUM_SHA384 = 5,
    LR_CHECKSUM_SHA512 = 6,
}
pub type LrChecksumType = Enum_Unnamed212;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
impl ::std::clone::Clone for Struct_iovec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_iovec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum___socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048,
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
impl ::std::clone::Clone for Struct_sockaddr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_align: ::std::os::raw::c_ulong,
    pub __ss_padding: [::std::os::raw::c_char; 112usize],
}
impl ::std::clone::Clone for Struct_sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed213 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut Struct_iovec,
    pub msg_iovlen: size_t,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: size_t,
    pub msg_flags: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_msghdr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_msghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cmsghdr {
    pub cmsg_len: size_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: *mut ::std::os::raw::c_uchar,
}
impl ::std::clone::Clone for Struct_cmsghdr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cmsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed214 { SCM_RIGHTS = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_linger {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_linger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
impl ::std::clone::Clone for Struct_osockaddr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_osockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed215 { SHUT_RD = 0, SHUT_WR = 1, SHUT_RDWR = 2, }
pub type curl_socklen_t = socklen_t;
pub type curl_off_t = ::std::os::raw::c_long;
pub type __curl_rule_01__ = [::std::os::raw::c_char; 1usize];
pub type __curl_rule_02__ = [::std::os::raw::c_char; 1usize];
pub type __curl_rule_03__ = [::std::os::raw::c_char; 1usize];
pub type __curl_rule_04__ = [::std::os::raw::c_char; 1usize];
pub type __curl_rule_05__ = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_timezone {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timezone {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __timezone_ptr_t = *mut Struct_timezone;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum___itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_itimerval {
    pub it_interval: Struct_timeval,
    pub it_value: Struct_timeval,
}
impl ::std::clone::Clone for Struct_itimerval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_itimerval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __itimer_which_t = ::std::os::raw::c_int;
pub type CURL = ::std::os::raw::c_void;
pub type curl_socket_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_curl_httppost {
    pub next: *mut Struct_curl_httppost,
    pub name: *mut ::std::os::raw::c_char,
    pub namelength: ::std::os::raw::c_long,
    pub contents: *mut ::std::os::raw::c_char,
    pub contentslength: ::std::os::raw::c_long,
    pub buffer: *mut ::std::os::raw::c_char,
    pub bufferlength: ::std::os::raw::c_long,
    pub contenttype: *mut ::std::os::raw::c_char,
    pub contentheader: *mut Struct_curl_slist,
    pub more: *mut Struct_curl_httppost,
    pub flags: ::std::os::raw::c_long,
    pub showfilename: *mut ::std::os::raw::c_char,
    pub userp: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_curl_httppost {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_curl_httppost {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type curl_progress_callback =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               dltotal:
                                                   ::std::os::raw::c_double,
                                               dlnow:
                                                   ::std::os::raw::c_double,
                                               ultotal:
                                                   ::std::os::raw::c_double,
                                               ulnow:
                                                   ::std::os::raw::c_double)
                              -> ::std::os::raw::c_int>;
pub type curl_xferinfo_callback =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               dltotal: curl_off_t,
                                               dlnow: curl_off_t,
                                               ultotal: curl_off_t,
                                               ulnow: curl_off_t)
                              -> ::std::os::raw::c_int>;
pub type curl_write_callback =
    ::std::option::Option<unsafe extern "C" fn(buffer:
                                                   *mut ::std::os::raw::c_char,
                                               size: size_t, nitems: size_t,
                                               outstream:
                                                   *mut ::std::os::raw::c_void)
                              -> size_t>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed216 {
    CURLFILETYPE_FILE = 0,
    CURLFILETYPE_DIRECTORY = 1,
    CURLFILETYPE_SYMLINK = 2,
    CURLFILETYPE_DEVICE_BLOCK = 3,
    CURLFILETYPE_DEVICE_CHAR = 4,
    CURLFILETYPE_NAMEDPIPE = 5,
    CURLFILETYPE_SOCKET = 6,
    CURLFILETYPE_DOOR = 7,
    CURLFILETYPE_UNKNOWN = 8,
}
pub type curlfiletype = Enum_Unnamed216;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_curl_fileinfo {
    pub filename: *mut ::std::os::raw::c_char,
    pub filetype: curlfiletype,
    pub time: time_t,
    pub perm: ::std::os::raw::c_uint,
    pub uid: ::std::os::raw::c_int,
    pub gid: ::std::os::raw::c_int,
    pub size: curl_off_t,
    pub hardlinks: ::std::os::raw::c_long,
    pub strings: Struct_Unnamed217,
    pub flags: ::std::os::raw::c_uint,
    pub b_data: *mut ::std::os::raw::c_char,
    pub b_size: size_t,
    pub b_used: size_t,
}
impl ::std::clone::Clone for Struct_curl_fileinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_curl_fileinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed217 {
    pub time: *mut ::std::os::raw::c_char,
    pub perm: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub group: *mut ::std::os::raw::c_char,
    pub target: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed217 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed217 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type curl_chunk_bgn_callback =
    ::std::option::Option<unsafe extern "C" fn(transfer_info:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               remains: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_long>;
pub type curl_chunk_end_callback =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_long>;
pub type curl_fnmatch_callback =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               pattern:
                                                   *const ::std::os::raw::c_char,
                                               string:
                                                   *const ::std::os::raw::c_char)
                              -> ::std::os::raw::c_int>;
pub type curl_seek_callback =
    ::std::option::Option<unsafe extern "C" fn(instream:
                                                   *mut ::std::os::raw::c_void,
                                               offset: curl_off_t,
                                               origin: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type curl_read_callback =
    ::std::option::Option<unsafe extern "C" fn(buffer:
                                                   *mut ::std::os::raw::c_char,
                                               size: size_t, nitems: size_t,
                                               instream:
                                                   *mut ::std::os::raw::c_void)
                              -> size_t>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed218 {
    CURLSOCKTYPE_IPCXN = 0,
    CURLSOCKTYPE_ACCEPT = 1,
    CURLSOCKTYPE_LAST = 2,
}
pub type curlsocktype = Enum_Unnamed218;
pub type curl_sockopt_callback =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               curlfd: curl_socket_t,
                                               purpose: curlsocktype)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_curl_sockaddr {
    pub family: ::std::os::raw::c_int,
    pub socktype: ::std::os::raw::c_int,
    pub protocol: ::std::os::raw::c_int,
    pub addrlen: ::std::os::raw::c_uint,
    pub addr: Struct_sockaddr,
}
impl ::std::clone::Clone for Struct_curl_sockaddr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_curl_sockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type curl_opensocket_callback =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               purpose: curlsocktype,
                                               address:
                                                   *mut Struct_curl_sockaddr)
                              -> curl_socket_t>;
pub type curl_closesocket_callback =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               item: curl_socket_t)
                              -> ::std::os::raw::c_int>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed219 {
    CURLIOE_OK = 0,
    CURLIOE_UNKNOWNCMD = 1,
    CURLIOE_FAILRESTART = 2,
    CURLIOE_LAST = 3,
}
pub type curlioerr = Enum_Unnamed219;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed220 {
    CURLIOCMD_NOP = 0,
    CURLIOCMD_RESTARTREAD = 1,
    CURLIOCMD_LAST = 2,
}
pub type curliocmd = Enum_Unnamed220;
pub type curl_ioctl_callback =
    ::std::option::Option<unsafe extern "C" fn(handle: *mut CURL,
                                               cmd: ::std::os::raw::c_int,
                                               clientp:
                                                   *mut ::std::os::raw::c_void)
                              -> curlioerr>;
pub type curl_malloc_callback =
    ::std::option::Option<extern "C" fn(size: size_t)
                              -> *mut ::std::os::raw::c_void>;
pub type curl_free_callback =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void)>;
pub type curl_realloc_callback =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               size: size_t)
                              -> *mut ::std::os::raw::c_void>;
pub type curl_strdup_callback =
    ::std::option::Option<unsafe extern "C" fn(str:
                                                   *const ::std::os::raw::c_char)
                              -> *mut ::std::os::raw::c_char>;
pub type curl_calloc_callback =
    ::std::option::Option<extern "C" fn(nmemb: size_t, size: size_t)
                              -> *mut ::std::os::raw::c_void>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed221 {
    CURLINFO_TEXT = 0,
    CURLINFO_HEADER_IN = 1,
    CURLINFO_HEADER_OUT = 2,
    CURLINFO_DATA_IN = 3,
    CURLINFO_DATA_OUT = 4,
    CURLINFO_SSL_DATA_IN = 5,
    CURLINFO_SSL_DATA_OUT = 6,
    CURLINFO_END = 7,
}
pub type curl_infotype = Enum_Unnamed221;
pub type curl_debug_callback =
    ::std::option::Option<unsafe extern "C" fn(handle: *mut CURL,
                                               _type: curl_infotype,
                                               data:
                                                   *mut ::std::os::raw::c_char,
                                               size: size_t,
                                               userptr:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed222 {
    CURLE_OK = 0,
    CURLE_UNSUPPORTED_PROTOCOL = 1,
    CURLE_FAILED_INIT = 2,
    CURLE_URL_MALFORMAT = 3,
    CURLE_NOT_BUILT_IN = 4,
    CURLE_COULDNT_RESOLVE_PROXY = 5,
    CURLE_COULDNT_RESOLVE_HOST = 6,
    CURLE_COULDNT_CONNECT = 7,
    CURLE_FTP_WEIRD_SERVER_REPLY = 8,
    CURLE_REMOTE_ACCESS_DENIED = 9,
    CURLE_FTP_ACCEPT_FAILED = 10,
    CURLE_FTP_WEIRD_PASS_REPLY = 11,
    CURLE_FTP_ACCEPT_TIMEOUT = 12,
    CURLE_FTP_WEIRD_PASV_REPLY = 13,
    CURLE_FTP_WEIRD_227_FORMAT = 14,
    CURLE_FTP_CANT_GET_HOST = 15,
    CURLE_HTTP2 = 16,
    CURLE_FTP_COULDNT_SET_TYPE = 17,
    CURLE_PARTIAL_FILE = 18,
    CURLE_FTP_COULDNT_RETR_FILE = 19,
    CURLE_OBSOLETE20 = 20,
    CURLE_QUOTE_ERROR = 21,
    CURLE_HTTP_RETURNED_ERROR = 22,
    CURLE_WRITE_ERROR = 23,
    CURLE_OBSOLETE24 = 24,
    CURLE_UPLOAD_FAILED = 25,
    CURLE_READ_ERROR = 26,
    CURLE_OUT_OF_MEMORY = 27,
    CURLE_OPERATION_TIMEDOUT = 28,
    CURLE_OBSOLETE29 = 29,
    CURLE_FTP_PORT_FAILED = 30,
    CURLE_FTP_COULDNT_USE_REST = 31,
    CURLE_OBSOLETE32 = 32,
    CURLE_RANGE_ERROR = 33,
    CURLE_HTTP_POST_ERROR = 34,
    CURLE_SSL_CONNECT_ERROR = 35,
    CURLE_BAD_DOWNLOAD_RESUME = 36,
    CURLE_FILE_COULDNT_READ_FILE = 37,
    CURLE_LDAP_CANNOT_BIND = 38,
    CURLE_LDAP_SEARCH_FAILED = 39,
    CURLE_OBSOLETE40 = 40,
    CURLE_FUNCTION_NOT_FOUND = 41,
    CURLE_ABORTED_BY_CALLBACK = 42,
    CURLE_BAD_FUNCTION_ARGUMENT = 43,
    CURLE_OBSOLETE44 = 44,
    CURLE_INTERFACE_FAILED = 45,
    CURLE_OBSOLETE46 = 46,
    CURLE_TOO_MANY_REDIRECTS = 47,
    CURLE_UNKNOWN_OPTION = 48,
    CURLE_TELNET_OPTION_SYNTAX = 49,
    CURLE_OBSOLETE50 = 50,
    CURLE_PEER_FAILED_VERIFICATION = 51,
    CURLE_GOT_NOTHING = 52,
    CURLE_SSL_ENGINE_NOTFOUND = 53,
    CURLE_SSL_ENGINE_SETFAILED = 54,
    CURLE_SEND_ERROR = 55,
    CURLE_RECV_ERROR = 56,
    CURLE_OBSOLETE57 = 57,
    CURLE_SSL_CERTPROBLEM = 58,
    CURLE_SSL_CIPHER = 59,
    CURLE_SSL_CACERT = 60,
    CURLE_BAD_CONTENT_ENCODING = 61,
    CURLE_LDAP_INVALID_URL = 62,
    CURLE_FILESIZE_EXCEEDED = 63,
    CURLE_USE_SSL_FAILED = 64,
    CURLE_SEND_FAIL_REWIND = 65,
    CURLE_SSL_ENGINE_INITFAILED = 66,
    CURLE_LOGIN_DENIED = 67,
    CURLE_TFTP_NOTFOUND = 68,
    CURLE_TFTP_PERM = 69,
    CURLE_REMOTE_DISK_FULL = 70,
    CURLE_TFTP_ILLEGAL = 71,
    CURLE_TFTP_UNKNOWNID = 72,
    CURLE_REMOTE_FILE_EXISTS = 73,
    CURLE_TFTP_NOSUCHUSER = 74,
    CURLE_CONV_FAILED = 75,
    CURLE_CONV_REQD = 76,
    CURLE_SSL_CACERT_BADFILE = 77,
    CURLE_REMOTE_FILE_NOT_FOUND = 78,
    CURLE_SSH = 79,
    CURLE_SSL_SHUTDOWN_FAILED = 80,
    CURLE_AGAIN = 81,
    CURLE_SSL_CRL_BADFILE = 82,
    CURLE_SSL_ISSUER_ERROR = 83,
    CURLE_FTP_PRET_FAILED = 84,
    CURLE_RTSP_CSEQ_ERROR = 85,
    CURLE_RTSP_SESSION_ERROR = 86,
    CURLE_FTP_BAD_FILE_LIST = 87,
    CURLE_CHUNK_FAILED = 88,
    CURLE_NO_CONNECTION_AVAILABLE = 89,
    CURLE_SSL_PINNEDPUBKEYNOTMATCH = 90,
    CURLE_SSL_INVALIDCERTSTATUS = 91,
    CURL_LAST = 92,
}
pub type CURLcode = Enum_Unnamed222;
pub type curl_conv_callback =
    ::std::option::Option<unsafe extern "C" fn(buffer:
                                                   *mut ::std::os::raw::c_char,
                                               length: size_t) -> CURLcode>;
pub type curl_ssl_ctx_callback =
    ::std::option::Option<unsafe extern "C" fn(curl: *mut CURL,
                                               ssl_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               userptr:
                                                   *mut ::std::os::raw::c_void)
                              -> CURLcode>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed223 {
    CURLPROXY_HTTP = 0,
    CURLPROXY_HTTP_1_0 = 1,
    CURLPROXY_SOCKS4 = 4,
    CURLPROXY_SOCKS5 = 5,
    CURLPROXY_SOCKS4A = 6,
    CURLPROXY_SOCKS5_HOSTNAME = 7,
}
pub type curl_proxytype = Enum_Unnamed223;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_curl_khtype {
    CURLKHTYPE_UNKNOWN = 0,
    CURLKHTYPE_RSA1 = 1,
    CURLKHTYPE_RSA = 2,
    CURLKHTYPE_DSS = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_curl_khkey {
    pub key: *const ::std::os::raw::c_char,
    pub len: size_t,
    pub keytype: Enum_curl_khtype,
}
impl ::std::clone::Clone for Struct_curl_khkey {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_curl_khkey {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_curl_khstat {
    CURLKHSTAT_FINE_ADD_TO_FILE = 0,
    CURLKHSTAT_FINE = 1,
    CURLKHSTAT_REJECT = 2,
    CURLKHSTAT_DEFER = 3,
    CURLKHSTAT_LAST = 4,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_curl_khmatch {
    CURLKHMATCH_OK = 0,
    CURLKHMATCH_MISMATCH = 1,
    CURLKHMATCH_MISSING = 2,
    CURLKHMATCH_LAST = 3,
}
pub type curl_sshkeycallback =
    ::std::option::Option<unsafe extern "C" fn(easy: *mut CURL,
                                               knownkey:
                                                   *const Struct_curl_khkey,
                                               foundkey:
                                                   *const Struct_curl_khkey,
                                               arg1: Enum_curl_khmatch,
                                               clientp:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed224 {
    CURLUSESSL_NONE = 0,
    CURLUSESSL_TRY = 1,
    CURLUSESSL_CONTROL = 2,
    CURLUSESSL_ALL = 3,
    CURLUSESSL_LAST = 4,
}
pub type curl_usessl = Enum_Unnamed224;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed225 {
    CURLFTPSSL_CCC_NONE = 0,
    CURLFTPSSL_CCC_PASSIVE = 1,
    CURLFTPSSL_CCC_ACTIVE = 2,
    CURLFTPSSL_CCC_LAST = 3,
}
pub type curl_ftpccc = Enum_Unnamed225;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed226 {
    CURLFTPAUTH_DEFAULT = 0,
    CURLFTPAUTH_SSL = 1,
    CURLFTPAUTH_TLS = 2,
    CURLFTPAUTH_LAST = 3,
}
pub type curl_ftpauth = Enum_Unnamed226;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed227 {
    CURLFTP_CREATE_DIR_NONE = 0,
    CURLFTP_CREATE_DIR = 1,
    CURLFTP_CREATE_DIR_RETRY = 2,
    CURLFTP_CREATE_DIR_LAST = 3,
}
pub type curl_ftpcreatedir = Enum_Unnamed227;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed228 {
    CURLFTPMETHOD_DEFAULT = 0,
    CURLFTPMETHOD_MULTICWD = 1,
    CURLFTPMETHOD_NOCWD = 2,
    CURLFTPMETHOD_SINGLECWD = 3,
    CURLFTPMETHOD_LAST = 4,
}
pub type curl_ftpmethod = Enum_Unnamed228;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed229 {
    CURLOPT_WRITEDATA = 10001,
    CURLOPT_URL = 10002,
    CURLOPT_PORT = 3,
    CURLOPT_PROXY = 10004,
    CURLOPT_USERPWD = 10005,
    CURLOPT_PROXYUSERPWD = 10006,
    CURLOPT_RANGE = 10007,
    CURLOPT_READDATA = 10009,
    CURLOPT_ERRORBUFFER = 10010,
    CURLOPT_WRITEFUNCTION = 20011,
    CURLOPT_READFUNCTION = 20012,
    CURLOPT_TIMEOUT = 13,
    CURLOPT_INFILESIZE = 14,
    CURLOPT_POSTFIELDS = 10015,
    CURLOPT_REFERER = 10016,
    CURLOPT_FTPPORT = 10017,
    CURLOPT_USERAGENT = 10018,
    CURLOPT_LOW_SPEED_LIMIT = 19,
    CURLOPT_LOW_SPEED_TIME = 20,
    CURLOPT_RESUME_FROM = 21,
    CURLOPT_COOKIE = 10022,
    CURLOPT_HTTPHEADER = 10023,
    CURLOPT_HTTPPOST = 10024,
    CURLOPT_SSLCERT = 10025,
    CURLOPT_KEYPASSWD = 10026,
    CURLOPT_CRLF = 27,
    CURLOPT_QUOTE = 10028,
    CURLOPT_HEADERDATA = 10029,
    CURLOPT_COOKIEFILE = 10031,
    CURLOPT_SSLVERSION = 32,
    CURLOPT_TIMECONDITION = 33,
    CURLOPT_TIMEVALUE = 34,
    CURLOPT_CUSTOMREQUEST = 10036,
    CURLOPT_STDERR = 10037,
    CURLOPT_POSTQUOTE = 10039,
    CURLOPT_OBSOLETE40 = 10040,
    CURLOPT_VERBOSE = 41,
    CURLOPT_HEADER = 42,
    CURLOPT_NOPROGRESS = 43,
    CURLOPT_NOBODY = 44,
    CURLOPT_FAILONERROR = 45,
    CURLOPT_UPLOAD = 46,
    CURLOPT_POST = 47,
    CURLOPT_DIRLISTONLY = 48,
    CURLOPT_APPEND = 50,
    CURLOPT_NETRC = 51,
    CURLOPT_FOLLOWLOCATION = 52,
    CURLOPT_TRANSFERTEXT = 53,
    CURLOPT_PUT = 54,
    CURLOPT_PROGRESSFUNCTION = 20056,
    CURLOPT_PROGRESSDATA = 10057,
    CURLOPT_AUTOREFERER = 58,
    CURLOPT_PROXYPORT = 59,
    CURLOPT_POSTFIELDSIZE = 60,
    CURLOPT_HTTPPROXYTUNNEL = 61,
    CURLOPT_INTERFACE = 10062,
    CURLOPT_KRBLEVEL = 10063,
    CURLOPT_SSL_VERIFYPEER = 64,
    CURLOPT_CAINFO = 10065,
    CURLOPT_MAXREDIRS = 68,
    CURLOPT_FILETIME = 69,
    CURLOPT_TELNETOPTIONS = 10070,
    CURLOPT_MAXCONNECTS = 71,
    CURLOPT_OBSOLETE72 = 72,
    CURLOPT_FRESH_CONNECT = 74,
    CURLOPT_FORBID_REUSE = 75,
    CURLOPT_RANDOM_FILE = 10076,
    CURLOPT_EGDSOCKET = 10077,
    CURLOPT_CONNECTTIMEOUT = 78,
    CURLOPT_HEADERFUNCTION = 20079,
    CURLOPT_HTTPGET = 80,
    CURLOPT_SSL_VERIFYHOST = 81,
    CURLOPT_COOKIEJAR = 10082,
    CURLOPT_SSL_CIPHER_LIST = 10083,
    CURLOPT_HTTP_VERSION = 84,
    CURLOPT_FTP_USE_EPSV = 85,
    CURLOPT_SSLCERTTYPE = 10086,
    CURLOPT_SSLKEY = 10087,
    CURLOPT_SSLKEYTYPE = 10088,
    CURLOPT_SSLENGINE = 10089,
    CURLOPT_SSLENGINE_DEFAULT = 90,
    CURLOPT_DNS_USE_GLOBAL_CACHE = 91,
    CURLOPT_DNS_CACHE_TIMEOUT = 92,
    CURLOPT_PREQUOTE = 10093,
    CURLOPT_DEBUGFUNCTION = 20094,
    CURLOPT_DEBUGDATA = 10095,
    CURLOPT_COOKIESESSION = 96,
    CURLOPT_CAPATH = 10097,
    CURLOPT_BUFFERSIZE = 98,
    CURLOPT_NOSIGNAL = 99,
    CURLOPT_SHARE = 10100,
    CURLOPT_PROXYTYPE = 101,
    CURLOPT_ACCEPT_ENCODING = 10102,
    CURLOPT_PRIVATE = 10103,
    CURLOPT_HTTP200ALIASES = 10104,
    CURLOPT_UNRESTRICTED_AUTH = 105,
    CURLOPT_FTP_USE_EPRT = 106,
    CURLOPT_HTTPAUTH = 107,
    CURLOPT_SSL_CTX_FUNCTION = 20108,
    CURLOPT_SSL_CTX_DATA = 10109,
    CURLOPT_FTP_CREATE_MISSING_DIRS = 110,
    CURLOPT_PROXYAUTH = 111,
    CURLOPT_FTP_RESPONSE_TIMEOUT = 112,
    CURLOPT_IPRESOLVE = 113,
    CURLOPT_MAXFILESIZE = 114,
    CURLOPT_INFILESIZE_LARGE = 30115,
    CURLOPT_RESUME_FROM_LARGE = 30116,
    CURLOPT_MAXFILESIZE_LARGE = 30117,
    CURLOPT_NETRC_FILE = 10118,
    CURLOPT_USE_SSL = 119,
    CURLOPT_POSTFIELDSIZE_LARGE = 30120,
    CURLOPT_TCP_NODELAY = 121,
    CURLOPT_FTPSSLAUTH = 129,
    CURLOPT_IOCTLFUNCTION = 20130,
    CURLOPT_IOCTLDATA = 10131,
    CURLOPT_FTP_ACCOUNT = 10134,
    CURLOPT_COOKIELIST = 10135,
    CURLOPT_IGNORE_CONTENT_LENGTH = 136,
    CURLOPT_FTP_SKIP_PASV_IP = 137,
    CURLOPT_FTP_FILEMETHOD = 138,
    CURLOPT_LOCALPORT = 139,
    CURLOPT_LOCALPORTRANGE = 140,
    CURLOPT_CONNECT_ONLY = 141,
    CURLOPT_CONV_FROM_NETWORK_FUNCTION = 20142,
    CURLOPT_CONV_TO_NETWORK_FUNCTION = 20143,
    CURLOPT_CONV_FROM_UTF8_FUNCTION = 20144,
    CURLOPT_MAX_SEND_SPEED_LARGE = 30145,
    CURLOPT_MAX_RECV_SPEED_LARGE = 30146,
    CURLOPT_FTP_ALTERNATIVE_TO_USER = 10147,
    CURLOPT_SOCKOPTFUNCTION = 20148,
    CURLOPT_SOCKOPTDATA = 10149,
    CURLOPT_SSL_SESSIONID_CACHE = 150,
    CURLOPT_SSH_AUTH_TYPES = 151,
    CURLOPT_SSH_PUBLIC_KEYFILE = 10152,
    CURLOPT_SSH_PRIVATE_KEYFILE = 10153,
    CURLOPT_FTP_SSL_CCC = 154,
    CURLOPT_TIMEOUT_MS = 155,
    CURLOPT_CONNECTTIMEOUT_MS = 156,
    CURLOPT_HTTP_TRANSFER_DECODING = 157,
    CURLOPT_HTTP_CONTENT_DECODING = 158,
    CURLOPT_NEW_FILE_PERMS = 159,
    CURLOPT_NEW_DIRECTORY_PERMS = 160,
    CURLOPT_POSTREDIR = 161,
    CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 = 10162,
    CURLOPT_OPENSOCKETFUNCTION = 20163,
    CURLOPT_OPENSOCKETDATA = 10164,
    CURLOPT_COPYPOSTFIELDS = 10165,
    CURLOPT_PROXY_TRANSFER_MODE = 166,
    CURLOPT_SEEKFUNCTION = 20167,
    CURLOPT_SEEKDATA = 10168,
    CURLOPT_CRLFILE = 10169,
    CURLOPT_ISSUERCERT = 10170,
    CURLOPT_ADDRESS_SCOPE = 171,
    CURLOPT_CERTINFO = 172,
    CURLOPT_USERNAME = 10173,
    CURLOPT_PASSWORD = 10174,
    CURLOPT_PROXYUSERNAME = 10175,
    CURLOPT_PROXYPASSWORD = 10176,
    CURLOPT_NOPROXY = 10177,
    CURLOPT_TFTP_BLKSIZE = 178,
    CURLOPT_SOCKS5_GSSAPI_SERVICE = 10179,
    CURLOPT_SOCKS5_GSSAPI_NEC = 180,
    CURLOPT_PROTOCOLS = 181,
    CURLOPT_REDIR_PROTOCOLS = 182,
    CURLOPT_SSH_KNOWNHOSTS = 10183,
    CURLOPT_SSH_KEYFUNCTION = 20184,
    CURLOPT_SSH_KEYDATA = 10185,
    CURLOPT_MAIL_FROM = 10186,
    CURLOPT_MAIL_RCPT = 10187,
    CURLOPT_FTP_USE_PRET = 188,
    CURLOPT_RTSP_REQUEST = 189,
    CURLOPT_RTSP_SESSION_ID = 10190,
    CURLOPT_RTSP_STREAM_URI = 10191,
    CURLOPT_RTSP_TRANSPORT = 10192,
    CURLOPT_RTSP_CLIENT_CSEQ = 193,
    CURLOPT_RTSP_SERVER_CSEQ = 194,
    CURLOPT_INTERLEAVEDATA = 10195,
    CURLOPT_INTERLEAVEFUNCTION = 20196,
    CURLOPT_WILDCARDMATCH = 197,
    CURLOPT_CHUNK_BGN_FUNCTION = 20198,
    CURLOPT_CHUNK_END_FUNCTION = 20199,
    CURLOPT_FNMATCH_FUNCTION = 20200,
    CURLOPT_CHUNK_DATA = 10201,
    CURLOPT_FNMATCH_DATA = 10202,
    CURLOPT_RESOLVE = 10203,
    CURLOPT_TLSAUTH_USERNAME = 10204,
    CURLOPT_TLSAUTH_PASSWORD = 10205,
    CURLOPT_TLSAUTH_TYPE = 10206,
    CURLOPT_TRANSFER_ENCODING = 207,
    CURLOPT_CLOSESOCKETFUNCTION = 20208,
    CURLOPT_CLOSESOCKETDATA = 10209,
    CURLOPT_GSSAPI_DELEGATION = 210,
    CURLOPT_DNS_SERVERS = 10211,
    CURLOPT_ACCEPTTIMEOUT_MS = 212,
    CURLOPT_TCP_KEEPALIVE = 213,
    CURLOPT_TCP_KEEPIDLE = 214,
    CURLOPT_TCP_KEEPINTVL = 215,
    CURLOPT_SSL_OPTIONS = 216,
    CURLOPT_MAIL_AUTH = 10217,
    CURLOPT_SASL_IR = 218,
    CURLOPT_XFERINFOFUNCTION = 20219,
    CURLOPT_XOAUTH2_BEARER = 10220,
    CURLOPT_DNS_INTERFACE = 10221,
    CURLOPT_DNS_LOCAL_IP4 = 10222,
    CURLOPT_DNS_LOCAL_IP6 = 10223,
    CURLOPT_LOGIN_OPTIONS = 10224,
    CURLOPT_SSL_ENABLE_NPN = 225,
    CURLOPT_SSL_ENABLE_ALPN = 226,
    CURLOPT_EXPECT_100_TIMEOUT_MS = 227,
    CURLOPT_PROXYHEADER = 10228,
    CURLOPT_HEADEROPT = 229,
    CURLOPT_PINNEDPUBLICKEY = 10230,
    CURLOPT_UNIX_SOCKET_PATH = 10231,
    CURLOPT_SSL_VERIFYSTATUS = 232,
    CURLOPT_SSL_FALSESTART = 233,
    CURLOPT_PATH_AS_IS = 234,
    CURLOPT_PROXY_SERVICE_NAME = 10235,
    CURLOPT_SERVICE_NAME = 10236,
    CURLOPT_PIPEWAIT = 237,
    CURLOPT_LASTENTRY = 238,
}
pub type CURLoption = Enum_Unnamed229;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed230 {
    CURL_HTTP_VERSION_NONE = 0,
    CURL_HTTP_VERSION_1_0 = 1,
    CURL_HTTP_VERSION_1_1 = 2,
    CURL_HTTP_VERSION_2_0 = 3,
    CURL_HTTP_VERSION_LAST = 4,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed231 {
    CURL_RTSPREQ_NONE = 0,
    CURL_RTSPREQ_OPTIONS = 1,
    CURL_RTSPREQ_DESCRIBE = 2,
    CURL_RTSPREQ_ANNOUNCE = 3,
    CURL_RTSPREQ_SETUP = 4,
    CURL_RTSPREQ_PLAY = 5,
    CURL_RTSPREQ_PAUSE = 6,
    CURL_RTSPREQ_TEARDOWN = 7,
    CURL_RTSPREQ_GET_PARAMETER = 8,
    CURL_RTSPREQ_SET_PARAMETER = 9,
    CURL_RTSPREQ_RECORD = 10,
    CURL_RTSPREQ_RECEIVE = 11,
    CURL_RTSPREQ_LAST = 12,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_CURL_NETRC_OPTION {
    CURL_NETRC_IGNORED = 0,
    CURL_NETRC_OPTIONAL = 1,
    CURL_NETRC_REQUIRED = 2,
    CURL_NETRC_LAST = 3,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed232 {
    CURL_SSLVERSION_DEFAULT = 0,
    CURL_SSLVERSION_TLSv1 = 1,
    CURL_SSLVERSION_SSLv2 = 2,
    CURL_SSLVERSION_SSLv3 = 3,
    CURL_SSLVERSION_TLSv1_0 = 4,
    CURL_SSLVERSION_TLSv1_1 = 5,
    CURL_SSLVERSION_TLSv1_2 = 6,
    CURL_SSLVERSION_LAST = 7,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_CURL_TLSAUTH {
    CURL_TLSAUTH_NONE = 0,
    CURL_TLSAUTH_SRP = 1,
    CURL_TLSAUTH_LAST = 2,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed233 {
    CURL_TIMECOND_NONE = 0,
    CURL_TIMECOND_IFMODSINCE = 1,
    CURL_TIMECOND_IFUNMODSINCE = 2,
    CURL_TIMECOND_LASTMOD = 3,
    CURL_TIMECOND_LAST = 4,
}
pub type curl_TimeCond = Enum_Unnamed233;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed234 {
    CURLFORM_NOTHING = 0,
    CURLFORM_COPYNAME = 1,
    CURLFORM_PTRNAME = 2,
    CURLFORM_NAMELENGTH = 3,
    CURLFORM_COPYCONTENTS = 4,
    CURLFORM_PTRCONTENTS = 5,
    CURLFORM_CONTENTSLENGTH = 6,
    CURLFORM_FILECONTENT = 7,
    CURLFORM_ARRAY = 8,
    CURLFORM_OBSOLETE = 9,
    CURLFORM_FILE = 10,
    CURLFORM_BUFFER = 11,
    CURLFORM_BUFFERPTR = 12,
    CURLFORM_BUFFERLENGTH = 13,
    CURLFORM_CONTENTTYPE = 14,
    CURLFORM_CONTENTHEADER = 15,
    CURLFORM_FILENAME = 16,
    CURLFORM_END = 17,
    CURLFORM_OBSOLETE2 = 18,
    CURLFORM_STREAM = 19,
    CURLFORM_LASTENTRY = 20,
}
pub type CURLformoption = Enum_Unnamed234;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_curl_forms {
    pub option: CURLformoption,
    pub value: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_curl_forms {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_curl_forms {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed235 {
    CURL_FORMADD_OK = 0,
    CURL_FORMADD_MEMORY = 1,
    CURL_FORMADD_OPTION_TWICE = 2,
    CURL_FORMADD_NULL = 3,
    CURL_FORMADD_UNKNOWN_OPTION = 4,
    CURL_FORMADD_INCOMPLETE = 5,
    CURL_FORMADD_ILLEGAL_ARRAY = 6,
    CURL_FORMADD_DISABLED = 7,
    CURL_FORMADD_LAST = 8,
}
pub type CURLFORMcode = Enum_Unnamed235;
pub type curl_formget_callback =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void,
                                               buf:
                                                   *const ::std::os::raw::c_char,
                                               len: size_t) -> size_t>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_curl_slist {
    pub data: *mut ::std::os::raw::c_char,
    pub next: *mut Struct_curl_slist,
}
impl ::std::clone::Clone for Struct_curl_slist {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_curl_slist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_curl_certinfo {
    pub num_of_certs: ::std::os::raw::c_int,
    pub certinfo: *mut *mut Struct_curl_slist,
}
impl ::std::clone::Clone for Struct_curl_certinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_curl_certinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed236 {
    CURLSSLBACKEND_NONE = 0,
    CURLSSLBACKEND_OPENSSL = 1,
    CURLSSLBACKEND_GNUTLS = 2,
    CURLSSLBACKEND_NSS = 3,
    CURLSSLBACKEND_OBSOLETE4 = 4,
    CURLSSLBACKEND_GSKIT = 5,
    CURLSSLBACKEND_POLARSSL = 6,
    CURLSSLBACKEND_CYASSL = 7,
    CURLSSLBACKEND_SCHANNEL = 8,
    CURLSSLBACKEND_DARWINSSL = 9,
    CURLSSLBACKEND_AXTLS = 10,
}
pub type curl_sslbackend = Enum_Unnamed236;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_curl_tlssessioninfo {
    pub backend: curl_sslbackend,
    pub internals: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_curl_tlssessioninfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_curl_tlssessioninfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed237 {
    CURLINFO_NONE = 0,
    CURLINFO_EFFECTIVE_URL = 1048577,
    CURLINFO_RESPONSE_CODE = 2097154,
    CURLINFO_TOTAL_TIME = 3145731,
    CURLINFO_NAMELOOKUP_TIME = 3145732,
    CURLINFO_CONNECT_TIME = 3145733,
    CURLINFO_PRETRANSFER_TIME = 3145734,
    CURLINFO_SIZE_UPLOAD = 3145735,
    CURLINFO_SIZE_DOWNLOAD = 3145736,
    CURLINFO_SPEED_DOWNLOAD = 3145737,
    CURLINFO_SPEED_UPLOAD = 3145738,
    CURLINFO_HEADER_SIZE = 2097163,
    CURLINFO_REQUEST_SIZE = 2097164,
    CURLINFO_SSL_VERIFYRESULT = 2097165,
    CURLINFO_FILETIME = 2097166,
    CURLINFO_CONTENT_LENGTH_DOWNLOAD = 3145743,
    CURLINFO_CONTENT_LENGTH_UPLOAD = 3145744,
    CURLINFO_STARTTRANSFER_TIME = 3145745,
    CURLINFO_CONTENT_TYPE = 1048594,
    CURLINFO_REDIRECT_TIME = 3145747,
    CURLINFO_REDIRECT_COUNT = 2097172,
    CURLINFO_PRIVATE = 1048597,
    CURLINFO_HTTP_CONNECTCODE = 2097174,
    CURLINFO_HTTPAUTH_AVAIL = 2097175,
    CURLINFO_PROXYAUTH_AVAIL = 2097176,
    CURLINFO_OS_ERRNO = 2097177,
    CURLINFO_NUM_CONNECTS = 2097178,
    CURLINFO_SSL_ENGINES = 4194331,
    CURLINFO_COOKIELIST = 4194332,
    CURLINFO_LASTSOCKET = 2097181,
    CURLINFO_FTP_ENTRY_PATH = 1048606,
    CURLINFO_REDIRECT_URL = 1048607,
    CURLINFO_PRIMARY_IP = 1048608,
    CURLINFO_APPCONNECT_TIME = 3145761,
    CURLINFO_CERTINFO = 4194338,
    CURLINFO_CONDITION_UNMET = 2097187,
    CURLINFO_RTSP_SESSION_ID = 1048612,
    CURLINFO_RTSP_CLIENT_CSEQ = 2097189,
    CURLINFO_RTSP_SERVER_CSEQ = 2097190,
    CURLINFO_RTSP_CSEQ_RECV = 2097191,
    CURLINFO_PRIMARY_PORT = 2097192,
    CURLINFO_LOCAL_IP = 1048617,
    CURLINFO_LOCAL_PORT = 2097194,
    CURLINFO_TLS_SESSION = 4194347,
    CURLINFO_LASTONE = 43,
}
pub type CURLINFO = Enum_Unnamed237;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed238 {
    CURLCLOSEPOLICY_NONE = 0,
    CURLCLOSEPOLICY_OLDEST = 1,
    CURLCLOSEPOLICY_LEAST_RECENTLY_USED = 2,
    CURLCLOSEPOLICY_LEAST_TRAFFIC = 3,
    CURLCLOSEPOLICY_SLOWEST = 4,
    CURLCLOSEPOLICY_CALLBACK = 5,
    CURLCLOSEPOLICY_LAST = 6,
}
pub type curl_closepolicy = Enum_Unnamed238;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed239 {
    CURL_LOCK_DATA_NONE = 0,
    CURL_LOCK_DATA_SHARE = 1,
    CURL_LOCK_DATA_COOKIE = 2,
    CURL_LOCK_DATA_DNS = 3,
    CURL_LOCK_DATA_SSL_SESSION = 4,
    CURL_LOCK_DATA_CONNECT = 5,
    CURL_LOCK_DATA_LAST = 6,
}
pub type curl_lock_data = Enum_Unnamed239;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed240 {
    CURL_LOCK_ACCESS_NONE = 0,
    CURL_LOCK_ACCESS_SHARED = 1,
    CURL_LOCK_ACCESS_SINGLE = 2,
    CURL_LOCK_ACCESS_LAST = 3,
}
pub type curl_lock_access = Enum_Unnamed240;
pub type curl_lock_function =
    ::std::option::Option<unsafe extern "C" fn(handle: *mut CURL,
                                               data: curl_lock_data,
                                               locktype: curl_lock_access,
                                               userptr:
                                                   *mut ::std::os::raw::c_void)>;
pub type curl_unlock_function =
    ::std::option::Option<unsafe extern "C" fn(handle: *mut CURL,
                                               data: curl_lock_data,
                                               userptr:
                                                   *mut ::std::os::raw::c_void)>;
pub type CURLSH = ::std::os::raw::c_void;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed241 {
    CURLSHE_OK = 0,
    CURLSHE_BAD_OPTION = 1,
    CURLSHE_IN_USE = 2,
    CURLSHE_INVALID = 3,
    CURLSHE_NOMEM = 4,
    CURLSHE_NOT_BUILT_IN = 5,
    CURLSHE_LAST = 6,
}
pub type CURLSHcode = Enum_Unnamed241;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed242 {
    CURLSHOPT_NONE = 0,
    CURLSHOPT_SHARE = 1,
    CURLSHOPT_UNSHARE = 2,
    CURLSHOPT_LOCKFUNC = 3,
    CURLSHOPT_UNLOCKFUNC = 4,
    CURLSHOPT_USERDATA = 5,
    CURLSHOPT_LAST = 6,
}
pub type CURLSHoption = Enum_Unnamed242;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed243 {
    CURLVERSION_FIRST = 0,
    CURLVERSION_SECOND = 1,
    CURLVERSION_THIRD = 2,
    CURLVERSION_FOURTH = 3,
    CURLVERSION_LAST = 4,
}
pub type CURLversion = Enum_Unnamed243;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed244 {
    pub age: CURLversion,
    pub version: *const ::std::os::raw::c_char,
    pub version_num: ::std::os::raw::c_uint,
    pub host: *const ::std::os::raw::c_char,
    pub features: ::std::os::raw::c_int,
    pub ssl_version: *const ::std::os::raw::c_char,
    pub ssl_version_num: ::std::os::raw::c_long,
    pub libz_version: *const ::std::os::raw::c_char,
    pub protocols: *const *const ::std::os::raw::c_char,
    pub ares: *const ::std::os::raw::c_char,
    pub ares_num: ::std::os::raw::c_int,
    pub libidn: *const ::std::os::raw::c_char,
    pub iconv_ver_num: ::std::os::raw::c_int,
    pub libssh_version: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed244 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed244 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type curl_version_info_data = Struct_Unnamed244;
pub type CURLM = ::std::os::raw::c_void;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed245 {
    CURLM_CALL_MULTI_PERFORM = -1,
    CURLM_OK = 0,
    CURLM_BAD_HANDLE = 1,
    CURLM_BAD_EASY_HANDLE = 2,
    CURLM_OUT_OF_MEMORY = 3,
    CURLM_INTERNAL_ERROR = 4,
    CURLM_BAD_SOCKET = 5,
    CURLM_UNKNOWN_OPTION = 6,
    CURLM_ADDED_ALREADY = 7,
    CURLM_LAST = 8,
}
pub type CURLMcode = Enum_Unnamed245;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed246 {
    CURLMSG_NONE = 0,
    CURLMSG_DONE = 1,
    CURLMSG_LAST = 2,
}
pub type CURLMSG = Enum_Unnamed246;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CURLMsg {
    pub msg: CURLMSG,
    pub easy_handle: *mut CURL,
    pub data: Union_Unnamed247,
}
impl ::std::clone::Clone for Struct_CURLMsg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CURLMsg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed247 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed247 {
    pub unsafe fn whatever(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn result(&mut self) -> *mut CURLcode {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed247 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed247 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CURLMsg = Struct_CURLMsg;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_curl_waitfd {
    pub fd: curl_socket_t,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
impl ::std::clone::Clone for Struct_curl_waitfd {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_curl_waitfd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type curl_socket_callback =
    ::std::option::Option<unsafe extern "C" fn(easy: *mut CURL,
                                               s: curl_socket_t,
                                               what: ::std::os::raw::c_int,
                                               userp:
                                                   *mut ::std::os::raw::c_void,
                                               socketp:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type curl_multi_timer_callback =
    ::std::option::Option<unsafe extern "C" fn(multi: *mut CURLM,
                                               timeout_ms:
                                                   ::std::os::raw::c_long,
                                               userp:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed248 {
    CURLMOPT_SOCKETFUNCTION = 20001,
    CURLMOPT_SOCKETDATA = 10002,
    CURLMOPT_PIPELINING = 3,
    CURLMOPT_TIMERFUNCTION = 20004,
    CURLMOPT_TIMERDATA = 10005,
    CURLMOPT_MAXCONNECTS = 6,
    CURLMOPT_MAX_HOST_CONNECTIONS = 7,
    CURLMOPT_MAX_PIPELINE_LENGTH = 8,
    CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE = 30009,
    CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE = 30010,
    CURLMOPT_PIPELINING_SITE_BL = 10011,
    CURLMOPT_PIPELINING_SERVER_BL = 10012,
    CURLMOPT_MAX_TOTAL_CONNECTIONS = 13,
    CURLMOPT_LASTENTRY = 14,
}
pub type CURLMoption = Enum_Unnamed248;
#[repr(C)]
#[derive(Copy)]
pub struct Union_wait {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_wait {
    pub unsafe fn w_status(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wait_terminated(&mut self) -> *mut Struct_Unnamed249 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wait_stopped(&mut self) -> *mut Struct_Unnamed250 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_wait {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_wait {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed249 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed249 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed249 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed250 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed250 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed250 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed251 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed251 {
    pub unsafe fn __uptr(&mut self) -> *mut *mut Union_wait {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __iptr(&mut self) -> *mut *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed251 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed251 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __WAIT_STATUS = Union_Unnamed251;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed252 {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed252 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed252 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type div_t = Struct_Unnamed252;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed253 {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
impl ::std::clone::Clone for Struct_Unnamed253 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed253 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ldiv_t = Struct_Unnamed253;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed254 {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
impl ::std::clone::Clone for Struct_Unnamed254 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed254 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type lldiv_t = Struct_Unnamed254;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_random_data {
    pub fptr: *mut int32_t,
    pub rptr: *mut int32_t,
    pub state: *mut int32_t,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut int32_t,
}
impl ::std::clone::Clone for Struct_random_data {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_random_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
impl ::std::clone::Clone for Struct_drand48_data {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_drand48_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed255 {
    pub var: *mut ::std::os::raw::c_char,
    pub val: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed255 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed255 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrVar = Struct_Unnamed255;
pub type LrUrlVars = GSList;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed256 {
    pub urls: *mut GSList,
}
impl ::std::clone::Clone for Struct_Unnamed256 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed256 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrMirrorlist = Struct_Unnamed256;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed257 {
    LR_XML_WARNING_UNKNOWNTAG = 0,
    LR_XML_WARNING_MISSINGATTR = 1,
    LR_XML_WARNING_UNKNOWNVAL = 2,
    LR_XML_WARNING_BADATTRVAL = 3,
    LR_XML_WARNING_MISSINGVAL = 4,
    LR_XML_WARNING_SENTINEL = 5,
}
pub type LrXmlParserWarningType = Enum_Unnamed257;
pub type LrXmlParserWarningCb =
    ::std::option::Option<unsafe extern "C" fn(_type: LrXmlParserWarningType,
                                               msg:
                                                   *mut ::std::os::raw::c_char,
                                               cbdata:
                                                   *mut ::std::os::raw::c_void,
                                               err: *mut *mut GError)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed258 {
    pub _type: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed258 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed258 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrMetalinkHash = Struct_Unnamed258;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed259 {
    pub protocol: *mut ::std::os::raw::c_char,
    pub _type: *mut ::std::os::raw::c_char,
    pub location: *mut ::std::os::raw::c_char,
    pub preference: ::std::os::raw::c_int,
    pub url: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed259 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed259 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrMetalinkUrl = Struct_Unnamed259;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed260 {
    pub timestamp: gint64,
    pub size: gint64,
    pub hashes: *mut GSList,
}
impl ::std::clone::Clone for Struct_Unnamed260 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed260 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrMetalinkAlternate = Struct_Unnamed260;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed261 {
    pub filename: *mut ::std::os::raw::c_char,
    pub timestamp: gint64,
    pub size: gint64,
    pub hashes: *mut GSList,
    pub urls: *mut GSList,
    pub alternates: *mut GSList,
}
impl ::std::clone::Clone for Struct_Unnamed261 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed261 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrMetalink = Struct_Unnamed261;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed262 { LR_CHECK_GPG = 1, LR_CHECK_CHECKSUM = 2, }
pub type LrChecks = Enum_Unnamed262;
pub const LR_RPMMDREPO: Enum_Unnamed263 = Enum_Unnamed263::LR_YUMREPO;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed263 { LR_YUMREPO = 2, LR_SUSEREPO = 4, LR_DEBREPO = 8, }
pub type LrRepotype = Enum_Unnamed263;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed264 {
    LR_PROXY_HTTP = 0,
    LR_PROXY_HTTP_1_0 = 1,
    LR_PROXY_SOCKS4 = 2,
    LR_PROXY_SOCKS5 = 3,
    LR_PROXY_SOCKS4A = 4,
    LR_PROXY_SOCKS5_HOSTNAME = 5,
}
pub type LrProxyType = Enum_Unnamed264;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed265 {
    LR_IPRESOLVE_WHATEVER = 0,
    LR_IPRESOLVE_V4 = 1,
    LR_IPRESOLVE_V6 = 2,
}
pub type LrIpResolveType = Enum_Unnamed265;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_LrCbReturnCode_e {
    LR_CB_OK = 0,
    LR_CB_ABORT = 1,
    LR_CB_ERROR = 2,
}
pub type LrCbReturnCode = Enum_LrCbReturnCode_e;
pub type LrProgressCb =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               total_to_download:
                                                   ::std::os::raw::c_double,
                                               now_downloaded:
                                                   ::std::os::raw::c_double)
                              -> ::std::os::raw::c_int>;
pub const LR_TRANSFER_ALREDYEXISTS: Enum_Unnamed266 =
    Enum_Unnamed266::LR_TRANSFER_ALREADYEXISTS;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed266 {
    LR_TRANSFER_SUCCESSFUL = 0,
    LR_TRANSFER_ALREADYEXISTS = 1,
    LR_TRANSFER_ERROR = 2,
}
pub type LrTransferStatus = Enum_Unnamed266;
pub type LrEndCb =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               status: LrTransferStatus,
                                               msg:
                                                   *const ::std::os::raw::c_char)
                              -> ::std::os::raw::c_int>;
pub type LrMirrorFailureCb =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               msg:
                                                   *const ::std::os::raw::c_char,
                                               url:
                                                   *const ::std::os::raw::c_char)
                              -> ::std::os::raw::c_int>;
pub type LrHandleMirrorFailureCb =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               msg:
                                                   *const ::std::os::raw::c_char,
                                               url:
                                                   *const ::std::os::raw::c_char,
                                               metadata:
                                                   *const ::std::os::raw::c_char)
                              -> ::std::os::raw::c_int>;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed267 {
    LR_FMSTAGE_INIT = 0,
    LR_FMSTAGE_CACHELOADING = 1,
    LR_FMSTAGE_CACHELOADINGSTATUS = 2,
    LR_FMSTAGE_DETECTION = 3,
    LR_FMSTAGE_FINISHING = 4,
    LR_FMSTAGE_STATUS = 5,
}
pub type LrFastestMirrorStages = Enum_Unnamed267;
pub type LrFastestMirrorCb =
    ::std::option::Option<unsafe extern "C" fn(clientp:
                                                   *mut ::std::os::raw::c_void,
                                               stage: LrFastestMirrorStages,
                                               ptr:
                                                   *mut ::std::os::raw::c_void)>;
pub enum Struct__LrResult { }
pub type LrResult = Struct__LrResult;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed268 {
    LRR_YUM_REPO = 0,
    LRR_YUM_REPOMD = 1,
    LRR_YUM_TIMESTAMP = 2,
    LRR_RPMMD_REPO = 3,
    LRR_RPMMD_REPOMD = 4,
    LRR_RPMMD_TIMESTAMP = 5,
    LRR_SENTINEL = 6,
}
pub type LrResultInfoOption = Enum_Unnamed268;
pub enum Struct__LrHandle { }
pub type LrHandle = Struct__LrHandle;
pub const LRO_RPMMDDLIST: Enum_Unnamed269 = Enum_Unnamed269::LRO_YUMDLIST;
pub const LRO_RPMMDBLIST: Enum_Unnamed269 = Enum_Unnamed269::LRO_YUMBLIST;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed269 {
    LRO_UPDATE = 0,
    LRO_URLS = 1,
    LRO_MIRRORLIST = 2,
    LRO_MIRRORLISTURL = 3,
    LRO_METALINKURL = 4,
    LRO_LOCAL = 5,
    LRO_HTTPAUTH = 6,
    LRO_USERPWD = 7,
    LRO_PROXY = 8,
    LRO_PROXYPORT = 9,
    LRO_PROXYTYPE = 10,
    LRO_PROXYAUTH = 11,
    LRO_PROXYUSERPWD = 12,
    LRO_PROGRESSCB = 13,
    LRO_PROGRESSDATA = 14,
    LRO_MAXSPEED = 15,
    LRO_DESTDIR = 16,
    LRO_REPOTYPE = 17,
    LRO_CONNECTTIMEOUT = 18,
    LRO_IGNOREMISSING = 19,
    LRO_INTERRUPTIBLE = 20,
    LRO_USERAGENT = 21,
    LRO_FETCHMIRRORS = 22,
    LRO_MAXMIRRORTRIES = 23,
    LRO_MAXPARALLELDOWNLOADS = 24,
    LRO_MAXDOWNLOADSPERMIRROR = 25,
    LRO_VARSUB = 26,
    LRO_FASTESTMIRROR = 27,
    LRO_FASTESTMIRRORCACHE = 28,
    LRO_FASTESTMIRRORMAXAGE = 29,
    LRO_FASTESTMIRRORCB = 30,
    LRO_FASTESTMIRRORDATA = 31,
    LRO_LOWSPEEDTIME = 32,
    LRO_LOWSPEEDLIMIT = 33,
    LRO_GPGCHECK = 34,
    LRO_CHECKSUM = 35,
    LRO_YUMDLIST = 36,
    LRO_YUMBLIST = 37,
    LRO_HMFCB = 38,
    LRO_SSLVERIFYPEER = 39,
    LRO_SSLVERIFYHOST = 40,
    LRO_IPRESOLVE = 41,
    LRO_ALLOWEDMIRRORFAILURES = 42,
    LRO_ADAPTIVEMIRRORSORTING = 43,
    LRO_GNUPGHOMEDIR = 44,
    LRO_FASTESTMIRRORTIMEOUT = 45,
    LRO_HTTPHEADER = 46,
    LRO_OFFLINE = 47,
    LRO_SSLCLIENTCERT = 48,
    LRO_SSLCLIENTKEY = 49,
    LRO_SSLCACERT = 50,
    LRO_SENTINEL = 51,
}
pub type LrHandleOption = Enum_Unnamed269;
pub const LRI_RPMMDDLIST: Enum_Unnamed270 = Enum_Unnamed270::LRI_YUMDLIST;
pub const LRI_RPMMDBLIST: Enum_Unnamed270 = Enum_Unnamed270::LRI_YUMBLIST;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed270 {
    LRI_UPDATE = 0,
    LRI_URLS = 1,
    LRI_MIRRORLIST = 2,
    LRI_MIRRORLISTURL = 3,
    LRI_METALINKURL = 4,
    LRI_LOCAL = 5,
    LRI_PROGRESSCB = 6,
    LRI_PROGRESSDATA = 7,
    LRI_DESTDIR = 8,
    LRI_REPOTYPE = 9,
    LRI_USERAGENT = 10,
    LRI_YUMDLIST = 11,
    LRI_YUMBLIST = 12,
    LRI_FETCHMIRRORS = 13,
    LRI_MAXMIRRORTRIES = 14,
    LRI_VARSUB = 15,
    LRI_MIRRORS = 16,
    LRI_METALINK = 17,
    LRI_FASTESTMIRROR = 18,
    LRI_FASTESTMIRRORCACHE = 19,
    LRI_FASTESTMIRRORMAXAGE = 20,
    LRI_HMFCB = 21,
    LRI_SSLVERIFYPEER = 22,
    LRI_SSLVERIFYHOST = 23,
    LRI_IPRESOLVE = 24,
    LRI_ALLOWEDMIRRORFAILURES = 25,
    LRI_ADAPTIVEMIRRORSORTING = 26,
    LRI_GNUPGHOMEDIR = 27,
    LRI_FASTESTMIRRORTIMEOUT = 28,
    LRI_HTTPHEADER = 29,
    LRI_OFFLINE = 30,
    LRI_SSLCLIENTCERT = 31,
    LRI_SSLCLIENTKEY = 32,
    LRI_SSLCACERT = 33,
    LRI_LOWSPEEDTIME = 34,
    LRI_LOWSPEEDLIMIT = 35,
    LRI_SENTINEL = 36,
}
pub type LrHandleInfoOption = Enum_Unnamed270;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed271 {
    pub url: *mut gchar,
    pub curl: *mut CURL,
    pub plain_connect_time: ::std::os::raw::c_double,
    pub cached: gboolean,
}
impl ::std::clone::Clone for Struct_Unnamed271 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed271 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrFastestMirror = Struct_Unnamed271;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed272 {
    LRE_OK = 0,
    LRE_BADFUNCARG = 1,
    LRE_BADOPTARG = 2,
    LRE_UNKNOWNOPT = 3,
    LRE_CURLSETOPT = 4,
    LRE_ALREADYUSEDRESULT = 5,
    LRE_INCOMPLETERESULT = 6,
    LRE_CURLDUP = 7,
    LRE_CURL = 8,
    LRE_CURLM = 9,
    LRE_BADSTATUS = 10,
    LRE_TEMPORARYERR = 11,
    LRE_NOTLOCAL = 12,
    LRE_CANNOTCREATEDIR = 13,
    LRE_IO = 14,
    LRE_MLBAD = 15,
    LRE_MLXML = 16,
    LRE_BADCHECKSUM = 17,
    LRE_REPOMDXML = 18,
    LRE_NOURL = 19,
    LRE_CANNOTCREATETMP = 20,
    LRE_UNKNOWNCHECKSUM = 21,
    LRE_BADURL = 22,
    LRE_GPGNOTSUPPORTED = 23,
    LRE_GPGERROR = 24,
    LRE_BADGPG = 25,
    LRE_INCOMPLETEREPO = 26,
    LRE_INTERRUPTED = 27,
    LRE_SIGACTION = 28,
    LRE_ALREADYDOWNLOADED = 29,
    LRE_UNFINISHED = 30,
    LRE_SELECT = 31,
    LRE_OPENSSL = 32,
    LRE_MEMORY = 33,
    LRE_XMLPARSER = 34,
    LRE_CBINTERRUPTED = 35,
    LRE_REPOMD = 36,
    LRE_VALUE = 37,
    LRE_NOTSET = 38,
    LRE_FILE = 39,
    LRE_KEYFILE = 40,
    LRE_UNKNOWNERROR = 41,
}
pub type LrRc = Enum_Unnamed272;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed273 {
    pub handle: *mut LrHandle,
    pub relative_url: *mut ::std::os::raw::c_char,
    pub dest: *mut ::std::os::raw::c_char,
    pub base_url: *mut ::std::os::raw::c_char,
    pub checksum_type: LrChecksumType,
    pub checksum: *mut ::std::os::raw::c_char,
    pub expectedsize: gint64,
    pub resume: gboolean,
    pub progresscb: LrProgressCb,
    pub cbdata: *mut ::std::os::raw::c_void,
    pub endcb: LrEndCb,
    pub mirrorfailurecb: LrMirrorFailureCb,
    pub byterangestart: gint64,
    pub byterangeend: gint64,
    pub local_path: *mut ::std::os::raw::c_char,
    pub err: *mut ::std::os::raw::c_char,
    pub chunk: *mut GStringChunk,
}
impl ::std::clone::Clone for Struct_Unnamed273 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed273 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrPackageTarget = Struct_Unnamed273;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed274 { LR_PACKAGEDOWNLOAD_FAILFAST = 1, }
pub type LrPackageDownloadFlag = Enum_Unnamed274;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed275 { LR_PACKAGECHECK_FAILFAST = 1, }
pub type LrPackageCheckFlag = Enum_Unnamed275;
pub enum Struct__LrYumRepoConf { }
pub type LrYumRepoConf = Struct__LrYumRepoConf;
pub enum Struct__LrYumRepoConfs { }
pub type LrYumRepoConfs = Struct__LrYumRepoConfs;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed276 {
    LR_YRC_ID = 0,
    LR_YRC_NAME = 1,
    LR_YRC_ENABLED = 2,
    LR_YRC_BASEURL = 3,
    LR_YRC_MIRRORLIST = 4,
    LR_YRC_METALINK = 5,
    LR_YRC_MEDIAID = 6,
    LR_YRC_GPGKEY = 7,
    LR_YRC_GPGCAKEY = 8,
    LR_YRC_EXCLUDE = 9,
    LR_YRC_INCLUDE = 10,
    LR_YRC_FASTESTMIRROR = 11,
    LR_YRC_PROXY = 12,
    LR_YRC_PROXY_USERNAME = 13,
    LR_YRC_PROXY_PASSWORD = 14,
    LR_YRC_USERNAME = 15,
    LR_YRC_PASSWORD = 16,
    LR_YRC_GPGCHECK = 17,
    LR_YRC_REPO_GPGCHECK = 18,
    LR_YRC_ENABLEGROUPS = 19,
    LR_YRC_BANDWIDTH = 20,
    LR_YRC_THROTTLE = 21,
    LR_YRC_IP_RESOLVE = 22,
    LR_YRC_METADATA_EXPIRE = 23,
    LR_YRC_COST = 24,
    LR_YRC_PRIORITY = 25,
    LR_YRC_SSLCACERT = 26,
    LR_YRC_SSLVERIFY = 27,
    LR_YRC_SSLCLIENTCERT = 28,
    LR_YRC_SSLCLIENTKEY = 29,
    LR_YRC_DELTAREPOBASEURL = 30,
    LR_YRC_FAILOVERMETHOD = 31,
    LR_YRC_SKIP_IF_UNAVAILABLE = 32,
}
pub type LrYumRepoConfOption = Enum_Unnamed276;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed277 {
    pub cpeid: *mut ::std::os::raw::c_char,
    pub tag: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed277 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed277 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrYumDistroTag = Struct_Unnamed277;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed278 {
    pub _type: *mut ::std::os::raw::c_char,
    pub location_href: *mut ::std::os::raw::c_char,
    pub location_base: *mut ::std::os::raw::c_char,
    pub checksum: *mut ::std::os::raw::c_char,
    pub checksum_type: *mut ::std::os::raw::c_char,
    pub checksum_open: *mut ::std::os::raw::c_char,
    pub checksum_open_type: *mut ::std::os::raw::c_char,
    pub timestamp: gint64,
    pub size: gint64,
    pub size_open: gint64,
    pub db_version: ::std::os::raw::c_int,
    pub chunk: *mut GStringChunk,
}
impl ::std::clone::Clone for Struct_Unnamed278 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed278 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrYumRepoMdRecord = Struct_Unnamed278;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed279 {
    pub revision: *mut ::std::os::raw::c_char,
    pub repoid: *mut ::std::os::raw::c_char,
    pub repoid_type: *mut ::std::os::raw::c_char,
    pub repo_tags: *mut GSList,
    pub content_tags: *mut GSList,
    pub distro_tags: *mut GSList,
    pub records: *mut GSList,
    pub chunk: *mut GStringChunk,
}
impl ::std::clone::Clone for Struct_Unnamed279 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed279 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrYumRepoMd = Struct_Unnamed279;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed280 {
    pub _type: *mut ::std::os::raw::c_char,
    pub path: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed280 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed280 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrYumRepoPath = Struct_Unnamed280;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed281 {
    pub paths: *mut GSList,
    pub repomd: *mut ::std::os::raw::c_char,
    pub url: *mut ::std::os::raw::c_char,
    pub destdir: *mut ::std::os::raw::c_char,
    pub signature: *mut ::std::os::raw::c_char,
    pub mirrorlist: *mut ::std::os::raw::c_char,
    pub metalink: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed281 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed281 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrYumRepo = Struct_Unnamed281;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed282 {
    pub _type: LrChecksumType,
    pub value: *mut gchar,
}
impl ::std::clone::Clone for Struct_Unnamed282 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed282 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrDownloadTargetChecksum = Struct_Unnamed282;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed283 {
    pub handle: *mut LrHandle,
    pub path: *mut ::std::os::raw::c_char,
    pub baseurl: *mut ::std::os::raw::c_char,
    pub fd: ::std::os::raw::c_int,
    pub _fn: *mut ::std::os::raw::c_char,
    pub checksums: *mut GSList,
    pub expectedsize: gint64,
    pub resume: gboolean,
    pub progresscb: LrProgressCb,
    pub cbdata: *mut ::std::os::raw::c_void,
    pub endcb: LrEndCb,
    pub mirrorfailurecb: LrMirrorFailureCb,
    pub chunk: *mut GStringChunk,
    pub byterangestart: gint64,
    pub byterangeend: gint64,
    pub usedmirror: *mut ::std::os::raw::c_char,
    pub effectiveurl: *mut ::std::os::raw::c_char,
    pub rcode: LrRc,
    pub err: *mut ::std::os::raw::c_char,
    pub userdata: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_Unnamed283 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed283 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LrDownloadTarget = Struct_Unnamed283;
pub type HifRepoClass = Struct__HifRepoClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifRepo {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifRepo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifRepo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifRepo_autoptr = *mut HifRepo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifRepoClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifRepoClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifRepoClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed284 {
    HIF_REPO_UPDATE_FLAG_NONE = 0,
    HIF_REPO_UPDATE_FLAG_FORCE = 1,
    HIF_REPO_UPDATE_FLAG_IMPORT_PUBKEY = 2,
    HIF_REPO_UPDATE_FLAG_SIMULATE = 4,
    HIF_REPO_UPDATE_FLAG_LAST = 5,
}
pub type HifRepoUpdateFlags = Enum_Unnamed284;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed285 {
    HIF_REPO_KIND_REMOTE = 0,
    HIF_REPO_KIND_MEDIA = 1,
    HIF_REPO_KIND_LOCAL = 2,
    HIF_REPO_KIND_LAST = 3,
}
pub type HifRepoKind = Enum_Unnamed285;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed286 {
    HIF_REPO_ENABLED_NONE = 0,
    HIF_REPO_ENABLED_PACKAGES = 1,
    HIF_REPO_ENABLED_METADATA = 2,
    HIF_REPO_ENABLED_LAST = 3,
}
pub type HifRepoEnabled = Enum_Unnamed286;
pub type HifPackageSetClass = Struct__HifPackageSetClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifPackageSet {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifPackageSet {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifPackageSet {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifPackageSet_autoptr = *mut HifPackageSet;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifPackageSetClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifPackageSetClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifPackageSetClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifSackClass = Struct__HifSackClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifSack {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifSack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifSack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifSack_autoptr = *mut HifSack;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifSackClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifSackClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifSackClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed287 {
    HIF_SACK_SETUP_FLAG_NONE = 0,
    HIF_SACK_SETUP_FLAG_MAKE_CACHE_DIR = 1,
    HIF_SACK_SETUP_FLAG_LAST = 2,
}
pub type HifSackSetupFlags = Enum_Unnamed287;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed288 {
    HIF_SACK_LOAD_FLAG_NONE = 0,
    HIF_SACK_LOAD_FLAG_BUILD_CACHE = 1,
    HIF_SACK_LOAD_FLAG_USE_FILELISTS = 2,
    HIF_SACK_LOAD_FLAG_USE_PRESTO = 4,
    HIF_SACK_LOAD_FLAG_USE_UPDATEINFO = 8,
    HIF_SACK_LOAD_FLAG_LAST = 9,
}
pub type HifSackLoadFlags = Enum_Unnamed288;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed289 {
    HIF_SACK_ADD_FLAG_NONE = 0,
    HIF_SACK_ADD_FLAG_FILELISTS = 1,
    HIF_SACK_ADD_FLAG_UPDATEINFO = 2,
    HIF_SACK_ADD_FLAG_REMOTE = 4,
    HIF_SACK_ADD_FLAG_UNAVAILABLE = 8,
    HIF_SACK_ADD_FLAG_LAST = 9,
}
pub type HifSackAddFlags = Enum_Unnamed289;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum__hy_goal_op_flags {
    HY_CHECK_INSTALLED = 1,
    HY_CLEAN_DEPS = 2,
    HY_WEAK_SOLV = 4,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed290 {
    HIF_ERASE = 1,
    HIF_DISTUPGRADE = 2,
    HIF_DISTUPGRADE_ALL = 4,
    HIF_DOWNGRADE = 8,
    HIF_INSTALL = 16,
    HIF_UPGRADE = 32,
    HIF_UPGRADE_ALL = 64,
    HIF_ALLOW_UNINSTALL = 1024,
    HIF_FORCE_BEST = 2048,
    HIF_VERIFY = 4096,
    HIF_IGNORE_WEAK_DEPS = 8192,
}
pub type HifGoalActions = Enum_Unnamed290;
pub type HifDbClass = Struct__HifDbClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifDb {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifDb {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifDb {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifDb_autoptr = *mut HifDb;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifDbClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifDbClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifDbClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifReposClass = Struct__HifReposClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifRepos {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifRepos {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifRepos {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifRepos_autoptr = *mut HifRepos;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifReposClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<unsafe extern "C" fn(repos:
                                                                *mut HifRepos)>,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifReposClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifReposClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifTransactionClass = Struct__HifTransactionClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifTransaction {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifTransaction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifTransaction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifTransaction_autoptr = *mut HifTransaction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifTransactionClass {
    pub parent_class: GObjectClass,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifTransactionClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifTransactionClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed291 {
    HIF_TRANSACTION_FLAG_NONE = 0,
    HIF_TRANSACTION_FLAG_ONLY_TRUSTED = 1,
    HIF_TRANSACTION_FLAG_ALLOW_REINSTALL = 2,
    HIF_TRANSACTION_FLAG_ALLOW_DOWNGRADE = 4,
    HIF_TRANSACTION_FLAG_NODOCS = 8,
}
pub type HifTransactionFlag = Enum_Unnamed291;
pub type HifContextClass = Struct__HifContextClass;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifContext {
    pub parent_instance: GObject,
}
impl ::std::clone::Clone for Struct__HifContext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifContext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HifContext_autoptr = *mut HifContext;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HifContextClass {
    pub parent_class: GObjectClass,
    pub invalidate: ::std::option::Option<unsafe extern "C" fn(context:
                                                                   *mut HifContext,
                                                               message:
                                                                   *const gchar)>,
    pub _hif_reserved1: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved2: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved3: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved4: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved5: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved6: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved7: ::std::option::Option<extern "C" fn()>,
    pub _hif_reserved8: ::std::option::Option<extern "C" fn()>,
}
impl ::std::clone::Clone for Struct__HifContextClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HifContextClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed292 {
    HIF_CONTEXT_INVALIDATE_FLAG_NONE = 0,
    HIF_CONTEXT_INVALIDATE_FLAG_RPMDB = 1,
    HIF_CONTEXT_INVALIDATE_FLAG_ENROLLMENT = 2,
    HIF_CONTEXT_INVALIDATE_FLAG_LAST = 3,
}
pub type HifContextInvalidateFlags = Enum_Unnamed292;
pub type uint8_t = ::std::os::raw::c_uchar;
pub type uint16_t = ::std::os::raw::c_ushort;
pub type uint32_t = ::std::os::raw::c_uint;
pub type uint64_t = ::std::os::raw::c_ulong;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type uintptr_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type errmsg_t = *const ::std::os::raw::c_char;
pub enum Struct_headerToken_s { }
pub type Header = *mut Struct_headerToken_s;
pub enum Struct_headerIterator_s { }
pub type HeaderIterator = *mut Struct_headerIterator_s;
pub type rpm_tag_t = int32_t;
pub type rpm_tagtype_t = uint32_t;
pub type rpm_count_t = uint32_t;
pub type rpmTagVal = rpm_tag_t;
pub type rpmDbiTagVal = rpm_tag_t;
pub type rpm_data_t = *mut ::std::os::raw::c_void;
pub type rpm_constdata_t = *const ::std::os::raw::c_void;
pub enum Struct_rpmtd_s { }
pub type rpmtd = *mut Struct_rpmtd_s;
pub type rpm_color_t = uint32_t;
pub type rpm_flag_t = uint32_t;
pub type rpm_tid_t = uint32_t;
pub type rpmFlags = uint32_t;
pub type rpm_off_t = uint32_t;
pub type rpm_loff_t = uint64_t;
pub type rpm_time_t = uint32_t;
pub type rpm_mode_t = uint16_t;
pub type rpm_rdev_t = uint16_t;
pub type rpm_dev_t = uint32_t;
pub type rpm_ino_t = uint32_t;
pub enum Struct_rpmts_s { }
pub type rpmts = *mut Struct_rpmts_s;
pub enum Struct_rpmte_s { }
pub type rpmte = *mut Struct_rpmte_s;
pub enum Struct_rpmds_s { }
pub type rpmds = *mut Struct_rpmds_s;
pub enum Struct_rpmfi_s { }
pub type rpmfi = *mut Struct_rpmfi_s;
pub enum Struct_rpmfiles_s { }
pub type rpmfiles = *mut Struct_rpmfiles_s;
pub enum Struct_rpmdb_s { }
pub type rpmdb = *mut Struct_rpmdb_s;
pub enum Struct_rpmdbMatchIterator_s { }
pub type rpmdbMatchIterator = *mut Struct_rpmdbMatchIterator_s;
pub enum Struct_rpmtsi_s { }
pub type rpmtsi = *mut Struct_rpmtsi_s;
pub enum Struct_rpmps_s { }
pub type rpmps = *mut Struct_rpmps_s;
pub enum Struct_rpmtxn_s { }
pub type rpmtxn = *mut Struct_rpmtxn_s;
pub enum Struct_rpmdbIndexIterator_s { }
pub type rpmdbIndexIterator = *mut Struct_rpmdbIndexIterator_s;
pub type fnpyKey = *const ::std::os::raw::c_void;
pub type rpmCallbackData = *mut ::std::os::raw::c_void;
pub enum Struct_rpmPubkey_s { }
pub type rpmPubkey = *mut Struct_rpmPubkey_s;
pub enum Struct_rpmKeyring_s { }
pub type rpmKeyring = *mut Struct_rpmKeyring_s;
pub type rpmsid = uint32_t;
pub enum Struct_rpmstrPool_s { }
pub type rpmstrPool = *mut Struct_rpmstrPool_s;
pub enum Struct_rpmPlugin_s { }
pub type rpmPlugin = *mut Struct_rpmPlugin_s;
pub enum Struct_rpmPlugins_s { }
pub type rpmPlugins = *mut Struct_rpmPlugins_s;
pub enum Struct_rpmgi_s { }
pub type rpmgi = *mut Struct_rpmgi_s;
pub enum Struct_rpmSpec_s { }
pub type rpmSpec = *mut Struct_rpmSpec_s;
pub type rpmRelocation = Struct_rpmRelocation_s;
pub enum Struct__FD_s { }
pub type FD_t = *mut Struct__FD_s;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmRC_e {
    RPMRC_OK = 0,
    RPMRC_NOTFOUND = 1,
    RPMRC_FAIL = 2,
    RPMRC_NOTTRUSTED = 3,
    RPMRC_NOKEY = 4,
}
pub type rpmRC = Enum_rpmRC_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmTag_e {
    RPMTAG_NOT_FOUND = -1,
    RPMTAG_HEADERIMAGE = 61,
    RPMTAG_HEADERSIGNATURES = 62,
    RPMTAG_HEADERIMMUTABLE = 63,
    RPMTAG_HEADERREGIONS = 64,
    RPMTAG_HEADERI18NTABLE = 100,
    RPMTAG_SIG_BASE = 256,
    RPMTAG_SIGSIZE = 257,
    RPMTAG_SIGLEMD5_1 = 258,
    RPMTAG_SIGPGP = 259,
    RPMTAG_SIGLEMD5_2 = 260,
    RPMTAG_SIGMD5 = 261,
    RPMTAG_SIGGPG = 262,
    RPMTAG_SIGPGP5 = 263,
    RPMTAG_BADSHA1_1 = 264,
    RPMTAG_BADSHA1_2 = 265,
    RPMTAG_PUBKEYS = 266,
    RPMTAG_DSAHEADER = 267,
    RPMTAG_RSAHEADER = 268,
    RPMTAG_SHA1HEADER = 269,
    RPMTAG_LONGSIGSIZE = 270,
    RPMTAG_LONGARCHIVESIZE = 271,
    RPMTAG_NAME = 1000,
    RPMTAG_VERSION = 1001,
    RPMTAG_RELEASE = 1002,
    RPMTAG_EPOCH = 1003,
    RPMTAG_SUMMARY = 1004,
    RPMTAG_DESCRIPTION = 1005,
    RPMTAG_BUILDTIME = 1006,
    RPMTAG_BUILDHOST = 1007,
    RPMTAG_INSTALLTIME = 1008,
    RPMTAG_SIZE = 1009,
    RPMTAG_DISTRIBUTION = 1010,
    RPMTAG_VENDOR = 1011,
    RPMTAG_GIF = 1012,
    RPMTAG_XPM = 1013,
    RPMTAG_LICENSE = 1014,
    RPMTAG_PACKAGER = 1015,
    RPMTAG_GROUP = 1016,
    RPMTAG_CHANGELOG = 1017,
    RPMTAG_SOURCE = 1018,
    RPMTAG_PATCH = 1019,
    RPMTAG_URL = 1020,
    RPMTAG_OS = 1021,
    RPMTAG_ARCH = 1022,
    RPMTAG_PREIN = 1023,
    RPMTAG_POSTIN = 1024,
    RPMTAG_PREUN = 1025,
    RPMTAG_POSTUN = 1026,
    RPMTAG_OLDFILENAMES = 1027,
    RPMTAG_FILESIZES = 1028,
    RPMTAG_FILESTATES = 1029,
    RPMTAG_FILEMODES = 1030,
    RPMTAG_FILEUIDS = 1031,
    RPMTAG_FILEGIDS = 1032,
    RPMTAG_FILERDEVS = 1033,
    RPMTAG_FILEMTIMES = 1034,
    RPMTAG_FILEDIGESTS = 1035,
    RPMTAG_FILELINKTOS = 1036,
    RPMTAG_FILEFLAGS = 1037,
    RPMTAG_ROOT = 1038,
    RPMTAG_FILEUSERNAME = 1039,
    RPMTAG_FILEGROUPNAME = 1040,
    RPMTAG_EXCLUDE = 1041,
    RPMTAG_EXCLUSIVE = 1042,
    RPMTAG_ICON = 1043,
    RPMTAG_SOURCERPM = 1044,
    RPMTAG_FILEVERIFYFLAGS = 1045,
    RPMTAG_ARCHIVESIZE = 1046,
    RPMTAG_PROVIDENAME = 1047,
    RPMTAG_REQUIREFLAGS = 1048,
    RPMTAG_REQUIRENAME = 1049,
    RPMTAG_REQUIREVERSION = 1050,
    RPMTAG_NOSOURCE = 1051,
    RPMTAG_NOPATCH = 1052,
    RPMTAG_CONFLICTFLAGS = 1053,
    RPMTAG_CONFLICTNAME = 1054,
    RPMTAG_CONFLICTVERSION = 1055,
    RPMTAG_DEFAULTPREFIX = 1056,
    RPMTAG_BUILDROOT = 1057,
    RPMTAG_INSTALLPREFIX = 1058,
    RPMTAG_EXCLUDEARCH = 1059,
    RPMTAG_EXCLUDEOS = 1060,
    RPMTAG_EXCLUSIVEARCH = 1061,
    RPMTAG_EXCLUSIVEOS = 1062,
    RPMTAG_AUTOREQPROV = 1063,
    RPMTAG_RPMVERSION = 1064,
    RPMTAG_TRIGGERSCRIPTS = 1065,
    RPMTAG_TRIGGERNAME = 1066,
    RPMTAG_TRIGGERVERSION = 1067,
    RPMTAG_TRIGGERFLAGS = 1068,
    RPMTAG_TRIGGERINDEX = 1069,
    RPMTAG_VERIFYSCRIPT = 1079,
    RPMTAG_CHANGELOGTIME = 1080,
    RPMTAG_CHANGELOGNAME = 1081,
    RPMTAG_CHANGELOGTEXT = 1082,
    RPMTAG_BROKENMD5 = 1083,
    RPMTAG_PREREQ = 1084,
    RPMTAG_PREINPROG = 1085,
    RPMTAG_POSTINPROG = 1086,
    RPMTAG_PREUNPROG = 1087,
    RPMTAG_POSTUNPROG = 1088,
    RPMTAG_BUILDARCHS = 1089,
    RPMTAG_OBSOLETENAME = 1090,
    RPMTAG_VERIFYSCRIPTPROG = 1091,
    RPMTAG_TRIGGERSCRIPTPROG = 1092,
    RPMTAG_DOCDIR = 1093,
    RPMTAG_COOKIE = 1094,
    RPMTAG_FILEDEVICES = 1095,
    RPMTAG_FILEINODES = 1096,
    RPMTAG_FILELANGS = 1097,
    RPMTAG_PREFIXES = 1098,
    RPMTAG_INSTPREFIXES = 1099,
    RPMTAG_TRIGGERIN = 1100,
    RPMTAG_TRIGGERUN = 1101,
    RPMTAG_TRIGGERPOSTUN = 1102,
    RPMTAG_AUTOREQ = 1103,
    RPMTAG_AUTOPROV = 1104,
    RPMTAG_CAPABILITY = 1105,
    RPMTAG_SOURCEPACKAGE = 1106,
    RPMTAG_OLDORIGFILENAMES = 1107,
    RPMTAG_BUILDPREREQ = 1108,
    RPMTAG_BUILDREQUIRES = 1109,
    RPMTAG_BUILDCONFLICTS = 1110,
    RPMTAG_BUILDMACROS = 1111,
    RPMTAG_PROVIDEFLAGS = 1112,
    RPMTAG_PROVIDEVERSION = 1113,
    RPMTAG_OBSOLETEFLAGS = 1114,
    RPMTAG_OBSOLETEVERSION = 1115,
    RPMTAG_DIRINDEXES = 1116,
    RPMTAG_BASENAMES = 1117,
    RPMTAG_DIRNAMES = 1118,
    RPMTAG_ORIGDIRINDEXES = 1119,
    RPMTAG_ORIGBASENAMES = 1120,
    RPMTAG_ORIGDIRNAMES = 1121,
    RPMTAG_OPTFLAGS = 1122,
    RPMTAG_DISTURL = 1123,
    RPMTAG_PAYLOADFORMAT = 1124,
    RPMTAG_PAYLOADCOMPRESSOR = 1125,
    RPMTAG_PAYLOADFLAGS = 1126,
    RPMTAG_INSTALLCOLOR = 1127,
    RPMTAG_INSTALLTID = 1128,
    RPMTAG_REMOVETID = 1129,
    RPMTAG_SHA1RHN = 1130,
    RPMTAG_RHNPLATFORM = 1131,
    RPMTAG_PLATFORM = 1132,
    RPMTAG_PATCHESNAME = 1133,
    RPMTAG_PATCHESFLAGS = 1134,
    RPMTAG_PATCHESVERSION = 1135,
    RPMTAG_CACHECTIME = 1136,
    RPMTAG_CACHEPKGPATH = 1137,
    RPMTAG_CACHEPKGSIZE = 1138,
    RPMTAG_CACHEPKGMTIME = 1139,
    RPMTAG_FILECOLORS = 1140,
    RPMTAG_FILECLASS = 1141,
    RPMTAG_CLASSDICT = 1142,
    RPMTAG_FILEDEPENDSX = 1143,
    RPMTAG_FILEDEPENDSN = 1144,
    RPMTAG_DEPENDSDICT = 1145,
    RPMTAG_SOURCEPKGID = 1146,
    RPMTAG_FILECONTEXTS = 1147,
    RPMTAG_FSCONTEXTS = 1148,
    RPMTAG_RECONTEXTS = 1149,
    RPMTAG_POLICIES = 1150,
    RPMTAG_PRETRANS = 1151,
    RPMTAG_POSTTRANS = 1152,
    RPMTAG_PRETRANSPROG = 1153,
    RPMTAG_POSTTRANSPROG = 1154,
    RPMTAG_DISTTAG = 1155,
    RPMTAG_OLDSUGGESTSNAME = 1156,
    RPMTAG_OLDSUGGESTSVERSION = 1157,
    RPMTAG_OLDSUGGESTSFLAGS = 1158,
    RPMTAG_OLDENHANCESNAME = 1159,
    RPMTAG_OLDENHANCESVERSION = 1160,
    RPMTAG_OLDENHANCESFLAGS = 1161,
    RPMTAG_PRIORITY = 1162,
    RPMTAG_CVSID = 1163,
    RPMTAG_BLINKPKGID = 1164,
    RPMTAG_BLINKHDRID = 1165,
    RPMTAG_BLINKNEVRA = 1166,
    RPMTAG_FLINKPKGID = 1167,
    RPMTAG_FLINKHDRID = 1168,
    RPMTAG_FLINKNEVRA = 1169,
    RPMTAG_PACKAGEORIGIN = 1170,
    RPMTAG_TRIGGERPREIN = 1171,
    RPMTAG_BUILDSUGGESTS = 1172,
    RPMTAG_BUILDENHANCES = 1173,
    RPMTAG_SCRIPTSTATES = 1174,
    RPMTAG_SCRIPTMETRICS = 1175,
    RPMTAG_BUILDCPUCLOCK = 1176,
    RPMTAG_FILEDIGESTALGOS = 1177,
    RPMTAG_VARIANTS = 1178,
    RPMTAG_XMAJOR = 1179,
    RPMTAG_XMINOR = 1180,
    RPMTAG_REPOTAG = 1181,
    RPMTAG_KEYWORDS = 1182,
    RPMTAG_BUILDPLATFORMS = 1183,
    RPMTAG_PACKAGECOLOR = 1184,
    RPMTAG_PACKAGEPREFCOLOR = 1185,
    RPMTAG_XATTRSDICT = 1186,
    RPMTAG_FILEXATTRSX = 1187,
    RPMTAG_DEPATTRSDICT = 1188,
    RPMTAG_CONFLICTATTRSX = 1189,
    RPMTAG_OBSOLETEATTRSX = 1190,
    RPMTAG_PROVIDEATTRSX = 1191,
    RPMTAG_REQUIREATTRSX = 1192,
    RPMTAG_BUILDPROVIDES = 1193,
    RPMTAG_BUILDOBSOLETES = 1194,
    RPMTAG_DBINSTANCE = 1195,
    RPMTAG_NVRA = 1196,
    RPMTAG_FILENAMES = 5000,
    RPMTAG_FILEPROVIDE = 5001,
    RPMTAG_FILEREQUIRE = 5002,
    RPMTAG_FSNAMES = 5003,
    RPMTAG_FSSIZES = 5004,
    RPMTAG_TRIGGERCONDS = 5005,
    RPMTAG_TRIGGERTYPE = 5006,
    RPMTAG_ORIGFILENAMES = 5007,
    RPMTAG_LONGFILESIZES = 5008,
    RPMTAG_LONGSIZE = 5009,
    RPMTAG_FILECAPS = 5010,
    RPMTAG_FILEDIGESTALGO = 5011,
    RPMTAG_BUGURL = 5012,
    RPMTAG_EVR = 5013,
    RPMTAG_NVR = 5014,
    RPMTAG_NEVR = 5015,
    RPMTAG_NEVRA = 5016,
    RPMTAG_HEADERCOLOR = 5017,
    RPMTAG_VERBOSE = 5018,
    RPMTAG_EPOCHNUM = 5019,
    RPMTAG_PREINFLAGS = 5020,
    RPMTAG_POSTINFLAGS = 5021,
    RPMTAG_PREUNFLAGS = 5022,
    RPMTAG_POSTUNFLAGS = 5023,
    RPMTAG_PRETRANSFLAGS = 5024,
    RPMTAG_POSTTRANSFLAGS = 5025,
    RPMTAG_VERIFYSCRIPTFLAGS = 5026,
    RPMTAG_TRIGGERSCRIPTFLAGS = 5027,
    RPMTAG_COLLECTIONS = 5029,
    RPMTAG_POLICYNAMES = 5030,
    RPMTAG_POLICYTYPES = 5031,
    RPMTAG_POLICYTYPESINDEXES = 5032,
    RPMTAG_POLICYFLAGS = 5033,
    RPMTAG_VCS = 5034,
    RPMTAG_ORDERNAME = 5035,
    RPMTAG_ORDERVERSION = 5036,
    RPMTAG_ORDERFLAGS = 5037,
    RPMTAG_MSSFMANIFEST = 5038,
    RPMTAG_MSSFDOMAIN = 5039,
    RPMTAG_INSTFILENAMES = 5040,
    RPMTAG_REQUIRENEVRS = 5041,
    RPMTAG_PROVIDENEVRS = 5042,
    RPMTAG_OBSOLETENEVRS = 5043,
    RPMTAG_CONFLICTNEVRS = 5044,
    RPMTAG_FILENLINKS = 5045,
    RPMTAG_RECOMMENDNAME = 5046,
    RPMTAG_RECOMMENDVERSION = 5047,
    RPMTAG_RECOMMENDFLAGS = 5048,
    RPMTAG_SUGGESTNAME = 5049,
    RPMTAG_SUGGESTVERSION = 5050,
    RPMTAG_SUGGESTFLAGS = 5051,
    RPMTAG_SUPPLEMENTNAME = 5052,
    RPMTAG_SUPPLEMENTVERSION = 5053,
    RPMTAG_SUPPLEMENTFLAGS = 5054,
    RPMTAG_ENHANCENAME = 5055,
    RPMTAG_ENHANCEVERSION = 5056,
    RPMTAG_ENHANCEFLAGS = 5057,
    RPMTAG_RECOMMENDNEVRS = 5058,
    RPMTAG_SUGGESTNEVRS = 5059,
    RPMTAG_SUPPLEMENTNEVRS = 5060,
    RPMTAG_ENHANCENEVRS = 5061,
    RPMTAG_ENCODING = 5062,
    RPMTAG_FILETRIGGERIN = 5063,
    RPMTAG_FILETRIGGERUN = 5064,
    RPMTAG_FILETRIGGERPOSTUN = 5065,
    RPMTAG_FILETRIGGERSCRIPTS = 5066,
    RPMTAG_FILETRIGGERSCRIPTPROG = 5067,
    RPMTAG_FILETRIGGERSCRIPTFLAGS = 5068,
    RPMTAG_FILETRIGGERNAME = 5069,
    RPMTAG_FILETRIGGERINDEX = 5070,
    RPMTAG_FILETRIGGERVERSION = 5071,
    RPMTAG_FILETRIGGERFLAGS = 5072,
    RPMTAG_TRANSFILETRIGGERIN = 5073,
    RPMTAG_TRANSFILETRIGGERUN = 5074,
    RPMTAG_TRANSFILETRIGGERPOSTUN = 5075,
    RPMTAG_TRANSFILETRIGGERSCRIPTS = 5076,
    RPMTAG_TRANSFILETRIGGERSCRIPTPROG = 5077,
    RPMTAG_TRANSFILETRIGGERSCRIPTFLAGS = 5078,
    RPMTAG_TRANSFILETRIGGERNAME = 5079,
    RPMTAG_TRANSFILETRIGGERINDEX = 5080,
    RPMTAG_TRANSFILETRIGGERVERSION = 5081,
    RPMTAG_TRANSFILETRIGGERFLAGS = 5082,
    RPMTAG_REMOVEPATHPOSTFIXES = 5083,
    RPMTAG_FILETRIGGERPRIORITIES = 5084,
    RPMTAG_TRANSFILETRIGGERPRIORITIES = 5085,
    RPMTAG_FILETRIGGERCONDS = 5086,
    RPMTAG_FILETRIGGERTYPE = 5087,
    RPMTAG_TRANSFILETRIGGERCONDS = 5088,
    RPMTAG_TRANSFILETRIGGERTYPE = 5089,
    RPMTAG_FILESIGNATURES = 5090,
    RPMTAG_FILESIGNATURELENGTH = 5091,
    RPMTAG_FIRSTFREE_TAG = 5092,
}
pub type rpmTag = Enum_rpmTag_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmDbiTag_e {
    RPMDBI_PACKAGES = 0,
    RPMDBI_LABEL = 2,
    RPMDBI_NAME = 1000,
    RPMDBI_BASENAMES = 1117,
    RPMDBI_GROUP = 1016,
    RPMDBI_REQUIRENAME = 1049,
    RPMDBI_PROVIDENAME = 1047,
    RPMDBI_CONFLICTNAME = 1054,
    RPMDBI_OBSOLETENAME = 1090,
    RPMDBI_TRIGGERNAME = 1066,
    RPMDBI_DIRNAMES = 1118,
    RPMDBI_INSTALLTID = 1128,
    RPMDBI_SIGMD5 = 261,
    RPMDBI_SHA1HEADER = 269,
    RPMDBI_INSTFILENAMES = 5040,
    RPMDBI_FILETRIGGERNAME = 5069,
    RPMDBI_TRANSFILETRIGGERNAME = 5079,
    RPMDBI_RECOMMENDNAME = 5046,
    RPMDBI_SUGGESTNAME = 5049,
    RPMDBI_SUPPLEMENTNAME = 5052,
    RPMDBI_ENHANCENAME = 5055,
}
pub type rpmDbiTag = Enum_rpmDbiTag_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmSigTag_e {
    RPMSIGTAG_SIZE = 1000,
    RPMSIGTAG_LEMD5_1 = 1001,
    RPMSIGTAG_PGP = 1002,
    RPMSIGTAG_LEMD5_2 = 1003,
    RPMSIGTAG_MD5 = 1004,
    RPMSIGTAG_GPG = 1005,
    RPMSIGTAG_PGP5 = 1006,
    RPMSIGTAG_PAYLOADSIZE = 1007,
    RPMSIGTAG_RESERVEDSPACE = 1008,
    RPMSIGTAG_BADSHA1_1 = 264,
    RPMSIGTAG_BADSHA1_2 = 265,
    RPMSIGTAG_SHA1 = 269,
    RPMSIGTAG_DSA = 267,
    RPMSIGTAG_RSA = 268,
    RPMSIGTAG_LONGSIZE = 270,
    RPMSIGTAG_LONGARCHIVESIZE = 271,
}
pub type rpmSigTag = Enum_rpmSigTag_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmTagType_e {
    RPM_NULL_TYPE = 0,
    RPM_CHAR_TYPE = 1,
    RPM_INT8_TYPE = 2,
    RPM_INT16_TYPE = 3,
    RPM_INT32_TYPE = 4,
    RPM_INT64_TYPE = 5,
    RPM_STRING_TYPE = 6,
    RPM_BIN_TYPE = 7,
    RPM_STRING_ARRAY_TYPE = 8,
    RPM_I18NSTRING_TYPE = 9,
}
pub type rpmTagType = Enum_rpmTagType_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmTagClass_e {
    RPM_NULL_CLASS = 0,
    RPM_NUMERIC_CLASS = 1,
    RPM_STRING_CLASS = 2,
    RPM_BINARY_CLASS = 3,
}
pub type rpmTagClass = Enum_rpmTagClass_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmSubTagType_e {
    RPM_REGION_TYPE = -10,
    RPM_BIN_ARRAY_TYPE = -11,
    RPM_XREF_TYPE = -12,
}
pub type rpmSubTagType = Enum_rpmSubTagType_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmTagReturnType_e {
    RPM_ANY_RETURN_TYPE = 0,
    RPM_SCALAR_RETURN_TYPE = 65536,
    RPM_ARRAY_RETURN_TYPE = 131072,
    RPM_MAPPING_RETURN_TYPE = 262144,
    RPM_MASK_RETURN_TYPE = -65536,
}
pub type rpmTagReturnType = rpmFlags;
pub type rpmMemFailFunc =
    ::std::option::Option<unsafe extern "C" fn(size: size_t,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
pub enum Struct_DIGEST_CTX_s { }
pub type DIGEST_CTX = *mut Struct_DIGEST_CTX_s;
pub enum Struct_rpmDigestBundle_s { }
pub type rpmDigestBundle = *mut Struct_rpmDigestBundle_s;
pub enum Struct_pgpDig_s { }
pub type pgpDig = *mut Struct_pgpDig_s;
pub enum Struct_pgpDigParams_s { }
pub type pgpDigParams = *mut Struct_pgpDigParams_s;
pub type pgpKeyID_t = [uint8_t; 8usize];
pub type pgpTime_t = [uint8_t; 4usize];
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpTag_e {
    PGPTAG_RESERVED = 0,
    PGPTAG_PUBLIC_SESSION_KEY = 1,
    PGPTAG_SIGNATURE = 2,
    PGPTAG_SYMMETRIC_SESSION_KEY = 3,
    PGPTAG_ONEPASS_SIGNATURE = 4,
    PGPTAG_SECRET_KEY = 5,
    PGPTAG_PUBLIC_KEY = 6,
    PGPTAG_SECRET_SUBKEY = 7,
    PGPTAG_COMPRESSED_DATA = 8,
    PGPTAG_SYMMETRIC_DATA = 9,
    PGPTAG_MARKER = 10,
    PGPTAG_LITERAL_DATA = 11,
    PGPTAG_TRUST = 12,
    PGPTAG_USER_ID = 13,
    PGPTAG_PUBLIC_SUBKEY = 14,
    PGPTAG_COMMENT_OLD = 16,
    PGPTAG_PHOTOID = 17,
    PGPTAG_ENCRYPTED_MDC = 18,
    PGPTAG_MDC = 19,
    PGPTAG_PRIVATE_60 = 60,
    PGPTAG_COMMENT = 61,
    PGPTAG_PRIVATE_62 = 62,
    PGPTAG_CONTROL = 63,
}
pub type pgpTag = Enum_pgpTag_e;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktPubkey_s {
    pub version: uint8_t,
    pub keyid: pgpKeyID_t,
    pub algo: uint8_t,
}
impl ::std::clone::Clone for Struct_pgpPktPubkey_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktPubkey_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktPubkey = Struct_pgpPktPubkey_s;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpSigType_e {
    PGPSIGTYPE_BINARY = 0,
    PGPSIGTYPE_TEXT = 1,
    PGPSIGTYPE_STANDALONE = 2,
    PGPSIGTYPE_GENERIC_CERT = 16,
    PGPSIGTYPE_PERSONA_CERT = 17,
    PGPSIGTYPE_CASUAL_CERT = 18,
    PGPSIGTYPE_POSITIVE_CERT = 19,
    PGPSIGTYPE_SUBKEY_BINDING = 24,
    PGPSIGTYPE_SIGNED_KEY = 31,
    PGPSIGTYPE_KEY_REVOKE = 32,
    PGPSIGTYPE_SUBKEY_REVOKE = 40,
    PGPSIGTYPE_CERT_REVOKE = 48,
    PGPSIGTYPE_TIMESTAMP = 64,
}
pub type pgpSigType = Enum_pgpSigType_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpPubkeyAlgo_e {
    PGPPUBKEYALGO_RSA = 1,
    PGPPUBKEYALGO_RSA_ENCRYPT = 2,
    PGPPUBKEYALGO_RSA_SIGN = 3,
    PGPPUBKEYALGO_ELGAMAL_ENCRYPT = 16,
    PGPPUBKEYALGO_DSA = 17,
    PGPPUBKEYALGO_EC = 18,
    PGPPUBKEYALGO_ECDSA = 19,
    PGPPUBKEYALGO_ELGAMAL = 20,
    PGPPUBKEYALGO_DH = 21,
}
pub type pgpPubkeyAlgo = Enum_pgpPubkeyAlgo_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpSymkeyAlgo_e {
    PGPSYMKEYALGO_PLAINTEXT = 0,
    PGPSYMKEYALGO_IDEA = 1,
    PGPSYMKEYALGO_TRIPLE_DES = 2,
    PGPSYMKEYALGO_CAST5 = 3,
    PGPSYMKEYALGO_BLOWFISH = 4,
    PGPSYMKEYALGO_SAFER = 5,
    PGPSYMKEYALGO_DES_SK = 6,
    PGPSYMKEYALGO_AES_128 = 7,
    PGPSYMKEYALGO_AES_192 = 8,
    PGPSYMKEYALGO_AES_256 = 9,
    PGPSYMKEYALGO_TWOFISH = 10,
    PGPSYMKEYALGO_NOENCRYPT = 110,
}
pub type pgpSymkeyAlgo = Enum_pgpSymkeyAlgo_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpCompressAlgo_e {
    PGPCOMPRESSALGO_NONE = 0,
    PGPCOMPRESSALGO_ZIP = 1,
    PGPCOMPRESSALGO_ZLIB = 2,
    PGPCOMPRESSALGO_BZIP2 = 3,
}
pub type pgpCompressAlgo = Enum_pgpCompressAlgo_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpHashAlgo_e {
    PGPHASHALGO_MD5 = 1,
    PGPHASHALGO_SHA1 = 2,
    PGPHASHALGO_RIPEMD160 = 3,
    PGPHASHALGO_MD2 = 5,
    PGPHASHALGO_TIGER192 = 6,
    PGPHASHALGO_HAVAL_5_160 = 7,
    PGPHASHALGO_SHA256 = 8,
    PGPHASHALGO_SHA384 = 9,
    PGPHASHALGO_SHA512 = 10,
    PGPHASHALGO_SHA224 = 11,
}
pub type pgpHashAlgo = Enum_pgpHashAlgo_e;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktSigV3_s {
    pub version: uint8_t,
    pub hashlen: uint8_t,
    pub sigtype: uint8_t,
    pub time: pgpTime_t,
    pub signid: pgpKeyID_t,
    pub pubkey_algo: uint8_t,
    pub hash_algo: uint8_t,
    pub signhash16: [uint8_t; 2usize],
}
impl ::std::clone::Clone for Struct_pgpPktSigV3_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktSigV3_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktSigV3 = *mut Struct_pgpPktSigV3_s;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktSigV4_s {
    pub version: uint8_t,
    pub sigtype: uint8_t,
    pub pubkey_algo: uint8_t,
    pub hash_algo: uint8_t,
    pub hashlen: [uint8_t; 2usize],
}
impl ::std::clone::Clone for Struct_pgpPktSigV4_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktSigV4_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktSigV4 = *mut Struct_pgpPktSigV4_s;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpSubType_e {
    PGPSUBTYPE_NONE = 0,
    PGPSUBTYPE_SIG_CREATE_TIME = 2,
    PGPSUBTYPE_SIG_EXPIRE_TIME = 3,
    PGPSUBTYPE_EXPORTABLE_CERT = 4,
    PGPSUBTYPE_TRUST_SIG = 5,
    PGPSUBTYPE_REGEX = 6,
    PGPSUBTYPE_REVOCABLE = 7,
    PGPSUBTYPE_KEY_EXPIRE_TIME = 9,
    PGPSUBTYPE_ARR = 10,
    PGPSUBTYPE_PREFER_SYMKEY = 11,
    PGPSUBTYPE_REVOKE_KEY = 12,
    PGPSUBTYPE_ISSUER_KEYID = 16,
    PGPSUBTYPE_NOTATION = 20,
    PGPSUBTYPE_PREFER_HASH = 21,
    PGPSUBTYPE_PREFER_COMPRESS = 22,
    PGPSUBTYPE_KEYSERVER_PREFERS = 23,
    PGPSUBTYPE_PREFER_KEYSERVER = 24,
    PGPSUBTYPE_PRIMARY_USERID = 25,
    PGPSUBTYPE_POLICY_URL = 26,
    PGPSUBTYPE_KEY_FLAGS = 27,
    PGPSUBTYPE_SIGNER_USERID = 28,
    PGPSUBTYPE_REVOKE_REASON = 29,
    PGPSUBTYPE_FEATURES = 30,
    PGPSUBTYPE_EMBEDDED_SIG = 32,
    PGPSUBTYPE_INTERNAL_100 = 100,
    PGPSUBTYPE_INTERNAL_101 = 101,
    PGPSUBTYPE_INTERNAL_102 = 102,
    PGPSUBTYPE_INTERNAL_103 = 103,
    PGPSUBTYPE_INTERNAL_104 = 104,
    PGPSUBTYPE_INTERNAL_105 = 105,
    PGPSUBTYPE_INTERNAL_106 = 106,
    PGPSUBTYPE_INTERNAL_107 = 107,
    PGPSUBTYPE_INTERNAL_108 = 108,
    PGPSUBTYPE_INTERNAL_109 = 109,
    PGPSUBTYPE_INTERNAL_110 = 110,
    PGPSUBTYPE_CRITICAL = 128,
}
pub type pgpSubType = Enum_pgpSubType_e;
#[repr(C)]
#[derive(Copy)]
pub struct Union_pgpPktSig_u {
    pub _bindgen_data_: [u8; 19usize],
}
impl Union_pgpPktSig_u {
    pub unsafe fn v3(&mut self) -> *mut Struct_pgpPktSigV3_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v4(&mut self) -> *mut Struct_pgpPktSigV4_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_pgpPktSig_u {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_pgpPktSig_u {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktSig = *mut Union_pgpPktSig_u;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktSymkey_s {
    pub version: uint8_t,
    pub symkey_algo: uint8_t,
    pub s2k: [uint8_t; 1usize],
}
impl ::std::clone::Clone for Struct_pgpPktSymkey_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktSymkey_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktSymkey = Struct_pgpPktSymkey_s;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktOnepass_s {
    pub version: uint8_t,
    pub sigtype: uint8_t,
    pub hash_algo: uint8_t,
    pub pubkey_algo: uint8_t,
    pub signid: pgpKeyID_t,
    pub nested: uint8_t,
}
impl ::std::clone::Clone for Struct_pgpPktOnepass_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktOnepass_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktOnepass = *mut Struct_pgpPktOnepass_s;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktKeyV3_s {
    pub version: uint8_t,
    pub time: pgpTime_t,
    pub valid: [uint8_t; 2usize],
    pub pubkey_algo: uint8_t,
}
impl ::std::clone::Clone for Struct_pgpPktKeyV3_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktKeyV3_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktKeyV3 = *mut Struct_pgpPktKeyV3_s;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktKeyV4_s {
    pub version: uint8_t,
    pub time: pgpTime_t,
    pub pubkey_algo: uint8_t,
}
impl ::std::clone::Clone for Struct_pgpPktKeyV4_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktKeyV4_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktKeyV4 = *mut Struct_pgpPktKeyV4_s;
#[repr(C)]
#[derive(Copy)]
pub struct Union_pgpPktKey_u {
    pub _bindgen_data_: [u8; 8usize],
}
impl Union_pgpPktKey_u {
    pub unsafe fn v3(&mut self) -> *mut Struct_pgpPktKeyV3_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn v4(&mut self) -> *mut Struct_pgpPktKeyV4_s {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_pgpPktKey_u {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_pgpPktKey_u {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktKey = Union_pgpPktKey_u;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktCdata_s {
    pub compressalgo: uint8_t,
    pub data: [uint8_t; 1usize],
}
impl ::std::clone::Clone for Struct_pgpPktCdata_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktCdata_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktCdata = Struct_pgpPktCdata_s;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktEdata_s {
    pub data: [uint8_t; 1usize],
}
impl ::std::clone::Clone for Struct_pgpPktEdata_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktEdata_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktEdata = Struct_pgpPktEdata_s;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktLdata_s {
    pub format: uint8_t,
    pub filenamelen: uint8_t,
    pub filename: [uint8_t; 1usize],
}
impl ::std::clone::Clone for Struct_pgpPktLdata_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktLdata_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktLdata = Struct_pgpPktLdata_s;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktTrust_s {
    pub flag: uint8_t,
}
impl ::std::clone::Clone for Struct_pgpPktTrust_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktTrust_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktTrust = Struct_pgpPktTrust_s;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pgpPktUid_s {
    pub userid: [uint8_t; 1usize],
}
impl ::std::clone::Clone for Struct_pgpPktUid_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pgpPktUid_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pgpPktUid = Struct_pgpPktUid_s;
#[repr(C)]
#[derive(Copy)]
pub struct Union_pgpPktPre_u {
    pub _bindgen_data_: [u64; 2usize],
}
impl Union_pgpPktPre_u {
    pub unsafe fn pubkey(&mut self) -> *mut pgpPktPubkey {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sig(&mut self) -> *mut pgpPktSig {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn symkey(&mut self) -> *mut pgpPktSymkey {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn onepass(&mut self) -> *mut pgpPktOnepass {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn key(&mut self) -> *mut pgpPktKey {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cdata(&mut self) -> *mut pgpPktCdata {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn edata(&mut self) -> *mut pgpPktEdata {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ldata(&mut self) -> *mut pgpPktLdata {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn tdata(&mut self) -> *mut pgpPktTrust {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn uid(&mut self) -> *mut pgpPktUid {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_pgpPktPre_u {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_pgpPktPre_u {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpArmor_e {
    PGPARMOR_ERR_CRC_CHECK = -7,
    PGPARMOR_ERR_BODY_DECODE = -6,
    PGPARMOR_ERR_CRC_DECODE = -5,
    PGPARMOR_ERR_NO_END_PGP = -4,
    PGPARMOR_ERR_UNKNOWN_PREAMBLE_TAG = -3,
    PGPARMOR_ERR_UNKNOWN_ARMOR_TYPE = -2,
    PGPARMOR_ERR_NO_BEGIN_PGP = -1,
    PGPARMOR_NONE = 0,
    PGPARMOR_MESSAGE = 1,
    PGPARMOR_PUBKEY = 2,
    PGPARMOR_SIGNATURE = 3,
    PGPARMOR_SIGNED_MESSAGE = 4,
    PGPARMOR_FILE = 5,
    PGPARMOR_PRIVKEY = 6,
    PGPARMOR_SECKEY = 7,
}
pub type pgpArmor = Enum_pgpArmor_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpArmorKey_e {
    PGPARMORKEY_VERSION = 1,
    PGPARMORKEY_COMMENT = 2,
    PGPARMORKEY_MESSAGEID = 3,
    PGPARMORKEY_HASH = 4,
    PGPARMORKEY_CHARSET = 5,
}
pub type pgpArmorKey = Enum_pgpArmorKey_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_pgpValType_e {
    PGPVAL_TAG = 1,
    PGPVAL_ARMORBLOCK = 2,
    PGPVAL_ARMORKEY = 3,
    PGPVAL_SIGTYPE = 4,
    PGPVAL_SUBTYPE = 5,
    PGPVAL_PUBKEYALGO = 6,
    PGPVAL_SYMKEYALGO = 7,
    PGPVAL_COMPRESSALGO = 8,
    PGPVAL_HASHALGO = 9,
    PGPVAL_SERVERPREFS = 10,
}
pub type pgpValType = Enum_pgpValType_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmDigestFlags_e { RPMDIGEST_NONE = 0, }
pub type rpmDigestFlags = rpmFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_Unnamed293 {
    HIF_PACKAGE_INFO_UNKNOWN = 0,
    HIF_PACKAGE_INFO_UPDATE = 11,
    HIF_PACKAGE_INFO_INSTALL = 12,
    HIF_PACKAGE_INFO_REMOVE = 13,
    HIF_PACKAGE_INFO_CLEANUP = 14,
    HIF_PACKAGE_INFO_OBSOLETE = 15,
    HIF_PACKAGE_INFO_REINSTALL = 19,
    HIF_PACKAGE_INFO_DOWNGRADE = 20,
    HIF_PACKAGE_INFO_LAST = 21,
}
pub type HifPackageInfo = Enum_Unnamed293;
pub type ARGV_t = *mut *mut ::std::os::raw::c_char;
pub type ARGV_const_t = *const *mut ::std::os::raw::c_char;
pub type ARGint_t = *mut ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ARGI_s {
    pub nvals: ::std::os::raw::c_uint,
    pub vals: ARGint_t,
}
impl ::std::clone::Clone for Struct_ARGI_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ARGI_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ARGI_t = *mut Struct_ARGI_s;
pub type ARGI_const_t = *const Struct_ARGI_s;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_argvFlags_e { ARGV_NONE = 0, ARGV_SKIPEMPTY = 1, }
pub type argvFlags = rpmFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmElementType_e { TR_ADDED = 1, TR_REMOVED = 2, }
pub type rpmElementType = Enum_rpmElementType_e;
pub type rpmElementTypes = rpmFlags;
pub enum Struct_rpmProblem_s { }
pub type rpmProblem = *mut Struct_rpmProblem_s;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmprobFilterFlags_e {
    RPMPROB_FILTER_NONE = 0,
    RPMPROB_FILTER_IGNOREOS = 1,
    RPMPROB_FILTER_IGNOREARCH = 2,
    RPMPROB_FILTER_REPLACEPKG = 4,
    RPMPROB_FILTER_FORCERELOCATE = 8,
    RPMPROB_FILTER_REPLACENEWFILES = 16,
    RPMPROB_FILTER_REPLACEOLDFILES = 32,
    RPMPROB_FILTER_OLDPACKAGE = 64,
    RPMPROB_FILTER_DISKSPACE = 128,
    RPMPROB_FILTER_DISKNODES = 256,
}
pub type rpmprobFilterFlags = rpmFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmProblemType_e {
    RPMPROB_BADARCH = 0,
    RPMPROB_BADOS = 1,
    RPMPROB_PKG_INSTALLED = 2,
    RPMPROB_BADRELOCATE = 3,
    RPMPROB_REQUIRES = 4,
    RPMPROB_CONFLICT = 5,
    RPMPROB_NEW_FILE_CONFLICT = 6,
    RPMPROB_FILE_CONFLICT = 7,
    RPMPROB_OLDPACKAGE = 8,
    RPMPROB_DISKSPACE = 9,
    RPMPROB_DISKNODES = 10,
    RPMPROB_OBSOLETES = 11,
}
pub type rpmProblemType = Enum_rpmProblemType_e;
pub enum Struct_rpmpsi_s { }
pub type rpmpsi = *mut Struct_rpmpsi_s;
pub type rpmtime_t = ::std::os::raw::c_ulong;
pub type rpmsw = *mut Struct_rpmsw_s;
pub type rpmop = *mut Struct_rpmop_s;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rpmsw_s {
    pub u: Union_Unnamed294,
}
impl ::std::clone::Clone for Struct_rpmsw_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rpmsw_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed294 {
    pub _bindgen_data_: [u64; 2usize],
}
impl Union_Unnamed294 {
    pub unsafe fn tv(&mut self) -> *mut Struct_timeval {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ticks(&mut self) -> *mut ::std::os::raw::c_ulonglong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn tocks(&mut self) -> *mut [::std::os::raw::c_ulong; 2usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed294 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed294 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rpmop_s {
    pub begin: Struct_rpmsw_s,
    pub count: ::std::os::raw::c_int,
    pub bytes: size_t,
    pub usecs: rpmtime_t,
}
impl ::std::clone::Clone for Struct_rpmop_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rpmop_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: Struct_timespec,
    pub st_mtim: Struct_timespec,
    pub st_ctim: Struct_timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
impl ::std::clone::Clone for Struct_stat {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_stat {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub const RPMVERIFY_FILEDIGEST: Enum_rpmVerifyAttrs_e =
    Enum_rpmVerifyAttrs_e::RPMVERIFY_MD5;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmVerifyAttrs_e {
    RPMVERIFY_NONE = 0,
    RPMVERIFY_MD5 = 1,
    RPMVERIFY_FILESIZE = 2,
    RPMVERIFY_LINKTO = 4,
    RPMVERIFY_USER = 8,
    RPMVERIFY_GROUP = 16,
    RPMVERIFY_MTIME = 32,
    RPMVERIFY_MODE = 64,
    RPMVERIFY_RDEV = 128,
    RPMVERIFY_CAPS = 256,
    RPMVERIFY_CONTEXTS = 32768,
    RPMVERIFY_READLINKFAIL = 268435456,
    RPMVERIFY_READFAIL = 536870912,
    RPMVERIFY_LSTATFAIL = 1073741824,
    RPMVERIFY_LGETFILECONFAIL = -2147483648,
}
pub type rpmVerifyAttrs = rpmFlags;
pub const VERIFY_FILEDIGEST: Enum_rpmVerifyFlags_e =
    Enum_rpmVerifyFlags_e::VERIFY_MD5;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmVerifyFlags_e {
    VERIFY_DEFAULT = 0,
    VERIFY_MD5 = 1,
    VERIFY_SIZE = 2,
    VERIFY_LINKTO = 4,
    VERIFY_USER = 8,
    VERIFY_GROUP = 16,
    VERIFY_MTIME = 32,
    VERIFY_MODE = 64,
    VERIFY_RDEV = 128,
    VERIFY_CAPS = 256,
    VERIFY_CONTEXTS = 32768,
    VERIFY_FILES = 65536,
    VERIFY_DEPS = 131072,
    VERIFY_SCRIPT = 262144,
    VERIFY_DIGEST = 524288,
    VERIFY_SIGNATURE = 1048576,
    VERIFY_PATCHES = 2097152,
    VERIFY_HDRCHK = 4194304,
    VERIFY_FOR_LIST = 8388608,
    VERIFY_FOR_STATE = 16777216,
    VERIFY_FOR_DOCS = 33554432,
    VERIFY_FOR_CONFIG = 67108864,
    VERIFY_FOR_DUMPFILES = 134217728,
}
pub type rpmVerifyFlags = rpmFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmFileTypes_e {
    PIPE = 1,
    CDEV = 2,
    XDIR = 4,
    BDEV = 6,
    REG = 8,
    LINK = 10,
    SOCK = 12,
}
pub type rpmFileTypes = Enum_rpmFileTypes_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmfileState_e {
    RPMFILE_STATE_MISSING = -1,
    RPMFILE_STATE_NORMAL = 0,
    RPMFILE_STATE_REPLACED = 1,
    RPMFILE_STATE_NOTINSTALLED = 2,
    RPMFILE_STATE_NETSHARED = 3,
    RPMFILE_STATE_WRONGCOLOR = 4,
}
pub type rpmfileState = Enum_rpmfileState_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmfileAttrs_e {
    RPMFILE_NONE = 0,
    RPMFILE_CONFIG = 1,
    RPMFILE_DOC = 2,
    RPMFILE_ICON = 4,
    RPMFILE_MISSINGOK = 8,
    RPMFILE_NOREPLACE = 16,
    RPMFILE_SPECFILE = 32,
    RPMFILE_GHOST = 64,
    RPMFILE_LICENSE = 128,
    RPMFILE_README = 256,
    RPMFILE_PUBKEY = 2048,
}
pub type rpmfileAttrs = rpmFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmFileAction_e {
    FA_UNKNOWN = 0,
    FA_CREATE = 1,
    FA_COPYIN = 2,
    FA_COPYOUT = 3,
    FA_BACKUP = 4,
    FA_SAVE = 5,
    FA_SKIP = 6,
    FA_ALTNAME = 7,
    FA_ERASE = 8,
    FA_SKIPNSTATE = 9,
    FA_SKIPNETSHARED = 10,
    FA_SKIPCOLOR = 11,
}
pub type rpmFileAction = Enum_rpmFileAction_e;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rpmRelocation_s {
    pub oldPath: *mut ::std::os::raw::c_char,
    pub newPath: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_rpmRelocation_s {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rpmRelocation_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmfiFlags_e {
    RPMFI_NOHEADER = 0,
    RPMFI_KEEPHEADER = 1,
    RPMFI_NOFILECLASS = 2,
    RPMFI_NOFILEDEPS = 4,
    RPMFI_NOFILELANGS = 8,
    RPMFI_NOFILEUSER = 16,
    RPMFI_NOFILEGROUP = 32,
    RPMFI_NOFILEMODES = 64,
    RPMFI_NOFILESIZES = 128,
    RPMFI_NOFILECAPS = 256,
    RPMFI_NOFILELINKTOS = 512,
    RPMFI_NOFILEDIGESTS = 1024,
    RPMFI_NOFILEMTIMES = 2048,
    RPMFI_NOFILERDEVS = 4096,
    RPMFI_NOFILEINODES = 8192,
    RPMFI_NOFILESTATES = 16384,
    RPMFI_NOFILECOLORS = 32768,
    RPMFI_NOFILEVERIFYFLAGS = 65536,
    RPMFI_NOFILEFLAGS = 131072,
    RPMFI_NOFILESIGNATURES = 262144,
}
pub type rpmfiFlags = rpmFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmFileIter_e {
    RPMFI_ITER_FWD = 0,
    RPMFI_ITER_BACK = 1,
    RPMFI_ITER_WRITE_ARCHIVE = 2,
    RPMFI_ITER_READ_ARCHIVE = 3,
    RPMFI_ITER_READ_ARCHIVE_CONTENT_FIRST = 4,
    RPMFI_ITER_READ_ARCHIVE_OMIT_HARDLINKS = 5,
    RPMFI_ITER_INTERVAL = 6,
}
pub type rpmFileIter = Enum_rpmFileIter_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmfilesErrorCodes {
    RPMERR_ITER_END = -1,
    RPMERR_BAD_MAGIC = -2,
    RPMERR_BAD_HEADER = -3,
    RPMERR_HDR_SIZE = -4,
    RPMERR_UNKNOWN_FILETYPE = -5,
    RPMERR_MISSING_FILE = -6,
    RPMERR_DIGEST_MISMATCH = -7,
    RPMERR_INTERNAL = -8,
    RPMERR_UNMAPPED_FILE = -9,
    RPMERR_ENOENT = -10,
    RPMERR_ENOTEMPTY = -11,
    RPMERR_FILE_SIZE = -12,
    RPMERR_ITER_SKIP = -13,
    RPMERR_OPEN_FAILED = -32768,
    RPMERR_CHMOD_FAILED = -32769,
    RPMERR_CHOWN_FAILED = -32770,
    RPMERR_WRITE_FAILED = -32771,
    RPMERR_UTIME_FAILED = -32772,
    RPMERR_UNLINK_FAILED = -32773,
    RPMERR_RENAME_FAILED = -32774,
    RPMERR_SYMLINK_FAILED = -32775,
    RPMERR_STAT_FAILED = -32776,
    RPMERR_LSTAT_FAILED = -32777,
    RPMERR_MKDIR_FAILED = -32778,
    RPMERR_RMDIR_FAILED = -32779,
    RPMERR_MKNOD_FAILED = -32780,
    RPMERR_MKFIFO_FAILED = -32781,
    RPMERR_LINK_FAILED = -32782,
    RPMERR_READLINK_FAILED = -32783,
    RPMERR_READ_FAILED = -32784,
    RPMERR_COPY_FAILED = -32785,
    RPMERR_LSETFCON_FAILED = -32786,
    RPMERR_SETCAP_FAILED = -32787,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmCallbackType_e {
    RPMCALLBACK_UNKNOWN = 0,
    RPMCALLBACK_INST_PROGRESS = 1,
    RPMCALLBACK_INST_START = 2,
    RPMCALLBACK_INST_OPEN_FILE = 4,
    RPMCALLBACK_INST_CLOSE_FILE = 8,
    RPMCALLBACK_TRANS_PROGRESS = 16,
    RPMCALLBACK_TRANS_START = 32,
    RPMCALLBACK_TRANS_STOP = 64,
    RPMCALLBACK_UNINST_PROGRESS = 128,
    RPMCALLBACK_UNINST_START = 256,
    RPMCALLBACK_UNINST_STOP = 512,
    RPMCALLBACK_REPACKAGE_PROGRESS = 1024,
    RPMCALLBACK_REPACKAGE_START = 2048,
    RPMCALLBACK_REPACKAGE_STOP = 4096,
    RPMCALLBACK_UNPACK_ERROR = 8192,
    RPMCALLBACK_CPIO_ERROR = 16384,
    RPMCALLBACK_SCRIPT_ERROR = 32768,
    RPMCALLBACK_SCRIPT_START = 65536,
    RPMCALLBACK_SCRIPT_STOP = 131072,
    RPMCALLBACK_INST_STOP = 262144,
}
pub type rpmCallbackType = Enum_rpmCallbackType_e;
pub type rpmCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(h:
                                                   *const ::std::os::raw::c_void,
                                               what: rpmCallbackType,
                                               amount: rpm_loff_t,
                                               total: rpm_loff_t,
                                               key: fnpyKey,
                                               data: rpmCallbackData)
                              -> *mut ::std::os::raw::c_void>;
pub const RPMTRANS_FLAG_NOFILEDIGEST: Enum_rpmtransFlags_e =
    Enum_rpmtransFlags_e::RPMTRANS_FLAG_NOMD5;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmtransFlags_e {
    RPMTRANS_FLAG_NONE = 0,
    RPMTRANS_FLAG_TEST = 1,
    RPMTRANS_FLAG_BUILD_PROBS = 2,
    RPMTRANS_FLAG_NOSCRIPTS = 4,
    RPMTRANS_FLAG_JUSTDB = 8,
    RPMTRANS_FLAG_NOTRIGGERS = 16,
    RPMTRANS_FLAG_NODOCS = 32,
    RPMTRANS_FLAG_ALLFILES = 64,
    RPMTRANS_FLAG_NOPLUGINS = 128,
    RPMTRANS_FLAG_NOCONTEXTS = 256,
    RPMTRANS_FLAG_NOTRIGGERPREIN = 65536,
    RPMTRANS_FLAG_NOPRE = 131072,
    RPMTRANS_FLAG_NOPOST = 262144,
    RPMTRANS_FLAG_NOTRIGGERIN = 524288,
    RPMTRANS_FLAG_NOTRIGGERUN = 1048576,
    RPMTRANS_FLAG_NOPREUN = 2097152,
    RPMTRANS_FLAG_NOPOSTUN = 4194304,
    RPMTRANS_FLAG_NOTRIGGERPOSTUN = 8388608,
    RPMTRANS_FLAG_NOPRETRANS = 16777216,
    RPMTRANS_FLAG_NOPOSTTRANS = 33554432,
    RPMTRANS_FLAG_NOMD5 = 134217728,
    RPMTRANS_FLAG_NOCONFIGS = 1073741824,
    RPMTRANS_FLAG_DEPLOOPS = -2147483648,
}
pub type rpmtransFlags = rpmFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmVSFlags_e {
    RPMVSF_DEFAULT = 0,
    RPMVSF_NOHDRCHK = 1,
    RPMVSF_NEEDPAYLOAD = 2,
    RPMVSF_NOSHA1HEADER = 256,
    RPMVSF_NOMD5HEADER = 512,
    RPMVSF_NODSAHEADER = 1024,
    RPMVSF_NORSAHEADER = 2048,
    RPMVSF_NOSHA1 = 65536,
    RPMVSF_NOMD5 = 131072,
    RPMVSF_NODSA = 262144,
    RPMVSF_NORSA = 524288,
}
pub type rpmVSFlags = rpmFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmtsOpX_e {
    RPMTS_OP_TOTAL = 0,
    RPMTS_OP_CHECK = 1,
    RPMTS_OP_ORDER = 2,
    RPMTS_OP_FINGERPRINT = 3,
    RPMTS_OP_INSTALL = 5,
    RPMTS_OP_ERASE = 6,
    RPMTS_OP_SCRIPTLETS = 7,
    RPMTS_OP_COMPRESS = 8,
    RPMTS_OP_UNCOMPRESS = 9,
    RPMTS_OP_DIGEST = 10,
    RPMTS_OP_SIGNATURE = 11,
    RPMTS_OP_DBADD = 12,
    RPMTS_OP_DBREMOVE = 13,
    RPMTS_OP_DBGET = 14,
    RPMTS_OP_DBPUT = 15,
    RPMTS_OP_DBDEL = 16,
    RPMTS_OP_MAX = 17,
}
pub type rpmtsOpX = Enum_rpmtsOpX_e;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_rpmtxnFlags_e { RPMTXN_READ = 1, RPMTXN_WRITE = 2, }
pub type rpmtxnFlags = rpmFlags;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum__hy_nevra_param_e {
    HY_NEVRA_NAME = 0,
    HY_NEVRA_VERSION = 1,
    HY_NEVRA_RELEASE = 2,
    HY_NEVRA_ARCH = 3,
}
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum__hy_query_flags { HY_IGNORE_EXCLUDES = 1, }
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum__HyForm {
    HY_FORM_NEVRA = 1,
    HY_FORM_NEVR = 2,
    HY_FORM_NEV = 3,
    HY_FORM_NA = 4,
    HY_FORM_NAME = 5,
    _HY_FORM_STOP_ = -1,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__HyPossibilities {
    pub subject: HySubject,
    pub sack: *mut HifSack,
    pub flags: ::std::os::raw::c_int,
    pub forms: *mut HyForm,
    pub current: ::std::os::raw::c_int,
    pub _type: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct__HyPossibilities {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__HyPossibilities {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
pub type __va_list_tag = Struct___va_list_tag;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct___va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[link(name = "hif")]
#[link(name = "gobject-2.0")]
#[link(name = "repo")]
#[link(name = "glib-2.0")]
#[link(name = "rpm")]
#[link(name = "rpmio")]
#[link(name = "hawkey")]
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
    pub static mut __daylight: ::std::os::raw::c_int;
    pub static mut __timezone: ::std::os::raw::c_long;
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
    pub static mut daylight: ::std::os::raw::c_int;
    pub static mut timezone: ::std::os::raw::c_long;
    pub static mut _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 65usize];
    pub static mut g_mem_gc_friendly: gboolean;
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
    pub static mut g_timeout_funcs: GSourceFuncs;
    pub static mut g_child_watch_funcs: GSourceFuncs;
    pub static mut g_idle_funcs: GSourceFuncs;
    pub static mut g_unix_signal_funcs: GSourceFuncs;
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
    pub static g_utf8_skip: *const gchar;
    pub static mut g_io_watch_funcs: GSourceFuncs;
    pub static g_ascii_table: *const guint16;
    pub static g_test_config_vars: *const GTestConfig;
    pub static glib_major_version: guint;
    pub static glib_minor_version: guint;
    pub static glib_micro_version: guint;
    pub static glib_interface_age: guint;
    pub static glib_binary_age: guint;
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
    pub static mut g_thread_use_default_impl: gboolean;
    pub static mut g_thread_gettime:
               ::std::option::Option<extern "C" fn() -> guint64>;
    pub static mut g_threads_got_initialized: gboolean;
    pub static mut g_param_spec_types: *mut GType;
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
    pub static mut optarg: *mut ::std::os::raw::c_char;
    pub static mut optind: ::std::os::raw::c_int;
    pub static mut opterr: ::std::os::raw::c_int;
    pub static mut optopt: ::std::os::raw::c_int;
    pub static mut _IO_2_1_stdin_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stdout_: Struct__IO_FILE_plus;
    pub static mut _IO_2_1_stderr_: Struct__IO_FILE_plus;
    pub static mut stdin: *mut Struct__IO_FILE;
    pub static mut stdout: *mut Struct__IO_FILE;
    pub static mut stderr: *mut Struct__IO_FILE;
    pub static mut sys_nerr: ::std::os::raw::c_int;
    pub static mut sys_errlist: *const *const ::std::os::raw::c_char;
    pub static mut solv_version: *const ::std::os::raw::c_char;
    pub static mut solv_version_major: ::std::os::raw::c_int;
    pub static mut solv_version_minor: ::std::os::raw::c_int;
    pub static mut solv_version_patch: ::std::os::raw::c_int;
    pub static mut lr_interrupt: sig_atomic_t;
    pub static mut _rpmts_stats: ::std::os::raw::c_int;
    pub static mut HY_FORMS_MOST_SPEC: *mut HyForm;
    pub static mut HY_FORMS_REAL: *mut HyForm;
}
#[link(name = "hif")]
#[link(name = "gobject-2.0")]
#[link(name = "repo")]
#[link(name = "glib-2.0")]
#[link(name = "rpm")]
#[link(name = "rpmio")]
#[link(name = "hawkey")]
extern "C" {
    pub fn clock() -> clock_t;
    pub fn time(__timer: *mut time_t) -> time_t;
    pub fn difftime(__time1: time_t, __time0: time_t)
     -> ::std::os::raw::c_double;
    pub fn mktime(__tp: *mut Struct_tm) -> time_t;
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: size_t,
                    __format: *const ::std::os::raw::c_char,
                    __tp: *const Struct_tm) -> size_t;
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: size_t,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const Struct_tm, __loc: __locale_t) -> size_t;
    pub fn gmtime(__timer: *const time_t) -> *mut Struct_tm;
    pub fn localtime(__timer: *const time_t) -> *mut Struct_tm;
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut Struct_tm)
     -> *mut Struct_tm;
    pub fn localtime_r(__timer: *const time_t, __tp: *mut Struct_tm)
     -> *mut Struct_tm;
    pub fn asctime(__tp: *const Struct_tm) -> *mut ::std::os::raw::c_char;
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
    pub fn asctime_r(__tp: *const Struct_tm,
                     __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tzset();
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
    pub fn timegm(__tp: *mut Struct_tm) -> time_t;
    pub fn timelocal(__tp: *mut Struct_tm) -> time_t;
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn nanosleep(__requested_time: *const Struct_timespec,
                     __remaining: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const Struct_timespec,
                           __rem: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::std::os::raw::c_int;
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut Struct_sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const Struct_itimerspec,
                         __ovalue: *mut Struct_itimerspec)
     -> ::std::os::raw::c_int;
    pub fn timer_gettime(__timerid: timer_t, __value: *mut Struct_itimerspec)
     -> ::std::os::raw::c_int;
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
    pub fn timespec_get(__ts: *mut Struct_timespec,
                        __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn g_array_new(zero_terminated: gboolean, clear_: gboolean,
                       element_size: guint) -> *mut GArray;
    pub fn g_array_sized_new(zero_terminated: gboolean, clear_: gboolean,
                             element_size: guint, reserved_size: guint)
     -> *mut GArray;
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean)
     -> *mut gchar;
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
    pub fn g_array_unref(array: *mut GArray);
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer,
                               len: guint) -> *mut GArray;
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer,
                                len: guint) -> *mut GArray;
    pub fn g_array_insert_vals(array: *mut GArray, index_: guint,
                               data: gconstpointer, len: guint)
     -> *mut GArray;
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
    pub fn g_array_remove_index(array: *mut GArray, index_: guint)
     -> *mut GArray;
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint)
     -> *mut GArray;
    pub fn g_array_remove_range(array: *mut GArray, index_: guint,
                                length: guint) -> *mut GArray;
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
    pub fn g_array_sort_with_data(array: *mut GArray,
                                  compare_func: GCompareDataFunc,
                                  user_data: gpointer);
    pub fn g_array_set_clear_func(array: *mut GArray,
                                  clear_func: GDestroyNotify);
    pub fn g_ptr_array_new() -> *mut GPtrArray;
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify)
     -> *mut GPtrArray;
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
    pub fn g_ptr_array_new_full(reserved_size: guint,
                                element_free_func: GDestroyNotify)
     -> *mut GPtrArray;
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean)
     -> *mut gpointer;
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray,
                                     element_free_func: GDestroyNotify);
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint)
     -> gpointer;
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint)
     -> gpointer;
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer)
     -> gboolean;
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer)
     -> gboolean;
    pub fn g_ptr_array_remove_range(array: *mut GPtrArray, index_: guint,
                                    length: guint) -> *mut GPtrArray;
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint,
                              data: gpointer);
    pub fn g_ptr_array_sort(array: *mut GPtrArray,
                            compare_func: GCompareFunc);
    pub fn g_ptr_array_sort_with_data(array: *mut GPtrArray,
                                      compare_func: GCompareDataFunc,
                                      user_data: gpointer);
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc,
                               user_data: gpointer);
    pub fn g_byte_array_new() -> *mut GByteArray;
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize)
     -> *mut GByteArray;
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean)
     -> *mut guint8;
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
    pub fn g_byte_array_unref(array: *mut GByteArray);
    pub fn g_byte_array_append(array: *mut GByteArray, data: *const guint8,
                               len: guint) -> *mut GByteArray;
    pub fn g_byte_array_prepend(array: *mut GByteArray, data: *const guint8,
                                len: guint) -> *mut GByteArray;
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint)
     -> *mut GByteArray;
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint)
     -> *mut GByteArray;
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray,
                                          index_: guint) -> *mut GByteArray;
    pub fn g_byte_array_remove_range(array: *mut GByteArray, index_: guint,
                                     length: guint) -> *mut GByteArray;
    pub fn g_byte_array_sort(array: *mut GByteArray,
                             compare_func: GCompareFunc);
    pub fn g_byte_array_sort_with_data(array: *mut GByteArray,
                                       compare_func: GCompareDataFunc,
                                       user_data: gpointer);
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
    pub fn g_atomic_int_inc(atomic: *mut gint);
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
    pub fn g_atomic_int_compare_and_exchange(atomic: *mut gint, oldval: gint,
                                             newval: gint) -> gboolean;
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void)
     -> gpointer;
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void,
                                newval: gpointer);
    pub fn g_atomic_pointer_compare_and_exchange(atomic:
                                                     *mut ::std::os::raw::c_void,
                                                 oldval: gpointer,
                                                 newval: gpointer)
     -> gboolean;
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void,
                                val: gssize) -> gssize;
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void,
                                val: gsize) -> gsize;
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void,
                               val: gsize) -> gsize;
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void,
                                val: gsize) -> gsize;
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint)
     -> gint;
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...)
     -> *mut GError;
    pub fn g_error_new_literal(domain: GQuark, code: gint,
                               message: *const gchar) -> *mut GError;
    pub fn g_error_new_valist(domain: GQuark, code: gint,
                              format: *const gchar, args: va_list)
     -> *mut GError;
    pub fn g_error_free(error: *mut GError);
    pub fn g_error_copy(error: *const GError) -> *mut GError;
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint)
     -> gboolean;
    pub fn g_set_error(err: *mut *mut GError, domain: GQuark, code: gint,
                       format: *const gchar, ...);
    pub fn g_set_error_literal(err: *mut *mut GError, domain: GQuark,
                               code: gint, message: *const gchar);
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
    pub fn g_clear_error(err: *mut *mut GError);
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
    pub fn g_propagate_prefixed_error(dest: *mut *mut GError,
                                      src: *mut GError,
                                      format: *const gchar, ...);
    pub fn g_get_user_name() -> *const gchar;
    pub fn g_get_real_name() -> *const gchar;
    pub fn g_get_home_dir() -> *const gchar;
    pub fn g_get_tmp_dir() -> *const gchar;
    pub fn g_get_host_name() -> *const gchar;
    pub fn g_get_prgname() -> *const gchar;
    pub fn g_set_prgname(prgname: *const gchar);
    pub fn g_get_application_name() -> *const gchar;
    pub fn g_set_application_name(application_name: *const gchar);
    pub fn g_reload_user_special_dirs_cache();
    pub fn g_get_user_data_dir() -> *const gchar;
    pub fn g_get_user_config_dir() -> *const gchar;
    pub fn g_get_user_cache_dir() -> *const gchar;
    pub fn g_get_system_data_dirs() -> *const *const gchar;
    pub fn g_get_system_config_dirs() -> *const *const gchar;
    pub fn g_get_user_runtime_dir() -> *const gchar;
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
    pub fn g_parse_debug_string(string: *const gchar, keys: *const GDebugKey,
                                nkeys: guint) -> guint;
    pub fn g_snprintf(string: *mut gchar, n: gulong,
                      format: *const gchar, ...) -> gint;
    pub fn g_vsnprintf(string: *mut gchar, n: gulong, format: *const gchar,
                       args: va_list) -> gint;
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags)
     -> *mut gchar;
    pub fn g_format_size(size: guint64) -> *mut gchar;
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
    pub fn g_atexit(func: GVoidFunc);
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
    pub fn g_thread_error_quark() -> GQuark;
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
    pub fn g_thread_unref(thread: *mut GThread);
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer)
     -> *mut GThread;
    pub fn g_thread_try_new(name: *const gchar, func: GThreadFunc,
                            data: gpointer, error: *mut *mut GError)
     -> *mut GThread;
    pub fn g_thread_self() -> *mut GThread;
    pub fn g_thread_exit(retval: gpointer);
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
    pub fn g_thread_yield();
    pub fn g_mutex_init(mutex: *mut GMutex);
    pub fn g_mutex_clear(mutex: *mut GMutex);
    pub fn g_mutex_lock(mutex: *mut GMutex);
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
    pub fn g_mutex_unlock(mutex: *mut GMutex);
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
    pub fn g_cond_init(cond: *mut GCond);
    pub fn g_cond_clear(cond: *mut GCond);
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
    pub fn g_cond_signal(cond: *mut GCond);
    pub fn g_cond_broadcast(cond: *mut GCond);
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex,
                             end_time: gint64) -> gboolean;
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer)
     -> gpointer;
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void)
     -> gboolean;
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void,
                             result: gsize);
    pub fn g_get_num_processors() -> guint;
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify)
     -> *mut GAsyncQueue;
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue,
                                       data: gpointer);
    pub fn g_async_queue_push_sorted(queue: *mut GAsyncQueue, data: gpointer,
                                     func: GCompareDataFunc,
                                     user_data: gpointer);
    pub fn g_async_queue_push_sorted_unlocked(queue: *mut GAsyncQueue,
                                              data: gpointer,
                                              func: GCompareDataFunc,
                                              user_data: gpointer);
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue)
     -> gpointer;
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue,
                                     timeout: guint64) -> gpointer;
    pub fn g_async_queue_timeout_pop_unlocked(queue: *mut GAsyncQueue,
                                              timeout: guint64) -> gpointer;
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc,
                              user_data: gpointer);
    pub fn g_async_queue_sort_unlocked(queue: *mut GAsyncQueue,
                                       func: GCompareDataFunc,
                                       user_data: gpointer);
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer)
     -> gboolean;
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue,
                                         item: gpointer) -> gboolean;
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue,
                                             item: gpointer);
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue,
                                   end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timed_pop_unlocked(queue: *mut GAsyncQueue,
                                            end_time: *mut GTimeVal)
     -> gpointer;
    pub fn __sigismember(arg1: *const __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn __sigaddset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn __sigdelset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int,
                         __handler: __sighandler_t) -> __sighandler_t;
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn psignal(__sig: ::std::os::raw::c_int,
                   __s: *const ::std::os::raw::c_char);
    pub fn psiginfo(__pinfo: *const siginfo_t,
                    __s: *const ::std::os::raw::c_char);
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn siggetmask() -> ::std::os::raw::c_int;
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigismember(__set: *const sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigprocmask(__how: ::std::os::raw::c_int, __set: *const sigset_t,
                       __oset: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
    pub fn sigaction(__sig: ::std::os::raw::c_int,
                     __act: *const Struct_sigaction,
                     __oact: *mut Struct_sigaction) -> ::std::os::raw::c_int;
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t)
     -> ::std::os::raw::c_int;
    pub fn sigtimedwait(__set: *const sigset_t, __info: *mut siginfo_t,
                        __timeout: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn sigqueue(__pid: __pid_t, __sig: ::std::os::raw::c_int,
                    __val: Union_sigval) -> ::std::os::raw::c_int;
    pub fn sigreturn(__scp: *mut Struct_sigcontext) -> ::std::os::raw::c_int;
    pub fn siginterrupt(__sig: ::std::os::raw::c_int,
                        __interrupt: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigstack(__ss: *mut Struct_sigstack, __oss: *mut Struct_sigstack)
     -> ::std::os::raw::c_int;
    pub fn sigaltstack(__ss: *const Struct_sigaltstack,
                       __oss: *mut Struct_sigaltstack)
     -> ::std::os::raw::c_int;
    pub fn pthread_sigmask(__how: ::std::os::raw::c_int,
                           __newmask: *const __sigset_t,
                           __oldmask: *mut __sigset_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
    pub fn g_on_error_query(prg_name: *const gchar);
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
    pub fn g_base64_encode_step(_in: *const guchar, len: gsize,
                                break_lines: gboolean, out: *mut gchar,
                                state: *mut gint, save: *mut gint) -> gsize;
    pub fn g_base64_encode_close(break_lines: gboolean, out: *mut gchar,
                                 state: *mut gint, save: *mut gint) -> gsize;
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
    pub fn g_base64_decode_step(_in: *const gchar, len: gsize,
                                out: *mut guchar, state: *mut gint,
                                save: *mut guint) -> gsize;
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize)
     -> *mut guchar;
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize)
     -> *mut guchar;
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void,
                              lock_bit: gint);
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void,
                                 lock_bit: gint) -> gboolean;
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void,
                                lock_bit: gint);
    pub fn g_bookmark_file_error_quark() -> GQuark;
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
    pub fn g_bookmark_file_load_from_file(bookmark: *mut GBookmarkFile,
                                          filename: *const gchar,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_load_from_data(bookmark: *mut GBookmarkFile,
                                          data: *const gchar, length: gsize,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_load_from_data_dirs(bookmark: *mut GBookmarkFile,
                                               file: *const gchar,
                                               full_path: *mut *mut gchar,
                                               error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_to_data(bookmark: *mut GBookmarkFile,
                                   length: *mut gsize,
                                   error: *mut *mut GError) -> *mut gchar;
    pub fn g_bookmark_file_to_file(bookmark: *mut GBookmarkFile,
                                   filename: *const gchar,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_title(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar, title: *const gchar);
    pub fn g_bookmark_file_get_title(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar,
                                     error: *mut *mut GError) -> *mut gchar;
    pub fn g_bookmark_file_set_description(bookmark: *mut GBookmarkFile,
                                           uri: *const gchar,
                                           description: *const gchar);
    pub fn g_bookmark_file_get_description(bookmark: *mut GBookmarkFile,
                                           uri: *const gchar,
                                           error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_bookmark_file_set_mime_type(bookmark: *mut GBookmarkFile,
                                         uri: *const gchar,
                                         mime_type: *const gchar);
    pub fn g_bookmark_file_get_mime_type(bookmark: *mut GBookmarkFile,
                                         uri: *const gchar,
                                         error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_bookmark_file_set_groups(bookmark: *mut GBookmarkFile,
                                      uri: *const gchar,
                                      groups: *mut *const gchar,
                                      length: gsize);
    pub fn g_bookmark_file_add_group(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar, group: *const gchar);
    pub fn g_bookmark_file_has_group(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar, group: *const gchar,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_groups(bookmark: *mut GBookmarkFile,
                                      uri: *const gchar, length: *mut gsize,
                                      error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_bookmark_file_add_application(bookmark: *mut GBookmarkFile,
                                           uri: *const gchar,
                                           name: *const gchar,
                                           exec: *const gchar);
    pub fn g_bookmark_file_has_application(bookmark: *mut GBookmarkFile,
                                           uri: *const gchar,
                                           name: *const gchar,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_get_applications(bookmark: *mut GBookmarkFile,
                                            uri: *const gchar,
                                            length: *mut gsize,
                                            error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_bookmark_file_set_app_info(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar, name: *const gchar,
                                        exec: *const gchar, count: gint,
                                        stamp: time_t,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_get_app_info(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar, name: *const gchar,
                                        exec: *mut *mut gchar,
                                        count: *mut guint, stamp: *mut time_t,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_is_private(bookmark: *mut GBookmarkFile,
                                          uri: *const gchar,
                                          is_private: gboolean);
    pub fn g_bookmark_file_get_is_private(bookmark: *mut GBookmarkFile,
                                          uri: *const gchar,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_set_icon(bookmark: *mut GBookmarkFile,
                                    uri: *const gchar, href: *const gchar,
                                    mime_type: *const gchar);
    pub fn g_bookmark_file_get_icon(bookmark: *mut GBookmarkFile,
                                    uri: *const gchar, href: *mut *mut gchar,
                                    mime_type: *mut *mut gchar,
                                    error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_set_added(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar, added: time_t);
    pub fn g_bookmark_file_get_added(bookmark: *mut GBookmarkFile,
                                     uri: *const gchar,
                                     error: *mut *mut GError) -> time_t;
    pub fn g_bookmark_file_set_modified(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar, modified: time_t);
    pub fn g_bookmark_file_get_modified(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar,
                                        error: *mut *mut GError) -> time_t;
    pub fn g_bookmark_file_set_visited(bookmark: *mut GBookmarkFile,
                                       uri: *const gchar, visited: time_t);
    pub fn g_bookmark_file_get_visited(bookmark: *mut GBookmarkFile,
                                       uri: *const gchar,
                                       error: *mut *mut GError) -> time_t;
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile,
                                    uri: *const gchar) -> gboolean;
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
    pub fn g_bookmark_file_get_uris(bookmark: *mut GBookmarkFile,
                                    length: *mut gsize) -> *mut *mut gchar;
    pub fn g_bookmark_file_remove_group(bookmark: *mut GBookmarkFile,
                                        uri: *const gchar,
                                        group: *const gchar,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_remove_application(bookmark: *mut GBookmarkFile,
                                              uri: *const gchar,
                                              name: *const gchar,
                                              error: *mut *mut GError)
     -> gboolean;
    pub fn g_bookmark_file_remove_item(bookmark: *mut GBookmarkFile,
                                       uri: *const gchar,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_bookmark_file_move_item(bookmark: *mut GBookmarkFile,
                                     old_uri: *const gchar,
                                     new_uri: *const gchar,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize)
     -> *mut GBytes;
    pub fn g_bytes_new_with_free_func(data: gconstpointer, size: gsize,
                                      free_func: GDestroyNotify,
                                      user_data: gpointer) -> *mut GBytes;
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize,
                                  length: gsize) -> *mut GBytes;
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize)
     -> gconstpointer;
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
    pub fn g_bytes_unref(bytes: *mut GBytes);
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize)
     -> gpointer;
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer)
     -> gboolean;
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer)
     -> gint;
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char)
     -> gboolean;
    pub fn g_get_codeset() -> *mut gchar;
    pub fn g_get_language_names() -> *const *const gchar;
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
    pub fn g_checksum_reset(checksum: *mut GChecksum);
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
    pub fn g_checksum_free(checksum: *mut GChecksum);
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar,
                             length: gssize);
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
    pub fn g_checksum_get_digest(checksum: *mut GChecksum,
                                 buffer: *mut guint8, digest_len: *mut gsize);
    pub fn g_compute_checksum_for_data(checksum_type: GChecksumType,
                                       data: *const guchar, length: gsize)
     -> *mut gchar;
    pub fn g_compute_checksum_for_string(checksum_type: GChecksumType,
                                         str: *const gchar, length: gssize)
     -> *mut gchar;
    pub fn g_compute_checksum_for_bytes(checksum_type: GChecksumType,
                                        data: *mut GBytes) -> *mut gchar;
    pub fn g_convert_error_quark() -> GQuark;
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar)
     -> GIConv;
    pub fn g_iconv(converter: GIConv, inbuf: *mut *mut gchar,
                   inbytes_left: *mut gsize, outbuf: *mut *mut gchar,
                   outbytes_left: *mut gsize) -> gsize;
    pub fn g_iconv_close(converter: GIConv) -> gint;
    pub fn g_convert(str: *const gchar, len: gssize, to_codeset: *const gchar,
                     from_codeset: *const gchar, bytes_read: *mut gsize,
                     bytes_written: *mut gsize, error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_convert_with_iconv(str: *const gchar, len: gssize,
                                converter: GIConv, bytes_read: *mut gsize,
                                bytes_written: *mut gsize,
                                error: *mut *mut GError) -> *mut gchar;
    pub fn g_convert_with_fallback(str: *const gchar, len: gssize,
                                   to_codeset: *const gchar,
                                   from_codeset: *const gchar,
                                   fallback: *const gchar,
                                   bytes_read: *mut gsize,
                                   bytes_written: *mut gsize,
                                   error: *mut *mut GError) -> *mut gchar;
    pub fn g_locale_to_utf8(opsysstring: *const gchar, len: gssize,
                            bytes_read: *mut gsize, bytes_written: *mut gsize,
                            error: *mut *mut GError) -> *mut gchar;
    pub fn g_locale_from_utf8(utf8string: *const gchar, len: gssize,
                              bytes_read: *mut gsize,
                              bytes_written: *mut gsize,
                              error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_to_utf8(opsysstring: *const gchar, len: gssize,
                              bytes_read: *mut gsize,
                              bytes_written: *mut gsize,
                              error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_from_utf8(utf8string: *const gchar, len: gssize,
                                bytes_read: *mut gsize,
                                bytes_written: *mut gsize,
                                error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_from_uri(uri: *const gchar, hostname: *mut *mut gchar,
                               error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_to_uri(filename: *const gchar, hostname: *const gchar,
                             error: *mut *mut GError) -> *mut gchar;
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
    pub fn g_get_filename_charsets(charsets: *mut *mut *const gchar)
     -> gboolean;
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
    pub fn g_datalist_init(datalist: *mut *mut GData);
    pub fn g_datalist_clear(datalist: *mut *mut GData);
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark)
     -> gpointer;
    pub fn g_datalist_id_set_data_full(datalist: *mut *mut GData,
                                       key_id: GQuark, data: gpointer,
                                       destroy_func: GDestroyNotify);
    pub fn g_datalist_id_dup_data(datalist: *mut *mut GData, key_id: GQuark,
                                  dup_func: GDuplicateFunc,
                                  user_data: gpointer) -> gpointer;
    pub fn g_datalist_id_replace_data(datalist: *mut *mut GData,
                                      key_id: GQuark, oldval: gpointer,
                                      newval: gpointer,
                                      destroy: GDestroyNotify,
                                      old_destroy: *mut GDestroyNotify)
     -> gboolean;
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData,
                                          key_id: GQuark) -> gpointer;
    pub fn g_datalist_foreach(datalist: *mut *mut GData,
                              func: GDataForeachFunc, user_data: gpointer);
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer,
                                 key_id: GQuark) -> gpointer;
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar)
     -> gpointer;
    pub fn g_dataset_id_set_data_full(dataset_location: gconstpointer,
                                      key_id: GQuark, data: gpointer,
                                      destroy_func: GDestroyNotify);
    pub fn g_dataset_id_remove_no_notify(dataset_location: gconstpointer,
                                         key_id: GQuark) -> gpointer;
    pub fn g_dataset_foreach(dataset_location: gconstpointer,
                             func: GDataForeachFunc, user_data: gpointer);
    pub fn g_date_new() -> *mut GDate;
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear)
     -> *mut GDate;
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
    pub fn g_date_free(date: *mut GDate);
    pub fn g_date_valid(date: *const GDate) -> gboolean;
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear)
     -> gboolean;
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
    pub fn g_date_set_parse(date: *mut GDate, str: *const gchar);
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth,
                          y: GDateYear);
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear)
     -> guint8;
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate)
     -> gint;
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut Struct_tm);
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate,
                        max_date: *const GDate);
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
    pub fn g_date_strftime(s: *mut gchar, slen: gsize, format: *const gchar,
                           date: *const GDate) -> gsize;
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, _type: GTimeType,
                                     time_: gint64) -> gint;
    pub fn g_time_zone_adjust_time(tz: *mut GTimeZone, _type: GTimeType,
                                   time_: *mut gint64) -> gint;
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint)
     -> *const gchar;
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint)
     -> gint32;
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
    pub fn g_date_time_unref(datetime: *mut GDateTime);
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal)
     -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal)
     -> *mut GDateTime;
    pub fn g_date_time_new(tz: *mut GTimeZone, year: gint, month: gint,
                           day: gint, hour: gint, minute: gint,
                           seconds: gdouble) -> *mut GDateTime;
    pub fn g_date_time_new_local(year: gint, month: gint, day: gint,
                                 hour: gint, minute: gint, seconds: gdouble)
     -> *mut GDateTime;
    pub fn g_date_time_new_utc(year: gint, month: gint, day: gint, hour: gint,
                               minute: gint, seconds: gdouble)
     -> *mut GDateTime;
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan)
     -> *mut GDateTime;
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint)
     -> *mut GDateTime;
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble)
     -> *mut GDateTime;
    pub fn g_date_time_add_full(datetime: *mut GDateTime, years: gint,
                                months: gint, days: gint, hours: gint,
                                minutes: gint, seconds: gdouble)
     -> *mut GDateTime;
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer)
     -> gint;
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime)
     -> GTimeSpan;
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer)
     -> gboolean;
    pub fn g_date_time_get_ymd(datetime: *mut GDateTime, year: *mut gint,
                               month: *mut gint, day: *mut gint);
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime)
     -> gint;
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal)
     -> gboolean;
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime)
     -> *const gchar;
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime)
     -> gboolean;
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime,
                                   tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar)
     -> *mut gchar;
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
    pub fn readdir(__dirp: *mut DIR) -> *mut Struct_dirent;
    pub fn readdir_r(__dirp: *mut DIR, __entry: *mut Struct_dirent,
                     __result: *mut *mut Struct_dirent)
     -> ::std::os::raw::c_int;
    pub fn rewinddir(__dirp: *mut DIR);
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
    pub fn scandir(__dir: *const ::std::os::raw::c_char,
                   __namelist: *mut *mut *mut Struct_dirent,
                   __selector:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const Struct_dirent)
                                                 -> ::std::os::raw::c_int>,
                   __cmp:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut *const Struct_dirent,
                                                                  arg2:
                                                                      *mut *const Struct_dirent)
                                                 -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
    pub fn alphasort(__e1: *mut *const Struct_dirent,
                     __e2: *mut *const Struct_dirent)
     -> ::std::os::raw::c_int;
    pub fn getdirentries(__fd: ::std::os::raw::c_int,
                         __buf: *mut ::std::os::raw::c_char, __nbytes: size_t,
                         __basep: *mut __off_t) -> __ssize_t;
    pub fn g_dir_open(path: *const gchar, flags: guint,
                      error: *mut *mut GError) -> *mut GDir;
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
    pub fn g_dir_rewind(dir: *mut GDir);
    pub fn g_dir_close(dir: *mut GDir);
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
    pub fn g_setenv(variable: *const gchar, value: *const gchar,
                    overwrite: gboolean) -> gboolean;
    pub fn g_unsetenv(variable: *const gchar);
    pub fn g_listenv() -> *mut *mut gchar;
    pub fn g_get_environ() -> *mut *mut gchar;
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar)
     -> *const gchar;
    pub fn g_environ_setenv(envp: *mut *mut gchar, variable: *const gchar,
                            value: *const gchar, overwrite: gboolean)
     -> *mut *mut gchar;
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar)
     -> *mut *mut gchar;
    pub fn g_file_error_quark() -> GQuark;
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
    pub fn g_file_get_contents(filename: *const gchar,
                               contents: *mut *mut gchar, length: *mut gsize,
                               error: *mut *mut GError) -> gboolean;
    pub fn g_file_set_contents(filename: *const gchar, contents: *const gchar,
                               length: gssize, error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
    pub fn g_file_open_tmp(tmpl: *const gchar, name_used: *mut *mut gchar,
                           error: *mut *mut GError) -> gint;
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_build_path(separator: *const gchar,
                        first_element: *const gchar, ...) -> *mut gchar;
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar)
     -> *mut gchar;
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
    pub fn g_get_current_dir() -> *mut gchar;
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar)
     -> *const gchar;
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar)
     -> *const gchar;
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar,
                       category: gint) -> *const gchar;
    pub fn g_dngettext(domain: *const gchar, msgid: *const gchar,
                       msgid_plural: *const gchar, n: gulong) -> *const gchar;
    pub fn g_dpgettext(domain: *const gchar, msgctxtid: *const gchar,
                       msgidoffset: gsize) -> *const gchar;
    pub fn g_dpgettext2(domain: *const gchar, context: *const gchar,
                        msgid: *const gchar) -> *const gchar;
    pub fn g_free(mem: gpointer);
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize)
     -> gpointer;
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize,
                           n_block_bytes: gsize) -> gpointer;
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
    pub fn g_mem_is_system_malloc() -> gboolean;
    pub fn g_mem_profile();
    pub fn g_node_new(data: gpointer) -> *mut GNode;
    pub fn g_node_destroy(root: *mut GNode);
    pub fn g_node_unlink(node: *mut GNode);
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc,
                            data: gpointer) -> *mut GNode;
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode)
     -> *mut GNode;
    pub fn g_node_insert_before(parent: *mut GNode, sibling: *mut GNode,
                                node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_after(parent: *mut GNode, sibling: *mut GNode,
                               node: *mut GNode) -> *mut GNode;
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode)
     -> gboolean;
    pub fn g_node_depth(node: *mut GNode) -> guint;
    pub fn g_node_find(root: *mut GNode, order: GTraverseType,
                       flags: GTraverseFlags, data: gpointer) -> *mut GNode;
    pub fn g_node_traverse(root: *mut GNode, order: GTraverseType,
                           flags: GTraverseFlags, max_depth: gint,
                           func: GNodeTraverseFunc, data: gpointer);
    pub fn g_node_max_height(root: *mut GNode) -> guint;
    pub fn g_node_children_foreach(node: *mut GNode, flags: GTraverseFlags,
                                   func: GNodeForeachFunc, data: gpointer);
    pub fn g_node_reverse_children(node: *mut GNode);
    pub fn g_node_n_children(node: *mut GNode) -> guint;
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags,
                             data: gpointer) -> *mut GNode;
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_list_alloc() -> *mut GList;
    pub fn g_list_free(list: *mut GList);
    pub fn g_list_free_1(list: *mut GList);
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint)
     -> *mut GList;
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer,
                                func: GCompareFunc) -> *mut GList;
    pub fn g_list_insert_sorted_with_data(list: *mut GList, data: gpointer,
                                          func: GCompareDataFunc,
                                          user_data: gpointer) -> *mut GList;
    pub fn g_list_insert_before(list: *mut GList, sibling: *mut GList,
                                data: gpointer) -> *mut GList;
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer)
     -> *mut GList;
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList)
     -> *mut GList;
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList)
     -> *mut GList;
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc,
                            user_data: gpointer) -> *mut GList;
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_find_custom(list: *mut GList, data: gconstpointer,
                              func: GCompareFunc) -> *mut GList;
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
    pub fn g_list_last(list: *mut GList) -> *mut GList;
    pub fn g_list_first(list: *mut GList) -> *mut GList;
    pub fn g_list_length(list: *mut GList) -> guint;
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc)
     -> *mut GList;
    pub fn g_list_sort_with_data(list: *mut GList,
                                 compare_func: GCompareDataFunc,
                                 user_data: gpointer) -> *mut GList;
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc)
     -> *mut GHashTable;
    pub fn g_hash_table_new_full(hash_func: GHashFunc,
                                 key_equal_func: GEqualFunc,
                                 key_destroy_func: GDestroyNotify,
                                 value_destroy_func: GDestroyNotify)
     -> *mut GHashTable;
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
    pub fn g_hash_table_insert(hash_table: *mut GHashTable, key: gpointer,
                               value: gpointer) -> gboolean;
    pub fn g_hash_table_replace(hash_table: *mut GHashTable, key: gpointer,
                                value: gpointer) -> gboolean;
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer)
     -> gboolean;
    pub fn g_hash_table_remove(hash_table: *mut GHashTable,
                               key: gconstpointer) -> gboolean;
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer)
     -> gboolean;
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable,
                               key: gconstpointer) -> gpointer;
    pub fn g_hash_table_contains(hash_table: *mut GHashTable,
                                 key: gconstpointer) -> gboolean;
    pub fn g_hash_table_lookup_extended(hash_table: *mut GHashTable,
                                        lookup_key: gconstpointer,
                                        orig_key: *mut gpointer,
                                        value: *mut gpointer) -> gboolean;
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc,
                                user_data: gpointer);
    pub fn g_hash_table_find(hash_table: *mut GHashTable, predicate: GHRFunc,
                             user_data: gpointer) -> gpointer;
    pub fn g_hash_table_foreach_remove(hash_table: *mut GHashTable,
                                       func: GHRFunc, user_data: gpointer)
     -> guint;
    pub fn g_hash_table_foreach_steal(hash_table: *mut GHashTable,
                                      func: GHRFunc, user_data: gpointer)
     -> guint;
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_get_keys_as_array(hash_table: *mut GHashTable,
                                          length: *mut guint)
     -> *mut gpointer;
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter,
                                  hash_table: *mut GHashTable);
    pub fn g_hash_table_iter_next(iter: *mut GHashTableIter,
                                  key: *mut gpointer, value: *mut gpointer)
     -> gboolean;
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter)
     -> *mut GHashTable;
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter,
                                     value: gpointer);
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_str_hash(v: gconstpointer) -> guint;
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int_hash(v: gconstpointer) -> guint;
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int64_hash(v: gconstpointer) -> guint;
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_double_hash(v: gconstpointer) -> guint;
    pub fn g_direct_hash(v: gconstpointer) -> guint;
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar,
                      key_len: gsize) -> *mut GHmac;
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
    pub fn g_hmac_unref(hmac: *mut GHmac);
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar,
                         length: gssize);
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8,
                             digest_len: *mut gsize);
    pub fn g_compute_hmac_for_data(digest_type: GChecksumType,
                                   key: *const guchar, key_len: gsize,
                                   data: *const guchar, length: gsize)
     -> *mut gchar;
    pub fn g_compute_hmac_for_string(digest_type: GChecksumType,
                                     key: *const guchar, key_len: gsize,
                                     str: *const gchar, length: gssize)
     -> *mut gchar;
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook)
     -> *mut GHook;
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong)
     -> gboolean;
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_insert_before(hook_list: *mut GHookList,
                                sibling: *mut GHook, hook: *mut GHook);
    pub fn g_hook_insert_sorted(hook_list: *mut GHookList, hook: *mut GHook,
                                func: GHookCompareFunc);
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong)
     -> *mut GHook;
    pub fn g_hook_find(hook_list: *mut GHookList, need_valids: gboolean,
                       func: GHookFindFunc, data: gpointer) -> *mut GHook;
    pub fn g_hook_find_data(hook_list: *mut GHookList, need_valids: gboolean,
                            data: gpointer) -> *mut GHook;
    pub fn g_hook_find_func(hook_list: *mut GHookList, need_valids: gboolean,
                            func: gpointer) -> *mut GHook;
    pub fn g_hook_find_func_data(hook_list: *mut GHookList,
                                 need_valids: gboolean, func: gpointer,
                                 data: gpointer) -> *mut GHook;
    pub fn g_hook_first_valid(hook_list: *mut GHookList,
                              may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_next_valid(hook_list: *mut GHookList, hook: *mut GHook,
                             may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook)
     -> gint;
    pub fn g_hook_list_invoke(hook_list: *mut GHookList,
                              may_recurse: gboolean);
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList,
                                    may_recurse: gboolean);
    pub fn g_hook_list_marshal(hook_list: *mut GHookList,
                               may_recurse: gboolean,
                               marshaller: GHookMarshaller,
                               marshal_data: gpointer);
    pub fn g_hook_list_marshal_check(hook_list: *mut GHookList,
                                     may_recurse: gboolean,
                                     marshaller: GHookCheckMarshaller,
                                     marshal_data: gpointer);
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
    pub fn g_slist_alloc() -> *mut GSList;
    pub fn g_slist_free(list: *mut GSList);
    pub fn g_slist_free_1(list: *mut GSList);
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint)
     -> *mut GSList;
    pub fn g_slist_insert_sorted(list: *mut GSList, data: gpointer,
                                 func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_insert_sorted_with_data(list: *mut GSList, data: gpointer,
                                           func: GCompareDataFunc,
                                           user_data: gpointer)
     -> *mut GSList;
    pub fn g_slist_insert_before(slist: *mut GSList, sibling: *mut GSList,
                                 data: gpointer) -> *mut GSList;
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList)
     -> *mut GSList;
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer)
     -> *mut GSList;
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer)
     -> *mut GSList;
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList)
     -> *mut GSList;
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList)
     -> *mut GSList;
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy_deep(list: *mut GSList, func: GCopyFunc,
                             user_data: gpointer) -> *mut GSList;
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer)
     -> *mut GSList;
    pub fn g_slist_find_custom(list: *mut GSList, data: gconstpointer,
                               func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_length(list: *mut GSList) -> guint;
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc,
                           user_data: gpointer);
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc)
     -> *mut GSList;
    pub fn g_slist_sort_with_data(list: *mut GSList,
                                  compare_func: GCompareDataFunc,
                                  user_data: gpointer) -> *mut GSList;
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
    pub fn g_main_context_new() -> *mut GMainContext;
    pub fn g_main_context_ref(context: *mut GMainContext)
     -> *mut GMainContext;
    pub fn g_main_context_unref(context: *mut GMainContext);
    pub fn g_main_context_default() -> *mut GMainContext;
    pub fn g_main_context_iteration(context: *mut GMainContext,
                                    may_block: gboolean) -> gboolean;
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_find_source_by_id(context: *mut GMainContext,
                                            source_id: guint) -> *mut GSource;
    pub fn g_main_context_find_source_by_user_data(context: *mut GMainContext,
                                                   user_data: gpointer)
     -> *mut GSource;
    pub fn g_main_context_find_source_by_funcs_user_data(context:
                                                             *mut GMainContext,
                                                         funcs:
                                                             *mut GSourceFuncs,
                                                         user_data: gpointer)
     -> *mut GSource;
    pub fn g_main_context_wakeup(context: *mut GMainContext);
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_release(context: *mut GMainContext);
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_wait(context: *mut GMainContext, cond: *mut GCond,
                               mutex: *mut GMutex) -> gboolean;
    pub fn g_main_context_prepare(context: *mut GMainContext,
                                  priority: *mut gint) -> gboolean;
    pub fn g_main_context_query(context: *mut GMainContext,
                                max_priority: gint, timeout_: *mut gint,
                                fds: *mut GPollFD, n_fds: gint) -> gint;
    pub fn g_main_context_check(context: *mut GMainContext,
                                max_priority: gint, fds: *mut GPollFD,
                                n_fds: gint) -> gint;
    pub fn g_main_context_dispatch(context: *mut GMainContext);
    pub fn g_main_context_set_poll_func(context: *mut GMainContext,
                                        func: GPollFunc);
    pub fn g_main_context_get_poll_func(context: *mut GMainContext)
     -> GPollFunc;
    pub fn g_main_context_add_poll(context: *mut GMainContext,
                                   fd: *mut GPollFD, priority: gint);
    pub fn g_main_context_remove_poll(context: *mut GMainContext,
                                      fd: *mut GPollFD);
    pub fn g_main_depth() -> gint;
    pub fn g_main_current_source() -> *mut GSource;
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean)
     -> *mut GMainLoop;
    pub fn g_main_loop_run(_loop: *mut GMainLoop);
    pub fn g_main_loop_quit(_loop: *mut GMainLoop);
    pub fn g_main_loop_ref(_loop: *mut GMainLoop) -> *mut GMainLoop;
    pub fn g_main_loop_unref(_loop: *mut GMainLoop);
    pub fn g_main_loop_is_running(_loop: *mut GMainLoop) -> gboolean;
    pub fn g_main_loop_get_context(_loop: *mut GMainLoop)
     -> *mut GMainContext;
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint)
     -> *mut GSource;
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
    pub fn g_source_unref(source: *mut GSource);
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext)
     -> guint;
    pub fn g_source_destroy(source: *mut GSource);
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
    pub fn g_source_set_can_recurse(source: *mut GSource,
                                    can_recurse: gboolean);
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
    pub fn g_source_get_id(source: *mut GSource) -> guint;
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
    pub fn g_source_set_callback(source: *mut GSource, func: GSourceFunc,
                                 data: gpointer, notify: GDestroyNotify);
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
    pub fn g_source_set_name(source: *mut GSource,
                             name: *const ::std::os::raw::c_char);
    pub fn g_source_get_name(source: *mut GSource)
     -> *const ::std::os::raw::c_char;
    pub fn g_source_set_name_by_id(tag: guint,
                                   name: *const ::std::os::raw::c_char);
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint,
                                events: GIOCondition) -> gpointer;
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer,
                                   new_events: GIOCondition);
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer)
     -> GIOCondition;
    pub fn g_source_set_callback_indirect(source: *mut GSource,
                                          callback_data: gpointer,
                                          callback_funcs:
                                              *mut GSourceCallbackFuncs);
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_add_child_source(source: *mut GSource,
                                     child_source: *mut GSource);
    pub fn g_source_remove_child_source(source: *mut GSource,
                                        child_source: *mut GSource);
    pub fn g_source_get_current_time(source: *mut GSource,
                                     timeval: *mut GTimeVal);
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
    pub fn g_idle_source_new() -> *mut GSource;
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
    pub fn g_get_current_time(result: *mut GTimeVal);
    pub fn g_get_monotonic_time() -> gint64;
    pub fn g_get_real_time() -> gint64;
    pub fn g_source_remove(tag: guint) -> gboolean;
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
    pub fn g_source_remove_by_funcs_user_data(funcs: *mut GSourceFuncs,
                                              user_data: gpointer)
     -> gboolean;
    pub fn g_timeout_add_full(priority: gint, interval: guint,
                              function: GSourceFunc, data: gpointer,
                              notify: GDestroyNotify) -> guint;
    pub fn g_timeout_add(interval: guint, function: GSourceFunc,
                         data: gpointer) -> guint;
    pub fn g_timeout_add_seconds_full(priority: gint, interval: guint,
                                      function: GSourceFunc, data: gpointer,
                                      notify: GDestroyNotify) -> guint;
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc,
                                 data: gpointer) -> guint;
    pub fn g_child_watch_add_full(priority: gint, pid: GPid,
                                  function: GChildWatchFunc, data: gpointer,
                                  notify: GDestroyNotify) -> guint;
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc,
                             data: gpointer) -> guint;
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
    pub fn g_idle_add_full(priority: gint, function: GSourceFunc,
                           data: gpointer, notify: GDestroyNotify) -> guint;
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
    pub fn g_main_context_invoke_full(context: *mut GMainContext,
                                      priority: gint, function: GSourceFunc,
                                      data: gpointer, notify: GDestroyNotify);
    pub fn g_main_context_invoke(context: *mut GMainContext,
                                 function: GSourceFunc, data: gpointer);
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
    pub fn g_unicode_script_from_iso15924(iso15924: guint32)
     -> GUnicodeScript;
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar)
     -> gboolean;
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar)
     -> gboolean;
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar,
                               b: *mut gunichar) -> gboolean;
    pub fn g_unichar_fully_decompose(ch: gunichar, compat: gboolean,
                                     result: *mut gunichar, result_len: gsize)
     -> gsize;
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
    pub fn g_unicode_canonical_decomposition(ch: gunichar,
                                             result_len: *mut gsize)
     -> *mut gunichar;
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize)
     -> gunichar;
    pub fn g_utf8_offset_to_pointer(str: *const gchar, offset: glong)
     -> *mut gchar;
    pub fn g_utf8_pointer_to_offset(str: *const gchar, pos: *const gchar)
     -> glong;
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar)
     -> *mut gchar;
    pub fn g_utf8_find_prev_char(str: *const gchar, p: *const gchar)
     -> *mut gchar;
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
    pub fn g_utf8_substring(str: *const gchar, start_pos: glong,
                            end_pos: glong) -> *mut gchar;
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize)
     -> *mut gchar;
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar)
     -> *mut gchar;
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar)
     -> *mut gchar;
    pub fn g_utf8_strreverse(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_to_utf16(str: *const gchar, len: glong,
                           items_read: *mut glong, items_written: *mut glong,
                           error: *mut *mut GError) -> *mut gunichar2;
    pub fn g_utf8_to_ucs4(str: *const gchar, len: glong,
                          items_read: *mut glong, items_written: *mut glong,
                          error: *mut *mut GError) -> *mut gunichar;
    pub fn g_utf8_to_ucs4_fast(str: *const gchar, len: glong,
                               items_written: *mut glong) -> *mut gunichar;
    pub fn g_utf16_to_ucs4(str: *const gunichar2, len: glong,
                           items_read: *mut glong, items_written: *mut glong,
                           error: *mut *mut GError) -> *mut gunichar;
    pub fn g_utf16_to_utf8(str: *const gunichar2, len: glong,
                           items_read: *mut glong, items_written: *mut glong,
                           error: *mut *mut GError) -> *mut gchar;
    pub fn g_ucs4_to_utf16(str: *const gunichar, len: glong,
                           items_read: *mut glong, items_written: *mut glong,
                           error: *mut *mut GError) -> *mut gunichar2;
    pub fn g_ucs4_to_utf8(str: *const gunichar, len: glong,
                          items_read: *mut glong, items_written: *mut glong,
                          error: *mut *mut GError) -> *mut gchar;
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
    pub fn g_utf8_validate(str: *const gchar, max_len: gssize,
                           end: *mut *const gchar) -> gboolean;
    pub fn g_utf8_strup(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_strdown(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_casefold(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_normalize(str: *const gchar, len: gssize,
                            mode: GNormalizeMode) -> *mut gchar;
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
    pub fn g_utf8_collate_key(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_collate_key_for_filename(str: *const gchar, len: gssize)
     -> *mut gchar;
    pub fn _g_utf8_make_valid(name: *const gchar) -> *mut gchar;
    pub fn g_string_new(init: *const gchar) -> *mut GString;
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
    pub fn g_string_free(string: *mut GString, free_segment: gboolean)
     -> *mut gchar;
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
    pub fn g_string_hash(str: *const GString) -> guint;
    pub fn g_string_assign(string: *mut GString, rval: *const gchar)
     -> *mut GString;
    pub fn g_string_truncate(string: *mut GString, len: gsize)
     -> *mut GString;
    pub fn g_string_set_size(string: *mut GString, len: gsize)
     -> *mut GString;
    pub fn g_string_insert_len(string: *mut GString, pos: gssize,
                               val: *const gchar, len: gssize)
     -> *mut GString;
    pub fn g_string_append(string: *mut GString, val: *const gchar)
     -> *mut GString;
    pub fn g_string_append_len(string: *mut GString, val: *const gchar,
                               len: gssize) -> *mut GString;
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar)
     -> *mut GString;
    pub fn g_string_prepend(string: *mut GString, val: *const gchar)
     -> *mut GString;
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar)
     -> *mut GString;
    pub fn g_string_prepend_len(string: *mut GString, val: *const gchar,
                                len: gssize) -> *mut GString;
    pub fn g_string_insert(string: *mut GString, pos: gssize,
                           val: *const gchar) -> *mut GString;
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar)
     -> *mut GString;
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize,
                                   wc: gunichar) -> *mut GString;
    pub fn g_string_overwrite(string: *mut GString, pos: gsize,
                              val: *const gchar) -> *mut GString;
    pub fn g_string_overwrite_len(string: *mut GString, pos: gsize,
                                  val: *const gchar, len: gssize)
     -> *mut GString;
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize)
     -> *mut GString;
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar,
                            args: va_list);
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
    pub fn g_string_append_vprintf(string: *mut GString, format: *const gchar,
                                   args: va_list);
    pub fn g_string_append_printf(string: *mut GString,
                                  format: *const gchar, ...);
    pub fn g_string_append_uri_escaped(string: *mut GString,
                                       unescaped: *const gchar,
                                       reserved_chars_allowed: *const gchar,
                                       allow_utf8: gboolean) -> *mut GString;
    pub fn g_string_down(string: *mut GString) -> *mut GString;
    pub fn g_string_up(string: *mut GString) -> *mut GString;
    pub fn g_io_channel_init(channel: *mut GIOChannel);
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
    pub fn g_io_channel_read(channel: *mut GIOChannel, buf: *mut gchar,
                             count: gsize, bytes_read: *mut gsize)
     -> GIOError;
    pub fn g_io_channel_write(channel: *mut GIOChannel, buf: *const gchar,
                              count: gsize, bytes_written: *mut gsize)
     -> GIOError;
    pub fn g_io_channel_seek(channel: *mut GIOChannel, offset: gint64,
                             _type: GSeekType) -> GIOError;
    pub fn g_io_channel_close(channel: *mut GIOChannel);
    pub fn g_io_channel_shutdown(channel: *mut GIOChannel, flush: gboolean,
                                 err: *mut *mut GError) -> GIOStatus;
    pub fn g_io_add_watch_full(channel: *mut GIOChannel, priority: gint,
                               condition: GIOCondition, func: GIOFunc,
                               user_data: gpointer, notify: GDestroyNotify)
     -> guint;
    pub fn g_io_create_watch(channel: *mut GIOChannel,
                             condition: GIOCondition) -> *mut GSource;
    pub fn g_io_add_watch(channel: *mut GIOChannel, condition: GIOCondition,
                          func: GIOFunc, user_data: gpointer) -> guint;
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel,
                                        size: gsize);
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel)
     -> GIOCondition;
    pub fn g_io_channel_set_flags(channel: *mut GIOChannel, flags: GIOFlags,
                                  error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
    pub fn g_io_channel_set_line_term(channel: *mut GIOChannel,
                                      line_term: *const gchar, length: gint);
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel,
                                      length: *mut gint) -> *const gchar;
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel,
                                     buffered: gboolean);
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_set_encoding(channel: *mut GIOChannel,
                                     encoding: *const gchar,
                                     error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel)
     -> *const gchar;
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel,
                                           do_close: gboolean);
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel)
     -> gboolean;
    pub fn g_io_channel_flush(channel: *mut GIOChannel,
                              error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_line(channel: *mut GIOChannel,
                                  str_return: *mut *mut gchar,
                                  length: *mut gsize,
                                  terminator_pos: *mut gsize,
                                  error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_line_string(channel: *mut GIOChannel,
                                         buffer: *mut GString,
                                         terminator_pos: *mut gsize,
                                         error: *mut *mut GError)
     -> GIOStatus;
    pub fn g_io_channel_read_to_end(channel: *mut GIOChannel,
                                    str_return: *mut *mut gchar,
                                    length: *mut gsize,
                                    error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_chars(channel: *mut GIOChannel, buf: *mut gchar,
                                   count: gsize, bytes_read: *mut gsize,
                                   error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_unichar(channel: *mut GIOChannel,
                                     thechar: *mut gunichar,
                                     error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_write_chars(channel: *mut GIOChannel,
                                    buf: *const gchar, count: gssize,
                                    bytes_written: *mut gsize,
                                    error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_write_unichar(channel: *mut GIOChannel,
                                      thechar: gunichar,
                                      error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_seek_position(channel: *mut GIOChannel,
                                      offset: gint64, _type: GSeekType,
                                      error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_new_file(filename: *const gchar, mode: *const gchar,
                                 error: *mut *mut GError) -> *mut GIOChannel;
    pub fn g_io_channel_error_quark() -> GQuark;
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int)
     -> *mut GIOChannel;
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
    pub fn g_key_file_error_quark() -> GQuark;
    pub fn g_key_file_new() -> *mut GKeyFile;
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
    pub fn g_key_file_free(key_file: *mut GKeyFile);
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile,
                                         separator: gchar);
    pub fn g_key_file_load_from_file(key_file: *mut GKeyFile,
                                     file: *const gchar, flags: GKeyFileFlags,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_data(key_file: *mut GKeyFile,
                                     data: *const gchar, length: gsize,
                                     flags: GKeyFileFlags,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_dirs(key_file: *mut GKeyFile,
                                     file: *const gchar,
                                     search_dirs: *mut *const gchar,
                                     full_path: *mut *mut gchar,
                                     flags: GKeyFileFlags,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_load_from_data_dirs(key_file: *mut GKeyFile,
                                          file: *const gchar,
                                          full_path: *mut *mut gchar,
                                          flags: GKeyFileFlags,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_key_file_to_data(key_file: *mut GKeyFile, length: *mut gsize,
                              error: *mut *mut GError) -> *mut gchar;
    pub fn g_key_file_save_to_file(key_file: *mut GKeyFile,
                                   filename: *const gchar,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize)
     -> *mut *mut gchar;
    pub fn g_key_file_get_keys(key_file: *mut GKeyFile,
                               group_name: *const gchar, length: *mut gsize,
                               error: *mut *mut GError) -> *mut *mut gchar;
    pub fn g_key_file_has_group(key_file: *mut GKeyFile,
                                group_name: *const gchar) -> gboolean;
    pub fn g_key_file_has_key(key_file: *mut GKeyFile,
                              group_name: *const gchar, key: *const gchar,
                              error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_get_value(key_file: *mut GKeyFile,
                                group_name: *const gchar, key: *const gchar,
                                error: *mut *mut GError) -> *mut gchar;
    pub fn g_key_file_set_value(key_file: *mut GKeyFile,
                                group_name: *const gchar, key: *const gchar,
                                value: *const gchar);
    pub fn g_key_file_get_string(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 error: *mut *mut GError) -> *mut gchar;
    pub fn g_key_file_set_string(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 string: *const gchar);
    pub fn g_key_file_get_locale_string(key_file: *mut GKeyFile,
                                        group_name: *const gchar,
                                        key: *const gchar,
                                        locale: *const gchar,
                                        error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_key_file_set_locale_string(key_file: *mut GKeyFile,
                                        group_name: *const gchar,
                                        key: *const gchar,
                                        locale: *const gchar,
                                        string: *const gchar);
    pub fn g_key_file_get_boolean(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_set_boolean(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  value: gboolean);
    pub fn g_key_file_get_integer(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  error: *mut *mut GError) -> gint;
    pub fn g_key_file_set_integer(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  value: gint);
    pub fn g_key_file_get_int64(key_file: *mut GKeyFile,
                                group_name: *const gchar, key: *const gchar,
                                error: *mut *mut GError) -> gint64;
    pub fn g_key_file_set_int64(key_file: *mut GKeyFile,
                                group_name: *const gchar, key: *const gchar,
                                value: gint64);
    pub fn g_key_file_get_uint64(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 error: *mut *mut GError) -> guint64;
    pub fn g_key_file_set_uint64(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 value: guint64);
    pub fn g_key_file_get_double(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 error: *mut *mut GError) -> gdouble;
    pub fn g_key_file_set_double(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 value: gdouble);
    pub fn g_key_file_get_string_list(key_file: *mut GKeyFile,
                                      group_name: *const gchar,
                                      key: *const gchar, length: *mut gsize,
                                      error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_key_file_set_string_list(key_file: *mut GKeyFile,
                                      group_name: *const gchar,
                                      key: *const gchar,
                                      list: *const *const gchar,
                                      length: gsize);
    pub fn g_key_file_get_locale_string_list(key_file: *mut GKeyFile,
                                             group_name: *const gchar,
                                             key: *const gchar,
                                             locale: *const gchar,
                                             length: *mut gsize,
                                             error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_key_file_set_locale_string_list(key_file: *mut GKeyFile,
                                             group_name: *const gchar,
                                             key: *const gchar,
                                             locale: *const gchar,
                                             list: *const *const gchar,
                                             length: gsize);
    pub fn g_key_file_get_boolean_list(key_file: *mut GKeyFile,
                                       group_name: *const gchar,
                                       key: *const gchar, length: *mut gsize,
                                       error: *mut *mut GError)
     -> *mut gboolean;
    pub fn g_key_file_set_boolean_list(key_file: *mut GKeyFile,
                                       group_name: *const gchar,
                                       key: *const gchar, list: *mut gboolean,
                                       length: gsize);
    pub fn g_key_file_get_integer_list(key_file: *mut GKeyFile,
                                       group_name: *const gchar,
                                       key: *const gchar, length: *mut gsize,
                                       error: *mut *mut GError) -> *mut gint;
    pub fn g_key_file_set_double_list(key_file: *mut GKeyFile,
                                      group_name: *const gchar,
                                      key: *const gchar, list: *mut gdouble,
                                      length: gsize);
    pub fn g_key_file_get_double_list(key_file: *mut GKeyFile,
                                      group_name: *const gchar,
                                      key: *const gchar, length: *mut gsize,
                                      error: *mut *mut GError)
     -> *mut gdouble;
    pub fn g_key_file_set_integer_list(key_file: *mut GKeyFile,
                                       group_name: *const gchar,
                                       key: *const gchar, list: *mut gint,
                                       length: gsize);
    pub fn g_key_file_set_comment(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  comment: *const gchar,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_get_comment(key_file: *mut GKeyFile,
                                  group_name: *const gchar, key: *const gchar,
                                  error: *mut *mut GError) -> *mut gchar;
    pub fn g_key_file_remove_comment(key_file: *mut GKeyFile,
                                     group_name: *const gchar,
                                     key: *const gchar,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_remove_key(key_file: *mut GKeyFile,
                                 group_name: *const gchar, key: *const gchar,
                                 error: *mut *mut GError) -> gboolean;
    pub fn g_key_file_remove_group(key_file: *mut GKeyFile,
                                   group_name: *const gchar,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_mapped_file_new(filename: *const gchar, writable: gboolean,
                             error: *mut *mut GError) -> *mut GMappedFile;
    pub fn g_mapped_file_new_from_fd(fd: gint, writable: gboolean,
                                     error: *mut *mut GError)
     -> *mut GMappedFile;
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
    pub fn g_mapped_file_free(file: *mut GMappedFile);
    pub fn g_markup_error_quark() -> GQuark;
    pub fn g_markup_parse_context_new(parser: *const GMarkupParser,
                                      flags: GMarkupParseFlags,
                                      user_data: gpointer,
                                      user_data_dnotify: GDestroyNotify)
     -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_ref(context: *mut GMarkupParseContext)
     -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_parse(context: *mut GMarkupParseContext,
                                        text: *const gchar, text_len: gssize,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_markup_parse_context_push(context: *mut GMarkupParseContext,
                                       parser: *const GMarkupParser,
                                       user_data: gpointer);
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext)
     -> gpointer;
    pub fn g_markup_parse_context_end_parse(context: *mut GMarkupParseContext,
                                            error: *mut *mut GError)
     -> gboolean;
    pub fn g_markup_parse_context_get_element(context:
                                                  *mut GMarkupParseContext)
     -> *const gchar;
    pub fn g_markup_parse_context_get_element_stack(context:
                                                        *mut GMarkupParseContext)
     -> *const GSList;
    pub fn g_markup_parse_context_get_position(context:
                                                   *mut GMarkupParseContext,
                                               line_number: *mut gint,
                                               char_number: *mut gint);
    pub fn g_markup_parse_context_get_user_data(context:
                                                    *mut GMarkupParseContext)
     -> gpointer;
    pub fn g_markup_escape_text(text: *const gchar, length: gssize)
     -> *mut gchar;
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...)
     -> *mut gchar;
    pub fn g_markup_vprintf_escaped(format: *const ::std::os::raw::c_char,
                                    args: va_list) -> *mut gchar;
    pub fn g_markup_collect_attributes(element_name: *const gchar,
                                       attribute_names: *mut *const gchar,
                                       attribute_values: *mut *const gchar,
                                       error: *mut *mut GError,
                                       first_type: GMarkupCollectType,
                                       first_attr: *const gchar, ...)
     -> gboolean;
    pub fn g_printf_string_upper_bound(format: *const gchar, args: va_list)
     -> gsize;
    pub fn g_log_set_handler(log_domain: *const gchar,
                             log_levels: GLogLevelFlags, log_func: GLogFunc,
                             user_data: gpointer) -> guint;
    pub fn g_log_set_handler_full(log_domain: *const gchar,
                                  log_levels: GLogLevelFlags,
                                  log_func: GLogFunc, user_data: gpointer,
                                  destroy: GDestroyNotify) -> guint;
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
    pub fn g_log_default_handler(log_domain: *const gchar,
                                 log_level: GLogLevelFlags,
                                 message: *const gchar,
                                 unused_data: gpointer);
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer)
     -> GLogFunc;
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags,
                 format: *const gchar, ...);
    pub fn g_logv(log_domain: *const gchar, log_level: GLogLevelFlags,
                  format: *const gchar, args: va_list);
    pub fn g_log_set_fatal_mask(log_domain: *const gchar,
                                fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags)
     -> GLogLevelFlags;
    pub fn _g_log_fallback_handler(log_domain: *const gchar,
                                   log_level: GLogLevelFlags,
                                   message: *const gchar,
                                   unused_data: gpointer);
    pub fn g_return_if_fail_warning(log_domain: *const ::std::os::raw::c_char,
                                    pretty_function:
                                        *const ::std::os::raw::c_char,
                                    expression:
                                        *const ::std::os::raw::c_char);
    pub fn g_warn_message(domain: *const ::std::os::raw::c_char,
                          file: *const ::std::os::raw::c_char,
                          line: ::std::os::raw::c_int,
                          func: *const ::std::os::raw::c_char,
                          warnexpr: *const ::std::os::raw::c_char);
    pub fn g_assert_warning(log_domain: *const ::std::os::raw::c_char,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int,
                            pretty_function: *const ::std::os::raw::c_char,
                            expression: *const ::std::os::raw::c_char);
    pub fn g_print(format: *const gchar, ...);
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_printerr(format: *const gchar, ...);
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_option_error_quark() -> GQuark;
    pub fn g_option_context_new(parameter_string: *const gchar)
     -> *mut GOptionContext;
    pub fn g_option_context_set_summary(context: *mut GOptionContext,
                                        summary: *const gchar);
    pub fn g_option_context_get_summary(context: *mut GOptionContext)
     -> *const gchar;
    pub fn g_option_context_set_description(context: *mut GOptionContext,
                                            description: *const gchar);
    pub fn g_option_context_get_description(context: *mut GOptionContext)
     -> *const gchar;
    pub fn g_option_context_free(context: *mut GOptionContext);
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext,
                                             help_enabled: gboolean);
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext)
     -> gboolean;
    pub fn g_option_context_set_ignore_unknown_options(context:
                                                           *mut GOptionContext,
                                                       ignore_unknown:
                                                           gboolean);
    pub fn g_option_context_get_ignore_unknown_options(context:
                                                           *mut GOptionContext)
     -> gboolean;
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext,
                                             strict_posix: gboolean);
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext)
     -> gboolean;
    pub fn g_option_context_add_main_entries(context: *mut GOptionContext,
                                             entries: *const GOptionEntry,
                                             translation_domain:
                                                 *const gchar);
    pub fn g_option_context_parse(context: *mut GOptionContext,
                                  argc: *mut gint, argv: *mut *mut *mut gchar,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_option_context_parse_strv(context: *mut GOptionContext,
                                       arguments: *mut *mut *mut gchar,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_option_context_set_translate_func(context: *mut GOptionContext,
                                               func: GTranslateFunc,
                                               data: gpointer,
                                               destroy_notify:
                                                   GDestroyNotify);
    pub fn g_option_context_set_translation_domain(context:
                                                       *mut GOptionContext,
                                                   domain: *const gchar);
    pub fn g_option_context_add_group(context: *mut GOptionContext,
                                      group: *mut GOptionGroup);
    pub fn g_option_context_set_main_group(context: *mut GOptionContext,
                                           group: *mut GOptionGroup);
    pub fn g_option_context_get_main_group(context: *mut GOptionContext)
     -> *mut GOptionGroup;
    pub fn g_option_context_get_help(context: *mut GOptionContext,
                                     main_help: gboolean,
                                     group: *mut GOptionGroup) -> *mut gchar;
    pub fn g_option_group_new(name: *const gchar, description: *const gchar,
                              help_description: *const gchar,
                              user_data: gpointer, destroy: GDestroyNotify)
     -> *mut GOptionGroup;
    pub fn g_option_group_set_parse_hooks(group: *mut GOptionGroup,
                                          pre_parse_func: GOptionParseFunc,
                                          post_parse_func: GOptionParseFunc);
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup,
                                         error_func: GOptionErrorFunc);
    pub fn g_option_group_free(group: *mut GOptionGroup);
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
    pub fn g_option_group_unref(group: *mut GOptionGroup);
    pub fn g_option_group_add_entries(group: *mut GOptionGroup,
                                      entries: *const GOptionEntry);
    pub fn g_option_group_set_translate_func(group: *mut GOptionGroup,
                                             func: GTranslateFunc,
                                             data: gpointer,
                                             destroy_notify: GDestroyNotify);
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup,
                                                 domain: *const gchar);
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec,
                                pspec2: *mut GPatternSpec) -> gboolean;
    pub fn g_pattern_match(pspec: *mut GPatternSpec, string_length: guint,
                           string: *const gchar,
                           string_reversed: *const gchar) -> gboolean;
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec,
                                  string: *const gchar) -> gboolean;
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar)
     -> gboolean;
    pub fn g_spaced_primes_closest(num: guint) -> guint;
    pub fn g_qsort_with_data(pbase: gconstpointer, total_elems: gint,
                             size: gsize, compare_func: GCompareDataFunc,
                             user_data: gpointer);
    pub fn g_queue_new() -> *mut GQueue;
    pub fn g_queue_free(queue: *mut GQueue);
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
    pub fn g_queue_init(queue: *mut GQueue);
    pub fn g_queue_clear(queue: *mut GQueue);
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
    pub fn g_queue_reverse(queue: *mut GQueue);
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc,
                           user_data: gpointer);
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer)
     -> *mut GList;
    pub fn g_queue_find_custom(queue: *mut GQueue, data: gconstpointer,
                               func: GCompareFunc) -> *mut GList;
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc,
                        user_data: gpointer);
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer)
     -> gboolean;
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer)
     -> guint;
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList,
                                 data: gpointer);
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList,
                                data: gpointer);
    pub fn g_queue_insert_sorted(queue: *mut GQueue, data: gpointer,
                                 func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint,
                                 link_: *mut GList);
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
    pub fn g_rand_new_with_seed_array(seed: *const guint32,
                                      seed_length: guint) -> *mut GRand;
    pub fn g_rand_new() -> *mut GRand;
    pub fn g_rand_free(rand_: *mut GRand);
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32,
                                 seed_length: guint);
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32)
     -> gint32;
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble,
                               end: gdouble) -> gdouble;
    pub fn g_random_set_seed(seed: guint32);
    pub fn g_random_int() -> guint32;
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
    pub fn g_random_double() -> gdouble;
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
    pub fn g_regex_error_quark() -> GQuark;
    pub fn g_regex_new(pattern: *const gchar,
                       compile_options: GRegexCompileFlags,
                       match_options: GRegexMatchFlags,
                       error: *mut *mut GError) -> *mut GRegex;
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
    pub fn g_regex_unref(regex: *mut GRegex);
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar)
     -> gint;
    pub fn g_regex_escape_string(string: *const gchar, length: gint)
     -> *mut gchar;
    pub fn g_regex_escape_nul(string: *const gchar, length: gint)
     -> *mut gchar;
    pub fn g_regex_get_compile_flags(regex: *const GRegex)
     -> GRegexCompileFlags;
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
    pub fn g_regex_match_simple(pattern: *const gchar, string: *const gchar,
                                compile_options: GRegexCompileFlags,
                                match_options: GRegexMatchFlags) -> gboolean;
    pub fn g_regex_match(regex: *const GRegex, string: *const gchar,
                         match_options: GRegexMatchFlags,
                         match_info: *mut *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_full(regex: *const GRegex, string: *const gchar,
                              string_len: gssize, start_position: gint,
                              match_options: GRegexMatchFlags,
                              match_info: *mut *mut GMatchInfo,
                              error: *mut *mut GError) -> gboolean;
    pub fn g_regex_match_all(regex: *const GRegex, string: *const gchar,
                             match_options: GRegexMatchFlags,
                             match_info: *mut *mut GMatchInfo) -> gboolean;
    pub fn g_regex_match_all_full(regex: *const GRegex, string: *const gchar,
                                  string_len: gssize, start_position: gint,
                                  match_options: GRegexMatchFlags,
                                  match_info: *mut *mut GMatchInfo,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_regex_split_simple(pattern: *const gchar, string: *const gchar,
                                compile_options: GRegexCompileFlags,
                                match_options: GRegexMatchFlags)
     -> *mut *mut gchar;
    pub fn g_regex_split(regex: *const GRegex, string: *const gchar,
                         match_options: GRegexMatchFlags) -> *mut *mut gchar;
    pub fn g_regex_split_full(regex: *const GRegex, string: *const gchar,
                              string_len: gssize, start_position: gint,
                              match_options: GRegexMatchFlags,
                              max_tokens: gint, error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_regex_replace(regex: *const GRegex, string: *const gchar,
                           string_len: gssize, start_position: gint,
                           replacement: *const gchar,
                           match_options: GRegexMatchFlags,
                           error: *mut *mut GError) -> *mut gchar;
    pub fn g_regex_replace_literal(regex: *const GRegex, string: *const gchar,
                                   string_len: gssize, start_position: gint,
                                   replacement: *const gchar,
                                   match_options: GRegexMatchFlags,
                                   error: *mut *mut GError) -> *mut gchar;
    pub fn g_regex_replace_eval(regex: *const GRegex, string: *const gchar,
                                string_len: gssize, start_position: gint,
                                match_options: GRegexMatchFlags,
                                eval: GRegexEvalCallback, user_data: gpointer,
                                error: *mut *mut GError) -> *mut gchar;
    pub fn g_regex_check_replacement(replacement: *const gchar,
                                     has_references: *mut gboolean,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo)
     -> *mut GRegex;
    pub fn g_match_info_get_string(match_info: *const GMatchInfo)
     -> *const gchar;
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
    pub fn g_match_info_next(match_info: *mut GMatchInfo,
                             error: *mut *mut GError) -> gboolean;
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo)
     -> gint;
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo)
     -> gboolean;
    pub fn g_match_info_expand_references(match_info: *const GMatchInfo,
                                          string_to_expand: *const gchar,
                                          error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint)
     -> *mut gchar;
    pub fn g_match_info_fetch_pos(match_info: *const GMatchInfo,
                                  match_num: gint, start_pos: *mut gint,
                                  end_pos: *mut gint) -> gboolean;
    pub fn g_match_info_fetch_named(match_info: *const GMatchInfo,
                                    name: *const gchar) -> *mut gchar;
    pub fn g_match_info_fetch_named_pos(match_info: *const GMatchInfo,
                                        name: *const gchar,
                                        start_pos: *mut gint,
                                        end_pos: *mut gint) -> gboolean;
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo)
     -> *mut *mut gchar;
    pub fn g_scanner_new(config_templ: *const GScannerConfig)
     -> *mut GScanner;
    pub fn g_scanner_destroy(scanner: *mut GScanner);
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar,
                                text_len: guint);
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint)
     -> guint;
    pub fn g_scanner_scope_add_symbol(scanner: *mut GScanner, scope_id: guint,
                                      symbol: *const gchar, value: gpointer);
    pub fn g_scanner_scope_remove_symbol(scanner: *mut GScanner,
                                         scope_id: guint,
                                         symbol: *const gchar);
    pub fn g_scanner_scope_lookup_symbol(scanner: *mut GScanner,
                                         scope_id: guint,
                                         symbol: *const gchar) -> gpointer;
    pub fn g_scanner_scope_foreach_symbol(scanner: *mut GScanner,
                                          scope_id: guint, func: GHFunc,
                                          user_data: gpointer);
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner,
                                   symbol: *const gchar) -> gpointer;
    pub fn g_scanner_unexp_token(scanner: *mut GScanner,
                                 expected_token: GTokenType,
                                 identifier_spec: *const gchar,
                                 symbol_spec: *const gchar,
                                 symbol_name: *const gchar,
                                 message: *const gchar, is_error: gint);
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
    pub fn g_sequence_free(seq: *mut GSequence);
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc,
                              user_data: gpointer);
    pub fn g_sequence_foreach_range(begin: *mut GSequenceIter,
                                    end: *mut GSequenceIter, func: GFunc,
                                    user_data: gpointer);
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc,
                           cmp_data: gpointer);
    pub fn g_sequence_sort_iter(seq: *mut GSequence,
                                cmp_func: GSequenceIterCompareFunc,
                                cmp_data: gpointer);
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence)
     -> *mut GSequenceIter;
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint)
     -> *mut GSequenceIter;
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
    pub fn g_sequence_insert_sorted(seq: *mut GSequence, data: gpointer,
                                    cmp_func: GCompareDataFunc,
                                    cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_insert_sorted_iter(seq: *mut GSequence, data: gpointer,
                                         iter_cmp: GSequenceIterCompareFunc,
                                         cmp_data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_sort_changed(iter: *mut GSequenceIter,
                                   cmp_func: GCompareDataFunc,
                                   cmp_data: gpointer);
    pub fn g_sequence_sort_changed_iter(iter: *mut GSequenceIter,
                                        iter_cmp: GSequenceIterCompareFunc,
                                        cmp_data: gpointer);
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter,
                                   end: *mut GSequenceIter);
    pub fn g_sequence_move_range(dest: *mut GSequenceIter,
                                 begin: *mut GSequenceIter,
                                 end: *mut GSequenceIter);
    pub fn g_sequence_search(seq: *mut GSequence, data: gpointer,
                             cmp_func: GCompareDataFunc, cmp_data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_search_iter(seq: *mut GSequence, data: gpointer,
                                  iter_cmp: GSequenceIterCompareFunc,
                                  cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_lookup(seq: *mut GSequence, data: gpointer,
                             cmp_func: GCompareDataFunc, cmp_data: gpointer)
     -> *mut GSequenceIter;
    pub fn g_sequence_lookup_iter(seq: *mut GSequence, data: gpointer,
                                  iter_cmp: GSequenceIterCompareFunc,
                                  cmp_data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter)
     -> *mut GSequenceIter;
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter)
     -> *mut GSequenceIter;
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint)
     -> *mut GSequenceIter;
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter)
     -> *mut GSequence;
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter,
                                   b: *mut GSequenceIter) -> gint;
    pub fn g_sequence_range_get_midpoint(begin: *mut GSequenceIter,
                                         end: *mut GSequenceIter)
     -> *mut GSequenceIter;
    pub fn g_shell_error_quark() -> GQuark;
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
    pub fn g_shell_unquote(quoted_string: *const gchar,
                           error: *mut *mut GError) -> *mut gchar;
    pub fn g_shell_parse_argv(command_line: *const gchar, argcp: *mut gint,
                              argvp: *mut *mut *mut gchar,
                              error: *mut *mut GError) -> gboolean;
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer)
     -> gpointer;
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
    pub fn g_slice_free_chain_with_offset(block_size: gsize,
                                          mem_chain: gpointer,
                                          next_offset: gsize);
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
    pub fn g_slice_get_config_state(ckey: GSliceConfig, address: gint64,
                                    n_values: *mut guint) -> *mut gint64;
    pub fn g_spawn_error_quark() -> GQuark;
    pub fn g_spawn_exit_error_quark() -> GQuark;
    pub fn g_spawn_async(working_directory: *const gchar,
                         argv: *mut *mut gchar, envp: *mut *mut gchar,
                         flags: GSpawnFlags,
                         child_setup: GSpawnChildSetupFunc,
                         user_data: gpointer, child_pid: *mut GPid,
                         error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_async_with_pipes(working_directory: *const gchar,
                                    argv: *mut *mut gchar,
                                    envp: *mut *mut gchar, flags: GSpawnFlags,
                                    child_setup: GSpawnChildSetupFunc,
                                    user_data: gpointer, child_pid: *mut GPid,
                                    standard_input: *mut gint,
                                    standard_output: *mut gint,
                                    standard_error: *mut gint,
                                    error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_sync(working_directory: *const gchar,
                        argv: *mut *mut gchar, envp: *mut *mut gchar,
                        flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc,
                        user_data: gpointer, standard_output: *mut *mut gchar,
                        standard_error: *mut *mut gchar,
                        exit_status: *mut gint, error: *mut *mut GError)
     -> gboolean;
    pub fn g_spawn_command_line_sync(command_line: *const gchar,
                                     standard_output: *mut *mut gchar,
                                     standard_error: *mut *mut gchar,
                                     exit_status: *mut gint,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_command_line_async(command_line: *const gchar,
                                      error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_check_exit_status(exit_status: gint,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_close_pid(pid: GPid);
    pub fn g_ascii_tolower(c: gchar) -> gchar;
    pub fn g_ascii_toupper(c: gchar) -> gchar;
    pub fn g_ascii_digit_value(c: gchar) -> gint;
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
    pub fn g_strdelimit(string: *mut gchar, delimiters: *const gchar,
                        new_delimiter: gchar) -> *mut gchar;
    pub fn g_strcanon(string: *mut gchar, valid_chars: *const gchar,
                      substitutor: gchar) -> *mut gchar;
    pub fn g_strerror(errnum: gint) -> *const gchar;
    pub fn g_strsignal(signum: gint) -> *const gchar;
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize)
     -> gsize;
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize)
     -> gsize;
    pub fn g_strstr_len(haystack: *const gchar, haystack_len: gssize,
                        needle: *const gchar) -> *mut gchar;
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar)
     -> *mut gchar;
    pub fn g_strrstr_len(haystack: *const gchar, haystack_len: gssize,
                         needle: *const gchar) -> *mut gchar;
    pub fn g_str_has_suffix(str: *const gchar, suffix: *const gchar)
     -> gboolean;
    pub fn g_str_has_prefix(str: *const gchar, prefix: *const gchar)
     -> gboolean;
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar)
     -> gdouble;
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar,
                            base: guint) -> guint64;
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar,
                           base: guint) -> gint64;
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble)
     -> *mut gchar;
    pub fn g_ascii_formatd(buffer: *mut gchar, buf_len: gint,
                           format: *const gchar, d: gdouble) -> *mut gchar;
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize)
     -> gint;
    pub fn g_ascii_strdown(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_ascii_strup(str: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_str_is_ascii(str: *const gchar) -> gboolean;
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint)
     -> gint;
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
    pub fn g_strdup(str: *const gchar) -> *mut gchar;
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
    pub fn g_strdup_vprintf(format: *const gchar, args: va_list)
     -> *mut gchar;
    pub fn g_strndup(str: *const gchar, n: gsize) -> *mut gchar;
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar)
     -> *mut gchar;
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
    pub fn g_strsplit(string: *const gchar, delimiter: *const gchar,
                      max_tokens: gint) -> *mut *mut gchar;
    pub fn g_strsplit_set(string: *const gchar, delimiters: *const gchar,
                          max_tokens: gint) -> *mut *mut gchar;
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar)
     -> *mut gchar;
    pub fn g_strfreev(str_array: *mut *mut gchar);
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char)
     -> *mut gchar;
    pub fn g_str_to_ascii(str: *const gchar, from_locale: *const gchar)
     -> *mut gchar;
    pub fn g_str_tokenize_and_fold(string: *const gchar,
                                   translit_locale: *const gchar,
                                   ascii_alternates: *mut *mut *mut gchar)
     -> *mut *mut gchar;
    pub fn g_str_match_string(search_term: *const gchar,
                              potential_hit: *const gchar,
                              accept_alternates: gboolean) -> gboolean;
    pub fn g_strv_contains(strv: *const *const gchar, str: *const gchar)
     -> gboolean;
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk,
                                 string: *const gchar) -> *mut gchar;
    pub fn g_string_chunk_insert_len(chunk: *mut GStringChunk,
                                     string: *const gchar, len: gssize)
     -> *mut gchar;
    pub fn g_string_chunk_insert_const(chunk: *mut GStringChunk,
                                       string: *const gchar) -> *mut gchar;
    pub fn g_strcmp0(str1: *const ::std::os::raw::c_char,
                     str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn g_test_minimized_result(minimized_quantity:
                                       ::std::os::raw::c_double,
                                   format:
                                       *const ::std::os::raw::c_char, ...);
    pub fn g_test_maximized_result(maximized_quantity:
                                       ::std::os::raw::c_double,
                                   format:
                                       *const ::std::os::raw::c_char, ...);
    pub fn g_test_init(argc: *mut ::std::os::raw::c_int,
                       argv: *mut *mut *mut ::std::os::raw::c_char, ...);
    pub fn g_test_subprocess() -> gboolean;
    pub fn g_test_run() -> ::std::os::raw::c_int;
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char,
                           test_func: GTestFunc);
    pub fn g_test_add_data_func(testpath: *const ::std::os::raw::c_char,
                                test_data: gconstpointer,
                                test_func: GTestDataFunc);
    pub fn g_test_add_data_func_full(testpath: *const ::std::os::raw::c_char,
                                     test_data: gpointer,
                                     test_func: GTestDataFunc,
                                     data_free_func: GDestroyNotify);
    pub fn g_test_fail();
    pub fn g_test_incomplete(msg: *const gchar);
    pub fn g_test_skip(msg: *const gchar);
    pub fn g_test_failed() -> gboolean;
    pub fn g_test_set_nonfatal_assertions();
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
    pub fn g_test_timer_start();
    pub fn g_test_timer_elapsed() -> ::std::os::raw::c_double;
    pub fn g_test_timer_last() -> ::std::os::raw::c_double;
    pub fn g_test_queue_free(gfree_pointer: gpointer);
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify,
                                destroy_data: gpointer);
    pub fn g_test_trap_fork(usec_timeout: guint64,
                            test_trap_flags: GTestTrapFlags) -> gboolean;
    pub fn g_test_trap_subprocess(test_path: *const ::std::os::raw::c_char,
                                  usec_timeout: guint64,
                                  test_flags: GTestSubprocessFlags);
    pub fn g_test_trap_has_passed() -> gboolean;
    pub fn g_test_trap_reached_timeout() -> gboolean;
    pub fn g_test_rand_int() -> gint32;
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
    pub fn g_test_rand_double() -> ::std::os::raw::c_double;
    pub fn g_test_rand_double_range(range_start: ::std::os::raw::c_double,
                                    range_end: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn g_test_create_case(test_name: *const ::std::os::raw::c_char,
                              data_size: gsize, test_data: gconstpointer,
                              data_setup: GTestFixtureFunc,
                              data_test: GTestFixtureFunc,
                              data_teardown: GTestFixtureFunc)
     -> *mut GTestCase;
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char)
     -> *mut GTestSuite;
    pub fn g_test_get_root() -> *mut GTestSuite;
    pub fn g_test_suite_add(suite: *mut GTestSuite,
                            test_case: *mut GTestCase);
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite,
                                  nestedsuite: *mut GTestSuite);
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
    pub fn g_test_trap_assertions(domain: *const ::std::os::raw::c_char,
                                  file: *const ::std::os::raw::c_char,
                                  line: ::std::os::raw::c_int,
                                  func: *const ::std::os::raw::c_char,
                                  assertion_flags: guint64,
                                  pattern: *const ::std::os::raw::c_char);
    pub fn g_assertion_message(domain: *const ::std::os::raw::c_char,
                               file: *const ::std::os::raw::c_char,
                               line: ::std::os::raw::c_int,
                               func: *const ::std::os::raw::c_char,
                               message: *const ::std::os::raw::c_char);
    pub fn g_assertion_message_expr(domain: *const ::std::os::raw::c_char,
                                    file: *const ::std::os::raw::c_char,
                                    line: ::std::os::raw::c_int,
                                    func: *const ::std::os::raw::c_char,
                                    expr: *const ::std::os::raw::c_char);
    pub fn g_assertion_message_cmpstr(domain: *const ::std::os::raw::c_char,
                                      file: *const ::std::os::raw::c_char,
                                      line: ::std::os::raw::c_int,
                                      func: *const ::std::os::raw::c_char,
                                      expr: *const ::std::os::raw::c_char,
                                      arg1: *const ::std::os::raw::c_char,
                                      cmp: *const ::std::os::raw::c_char,
                                      arg2: *const ::std::os::raw::c_char);
    pub fn g_assertion_message_cmpnum(domain: *const ::std::os::raw::c_char,
                                      file: *const ::std::os::raw::c_char,
                                      line: ::std::os::raw::c_int,
                                      func: *const ::std::os::raw::c_char,
                                      expr: *const ::std::os::raw::c_char,
                                      arg1: ::std::os::raw::c_double,
                                      cmp: *const ::std::os::raw::c_char,
                                      arg2: ::std::os::raw::c_double,
                                      numtype: ::std::os::raw::c_char);
    pub fn g_assertion_message_error(domain: *const ::std::os::raw::c_char,
                                     file: *const ::std::os::raw::c_char,
                                     line: ::std::os::raw::c_int,
                                     func: *const ::std::os::raw::c_char,
                                     expr: *const ::std::os::raw::c_char,
                                     error: *const GError,
                                     error_domain: GQuark,
                                     error_code: ::std::os::raw::c_int);
    pub fn g_test_add_vtable(testpath: *const ::std::os::raw::c_char,
                             data_size: gsize, test_data: gconstpointer,
                             data_setup: GTestFixtureFunc,
                             data_test: GTestFixtureFunc,
                             data_teardown: GTestFixtureFunc);
    pub fn g_test_log_type_name(log_type: GTestLogType)
     -> *const ::std::os::raw::c_char;
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
    pub fn g_test_log_buffer_push(tbuffer: *mut GTestLogBuffer,
                                  n_bytes: guint, bytes: *const guint8);
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer)
     -> *mut GTestLogMsg;
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc,
                                        user_data: gpointer);
    pub fn g_test_expect_message(log_domain: *const gchar,
                                 log_level: GLogLevelFlags,
                                 pattern: *const gchar);
    pub fn g_test_assert_expected_messages_internal(domain:
                                                        *const ::std::os::raw::c_char,
                                                    file:
                                                        *const ::std::os::raw::c_char,
                                                    line:
                                                        ::std::os::raw::c_int,
                                                    func:
                                                        *const ::std::os::raw::c_char);
    pub fn g_test_build_filename(file_type: GTestFileType,
                                 first_path: *const gchar, ...) -> *mut gchar;
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
    pub fn g_test_get_filename(file_type: GTestFileType,
                               first_path: *const gchar, ...) -> *const gchar;
    pub fn g_thread_pool_new(func: GFunc, user_data: gpointer,
                             max_threads: gint, exclusive: gboolean,
                             error: *mut *mut GError) -> *mut GThreadPool;
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean,
                              wait_: gboolean);
    pub fn g_thread_pool_push(pool: *mut GThreadPool, data: gpointer,
                              error: *mut *mut GError) -> gboolean;
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
    pub fn g_thread_pool_set_sort_function(pool: *mut GThreadPool,
                                           func: GCompareDataFunc,
                                           user_data: gpointer);
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer)
     -> gboolean;
    pub fn g_thread_pool_set_max_threads(pool: *mut GThreadPool,
                                         max_threads: gint,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
    pub fn g_thread_pool_stop_unused_threads();
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
    pub fn g_thread_pool_get_max_idle_time() -> guint;
    pub fn g_timer_new() -> *mut GTimer;
    pub fn g_timer_destroy(timer: *mut GTimer);
    pub fn g_timer_start(timer: *mut GTimer);
    pub fn g_timer_stop(timer: *mut GTimer);
    pub fn g_timer_reset(timer: *mut GTimer);
    pub fn g_timer_continue(timer: *mut GTimer);
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong)
     -> gdouble;
    pub fn g_usleep(microseconds: gulong);
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
    pub fn g_time_val_from_iso8601(iso_date: *const gchar,
                                   time_: *mut GTimeVal) -> gboolean;
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
    pub fn g_tree_new_with_data(key_compare_func: GCompareDataFunc,
                                key_compare_data: gpointer) -> *mut GTree;
    pub fn g_tree_new_full(key_compare_func: GCompareDataFunc,
                           key_compare_data: gpointer,
                           key_destroy_func: GDestroyNotify,
                           value_destroy_func: GDestroyNotify) -> *mut GTree;
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
    pub fn g_tree_unref(tree: *mut GTree);
    pub fn g_tree_destroy(tree: *mut GTree);
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
    pub fn g_tree_lookup_extended(tree: *mut GTree, lookup_key: gconstpointer,
                                  orig_key: *mut gpointer,
                                  value: *mut gpointer) -> gboolean;
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc,
                          user_data: gpointer);
    pub fn g_tree_traverse(tree: *mut GTree, traverse_func: GTraverseFunc,
                           traverse_type: GTraverseType, user_data: gpointer);
    pub fn g_tree_search(tree: *mut GTree, search_func: GCompareFunc,
                         user_data: gconstpointer) -> gpointer;
    pub fn g_tree_height(tree: *mut GTree) -> gint;
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
    pub fn g_uri_unescape_string(escaped_string:
                                     *const ::std::os::raw::c_char,
                                 illegal_characters:
                                     *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn g_uri_unescape_segment(escaped_string:
                                      *const ::std::os::raw::c_char,
                                  escaped_string_end:
                                      *const ::std::os::raw::c_char,
                                  illegal_characters:
                                      *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn g_uri_escape_string(unescaped: *const ::std::os::raw::c_char,
                               reserved_chars_allowed:
                                   *const ::std::os::raw::c_char,
                               allow_utf8: gboolean)
     -> *mut ::std::os::raw::c_char;
    pub fn g_variant_type_string_is_valid(type_string: *const gchar)
     -> gboolean;
    pub fn g_variant_type_string_scan(string: *const gchar,
                                      limit: *const gchar,
                                      endptr: *mut *const gchar) -> gboolean;
    pub fn g_variant_type_free(_type: *mut GVariantType);
    pub fn g_variant_type_copy(_type: *const GVariantType)
     -> *mut GVariantType;
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
    pub fn g_variant_type_get_string_length(_type: *const GVariantType)
     -> gsize;
    pub fn g_variant_type_peek_string(_type: *const GVariantType)
     -> *const gchar;
    pub fn g_variant_type_dup_string(_type: *const GVariantType)
     -> *mut gchar;
    pub fn g_variant_type_is_definite(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_container(_type: *const GVariantType)
     -> gboolean;
    pub fn g_variant_type_is_basic(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_maybe(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_array(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_tuple(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_dict_entry(_type: *const GVariantType)
     -> gboolean;
    pub fn g_variant_type_is_variant(_type: *const GVariantType) -> gboolean;
    pub fn g_variant_type_hash(_type: gconstpointer) -> guint;
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer)
     -> gboolean;
    pub fn g_variant_type_is_subtype_of(_type: *const GVariantType,
                                        supertype: *const GVariantType)
     -> gboolean;
    pub fn g_variant_type_element(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_first(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_next(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_n_items(_type: *const GVariantType) -> gsize;
    pub fn g_variant_type_key(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_value(_type: *const GVariantType)
     -> *const GVariantType;
    pub fn g_variant_type_new_array(element: *const GVariantType)
     -> *mut GVariantType;
    pub fn g_variant_type_new_maybe(element: *const GVariantType)
     -> *mut GVariantType;
    pub fn g_variant_type_new_tuple(items: *const *const GVariantType,
                                    length: gint) -> *mut GVariantType;
    pub fn g_variant_type_new_dict_entry(key: *const GVariantType,
                                         value: *const GVariantType)
     -> *mut GVariantType;
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
    pub fn g_variant_unref(value: *mut GVariant);
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
    pub fn g_variant_is_of_type(value: *mut GVariant,
                                _type: *const GVariantType) -> gboolean;
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
    pub fn g_variant_new_byte(value: guchar) -> *mut GVariant;
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
    pub fn g_variant_new_printf(format_string: *const gchar, ...)
     -> *mut GVariant;
    pub fn g_variant_new_object_path(object_path: *const gchar)
     -> *mut GVariant;
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize)
     -> *mut GVariant;
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize)
     -> *mut GVariant;
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
    pub fn g_variant_new_bytestring_array(strv: *const *const gchar,
                                          length: gssize) -> *mut GVariant;
    pub fn g_variant_new_fixed_array(element_type: *const GVariantType,
                                     elements: gconstpointer,
                                     n_elements: gsize, element_size: gsize)
     -> *mut GVariant;
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
    pub fn g_variant_get_byte(value: *mut GVariant) -> guchar;
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize)
     -> *const gchar;
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize)
     -> *mut gchar;
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize)
     -> *mut *const gchar;
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize)
     -> *mut *mut gchar;
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize)
     -> *mut *const gchar;
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize)
     -> *mut *mut gchar;
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize)
     -> *mut gchar;
    pub fn g_variant_get_bytestring_array(value: *mut GVariant,
                                          length: *mut gsize)
     -> *mut *const gchar;
    pub fn g_variant_dup_bytestring_array(value: *mut GVariant,
                                          length: *mut gsize)
     -> *mut *mut gchar;
    pub fn g_variant_new_maybe(child_type: *const GVariantType,
                               child: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_array(child_type: *const GVariantType,
                               children: *const *mut GVariant,
                               n_children: gsize) -> *mut GVariant;
    pub fn g_variant_new_tuple(children: *const *mut GVariant,
                               n_children: gsize) -> *mut GVariant;
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant)
     -> *mut GVariant;
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
    pub fn g_variant_get_child(value: *mut GVariant, index_: gsize,
                               format_string: *const gchar, ...);
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize)
     -> *mut GVariant;
    pub fn g_variant_lookup(dictionary: *mut GVariant, key: *const gchar,
                            format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_lookup_value(dictionary: *mut GVariant,
                                  key: *const gchar,
                                  expected_type: *const GVariantType)
     -> *mut GVariant;
    pub fn g_variant_get_fixed_array(value: *mut GVariant,
                                     n_elements: *mut gsize,
                                     element_size: gsize) -> gconstpointer;
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean)
     -> *mut gchar;
    pub fn g_variant_print_string(value: *mut GVariant, string: *mut GString,
                                  type_annotate: gboolean) -> *mut GString;
    pub fn g_variant_hash(value: gconstpointer) -> guint;
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer)
     -> gboolean;
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_from_bytes(_type: *const GVariantType,
                                    bytes: *mut GBytes, trusted: gboolean)
     -> *mut GVariant;
    pub fn g_variant_new_from_data(_type: *const GVariantType,
                                   data: gconstpointer, size: gsize,
                                   trusted: gboolean, notify: GDestroyNotify,
                                   user_data: gpointer) -> *mut GVariant;
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant)
     -> gsize;
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter)
     -> *mut GVariant;
    pub fn g_variant_iter_next(iter: *mut GVariantIter,
                               format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_iter_loop(iter: *mut GVariantIter,
                               format_string: *const gchar, ...) -> gboolean;
    pub fn g_variant_parser_get_error_quark() -> GQuark;
    pub fn g_variant_parse_error_quark() -> GQuark;
    pub fn g_variant_builder_new(_type: *const GVariantType)
     -> *mut GVariantBuilder;
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder)
     -> *mut GVariantBuilder;
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder,
                                  _type: *const GVariantType);
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder)
     -> *mut GVariant;
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder,
                                  _type: *const GVariantType);
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder,
                                       value: *mut GVariant);
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder,
                                 format_string: *const gchar, ...);
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder,
                                        format: *const gchar, ...);
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_get(value: *mut GVariant,
                         format_string: *const gchar, ...);
    pub fn g_variant_new_va(format_string: *const gchar,
                            endptr: *mut *const gchar, app: *mut va_list)
     -> *mut GVariant;
    pub fn g_variant_get_va(value: *mut GVariant, format_string: *const gchar,
                            endptr: *mut *const gchar, app: *mut va_list);
    pub fn g_variant_check_format_string(value: *mut GVariant,
                                         format_string: *const gchar,
                                         copy_only: gboolean) -> gboolean;
    pub fn g_variant_parse(_type: *const GVariantType, text: *const gchar,
                           limit: *const gchar, endptr: *mut *const gchar,
                           error: *mut *mut GError) -> *mut GVariant;
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list)
     -> *mut GVariant;
    pub fn g_variant_parse_error_print_context(error: *mut GError,
                                               source_str: *const gchar)
     -> *mut gchar;
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
    pub fn g_variant_dict_init(dict: *mut GVariantDict,
                               from_asv: *mut GVariant);
    pub fn g_variant_dict_lookup(dict: *mut GVariantDict, key: *const gchar,
                                 format_string: *const gchar, ...)
     -> gboolean;
    pub fn g_variant_dict_lookup_value(dict: *mut GVariantDict,
                                       key: *const gchar,
                                       expected_type: *const GVariantType)
     -> *mut GVariant;
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar)
     -> gboolean;
    pub fn g_variant_dict_insert(dict: *mut GVariantDict, key: *const gchar,
                                 format_string: *const gchar, ...);
    pub fn g_variant_dict_insert_value(dict: *mut GVariantDict,
                                       key: *const gchar,
                                       value: *mut GVariant);
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar)
     -> gboolean;
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
    pub fn glib_check_version(required_major: guint, required_minor: guint,
                              required_micro: guint) -> *const gchar;
    pub fn g_mem_chunk_new(name: *const gchar, atom_size: gint,
                           area_size: gsize, _type: gint) -> *mut GMemChunk;
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_info();
    pub fn g_blow_chunks();
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint)
     -> *mut GAllocator;
    pub fn g_allocator_free(allocator: *mut GAllocator);
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
    pub fn g_list_pop_allocator();
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
    pub fn g_slist_pop_allocator();
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
    pub fn g_node_pop_allocator();
    pub fn g_cache_new(value_new_func: GCacheNewFunc,
                       value_destroy_func: GCacheDestroyFunc,
                       key_dup_func: GCacheDupFunc,
                       key_destroy_func: GCacheDestroyFunc,
                       hash_key_func: GHashFunc, hash_value_func: GHashFunc,
                       key_equal_func: GEqualFunc) -> *mut GCache;
    pub fn g_cache_destroy(cache: *mut GCache);
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc,
                               user_data: gpointer);
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc,
                                 user_data: gpointer);
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
    pub fn g_completion_remove_items(cmp: *mut GCompletion,
                                     items: *mut GList);
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
    pub fn g_completion_complete(cmp: *mut GCompletion, prefix: *const gchar,
                                 new_prefix: *mut *mut gchar) -> *mut GList;
    pub fn g_completion_complete_utf8(cmp: *mut GCompletion,
                                      prefix: *const gchar,
                                      new_prefix: *mut *mut gchar)
     -> *mut GList;
    pub fn g_completion_set_compare(cmp: *mut GCompletion,
                                    strncmp_func: GCompletionStrncmpFunc);
    pub fn g_completion_free(cmp: *mut GCompletion);
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
    pub fn g_relation_destroy(relation: *mut GRelation);
    pub fn g_relation_index(relation: *mut GRelation, field: gint,
                            hash_func: GHashFunc, key_equal_func: GEqualFunc);
    pub fn g_relation_insert(relation: *mut GRelation, ...);
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer,
                             field: gint) -> gint;
    pub fn g_relation_select(relation: *mut GRelation, key: gconstpointer,
                             field: gint) -> *mut GTuples;
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer,
                            field: gint) -> gint;
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
    pub fn g_relation_print(relation: *mut GRelation);
    pub fn g_tuples_destroy(tuples: *mut GTuples);
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint)
     -> gpointer;
    pub fn g_thread_create(func: GThreadFunc, data: gpointer,
                           joinable: gboolean, error: *mut *mut GError)
     -> *mut GThread;
    pub fn g_thread_create_full(func: GThreadFunc, data: gpointer,
                                stack_size: gulong, joinable: gboolean,
                                bound: gboolean, priority: GThreadPriority,
                                error: *mut *mut GError) -> *mut GThread;
    pub fn g_thread_set_priority(thread: *mut GThread,
                                 priority: GThreadPriority);
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut Struct_timeval) -> ::std::os::raw::c_int;
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const Struct_timespec,
                   __sigmask: *const __sigset_t) -> ::std::os::raw::c_int;
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t)
     -> ::std::os::raw::c_int;
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
    pub fn sched_setparam(__pid: __pid_t, __param: *const Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn sched_getparam(__pid: __pid_t, __param: *mut Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn sched_setscheduler(__pid: __pid_t, __policy: ::std::os::raw::c_int,
                              __param: *const Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
    pub fn sched_yield() -> ::std::os::raw::c_int;
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_create(__newthread: *mut pthread_t,
                          __attr: *const pthread_attr_t,
                          __start_routine:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut ::std::os::raw::c_void)
                                                        ->
                                                            *mut ::std::os::raw::c_void>,
                          __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
    pub fn pthread_join(__th: pthread_t,
                        __thread_return: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
    pub fn pthread_self() -> pthread_t;
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t,
                                       __detachstate:
                                           *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t,
                                       __detachstate: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t,
                                     __guardsize: *mut size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t,
                                     __guardsize: size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t,
                                      __param: *mut Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t,
                                      __param: *const Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t,
                                       __policy: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t,
                                       __policy: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t,
                                        __inherit: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t,
                                        __inherit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getscope(__attr: *const pthread_attr_t,
                                 __scope: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t,
                                 __scope: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t,
                                     __stackaddr:
                                         *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t,
                                     __stackaddr: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t,
                                     __stacksize: *mut size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t,
                                     __stacksize: size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_getstack(__attr: *const pthread_attr_t,
                                 __stackaddr:
                                     *mut *mut ::std::os::raw::c_void,
                                 __stacksize: *mut size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_attr_setstack(__attr: *mut pthread_attr_t,
                                 __stackaddr: *mut ::std::os::raw::c_void,
                                 __stacksize: size_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_setschedparam(__target_thread: pthread_t,
                                 __policy: ::std::os::raw::c_int,
                                 __param: *const Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn pthread_getschedparam(__target_thread: pthread_t,
                                 __policy: *mut ::std::os::raw::c_int,
                                 __param: *mut Struct_sched_param)
     -> ::std::os::raw::c_int;
    pub fn pthread_setschedprio(__target_thread: pthread_t,
                                __prio: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_once(__once_control: *mut pthread_once_t,
                        __init_routine:
                            ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn pthread_setcancelstate(__state: ::std::os::raw::c_int,
                                  __oldstate: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_setcanceltype(__type: ::std::os::raw::c_int,
                                 __oldtype: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
    pub fn pthread_testcancel();
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
    pub fn __sigsetjmp(__env: *mut Struct___jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t,
                              __mutexattr: *const pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t,
                                   __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_getprioceiling(__mutex: *const pthread_mutex_t,
                                        __prioceiling:
                                            *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_setprioceiling(__mutex: *mut pthread_mutex_t,
                                        __prioceiling: ::std::os::raw::c_int,
                                        __old_ceiling:
                                            *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t,
                                        __pshared: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t,
                                        __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t,
                                     __kind: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t,
                                     __kind: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_getprotocol(__attr: *const pthread_mutexattr_t,
                                         __protocol:
                                             *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t,
                                         __protocol: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_getprioceiling(__attr:
                                                *const pthread_mutexattr_t,
                                            __prioceiling:
                                                *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_setprioceiling(__attr: *mut pthread_mutexattr_t,
                                            __prioceiling:
                                                ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_getrobust(__attr: *const pthread_mutexattr_t,
                                       __robustness:
                                           *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t,
                                       __robustness: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t,
                               __attr: *const pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_getpshared(__attr: *const pthread_rwlockattr_t,
                                         __pshared:
                                             *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t,
                                         __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t,
                                         __pref: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t,
                                         __pref: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_init(__cond: *mut pthread_cond_t,
                             __cond_attr: *const pthread_condattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t,
                             __mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_cond_timedwait(__cond: *mut pthread_cond_t,
                                  __mutex: *mut pthread_mutex_t,
                                  __abstime: *const Struct_timespec)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t,
                                       __pshared: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t,
                                       __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t,
                                     __clock_id: *mut __clockid_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t,
                                     __clock_id: __clockid_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t,
                             __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrier_init(__barrier: *mut pthread_barrier_t,
                                __attr: *const pthread_barrierattr_t,
                                __count: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrierattr_getpshared(__attr:
                                              *const pthread_barrierattr_t,
                                          __pshared:
                                              *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t,
                                          __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_key_create(__key: *mut pthread_key_t,
                              __destr_function:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
    pub fn pthread_getspecific(__key: pthread_key_t)
     -> *mut ::std::os::raw::c_void;
    pub fn pthread_setspecific(__key: pthread_key_t,
                               __pointer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn pthread_getcpuclockid(__thread_id: pthread_t,
                                 __clock_id: *mut __clockid_t)
     -> ::std::os::raw::c_int;
    pub fn pthread_atfork(__prepare: ::std::option::Option<extern "C" fn()>,
                          __parent: ::std::option::Option<extern "C" fn()>,
                          __child: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex)
     -> *mut GMutex;
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex)
     -> gboolean;
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex,
                                        depth: guint);
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex)
     -> guint;
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock)
     -> gboolean;
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock)
     -> gboolean;
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
    pub fn g_static_private_set(private_key: *mut GStaticPrivate,
                                data: gpointer, notify: GDestroyNotify);
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
    pub fn g_thread_init(vtable: gpointer);
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
    pub fn g_thread_get_initialized() -> gboolean;
    pub fn g_mutex_new() -> *mut GMutex;
    pub fn g_mutex_free(mutex: *mut GMutex);
    pub fn g_cond_new() -> *mut GCond;
    pub fn g_cond_free(cond: *mut GCond);
    pub fn g_cond_timed_wait(cond: *mut GCond, mutex: *mut GMutex,
                             timeval: *mut GTimeVal) -> gboolean;
    pub fn g_type_init();
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
    pub fn g_type_name(_type: GType) -> *const gchar;
    pub fn g_type_qname(_type: GType) -> GQuark;
    pub fn g_type_from_name(name: *const gchar) -> GType;
    pub fn g_type_parent(_type: GType) -> GType;
    pub fn g_type_depth(_type: GType) -> guint;
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
    pub fn g_type_is_a(_type: GType, is_a_type: GType) -> gboolean;
    pub fn g_type_class_ref(_type: GType) -> gpointer;
    pub fn g_type_class_peek(_type: GType) -> gpointer;
    pub fn g_type_class_peek_static(_type: GType) -> gpointer;
    pub fn g_type_class_unref(g_class: gpointer);
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType)
     -> gpointer;
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_unref(g_iface: gpointer);
    pub fn g_type_children(_type: GType, n_children: *mut guint)
     -> *mut GType;
    pub fn g_type_interfaces(_type: GType, n_interfaces: *mut guint)
     -> *mut GType;
    pub fn g_type_set_qdata(_type: GType, quark: GQuark, data: gpointer);
    pub fn g_type_get_qdata(_type: GType, quark: GQuark) -> gpointer;
    pub fn g_type_query(_type: GType, query: *mut GTypeQuery);
    pub fn g_type_get_instance_count(_type: GType) -> ::std::os::raw::c_int;
    pub fn g_type_register_static(parent_type: GType, type_name: *const gchar,
                                  info: *const GTypeInfo, flags: GTypeFlags)
     -> GType;
    pub fn g_type_register_static_simple(parent_type: GType,
                                         type_name: *const gchar,
                                         class_size: guint,
                                         class_init: GClassInitFunc,
                                         instance_size: guint,
                                         instance_init: GInstanceInitFunc,
                                         flags: GTypeFlags) -> GType;
    pub fn g_type_register_dynamic(parent_type: GType,
                                   type_name: *const gchar,
                                   plugin: *mut GTypePlugin,
                                   flags: GTypeFlags) -> GType;
    pub fn g_type_register_fundamental(type_id: GType,
                                       type_name: *const gchar,
                                       info: *const GTypeInfo,
                                       finfo: *const GTypeFundamentalInfo,
                                       flags: GTypeFlags) -> GType;
    pub fn g_type_add_interface_static(instance_type: GType,
                                       interface_type: GType,
                                       info: *const GInterfaceInfo);
    pub fn g_type_add_interface_dynamic(instance_type: GType,
                                        interface_type: GType,
                                        plugin: *mut GTypePlugin);
    pub fn g_type_interface_add_prerequisite(interface_type: GType,
                                             prerequisite_type: GType);
    pub fn g_type_interface_prerequisites(interface_type: GType,
                                          n_prerequisites: *mut guint)
     -> *mut GType;
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize)
     -> gint;
    pub fn g_type_instance_get_private(instance: *mut GTypeInstance,
                                       private_type: GType) -> gpointer;
    pub fn g_type_class_adjust_private_offset(g_class: gpointer,
                                              private_size_or_offset:
                                                  *mut gint);
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
    pub fn g_type_class_get_private(klass: *mut GTypeClass,
                                    private_type: GType) -> gpointer;
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer)
     -> gint;
    pub fn g_type_ensure(_type: GType);
    pub fn g_type_get_type_registration_serial() -> guint;
    pub fn g_type_get_plugin(_type: GType) -> *mut GTypePlugin;
    pub fn g_type_interface_get_plugin(instance_type: GType,
                                       interface_type: GType)
     -> *mut GTypePlugin;
    pub fn g_type_fundamental_next() -> GType;
    pub fn g_type_fundamental(type_id: GType) -> GType;
    pub fn g_type_create_instance(_type: GType) -> *mut GTypeInstance;
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
    pub fn g_type_add_class_cache_func(cache_data: gpointer,
                                       cache_func: GTypeClassCacheFunc);
    pub fn g_type_remove_class_cache_func(cache_data: gpointer,
                                          cache_func: GTypeClassCacheFunc);
    pub fn g_type_class_unref_uncached(g_class: gpointer);
    pub fn g_type_add_interface_check(check_data: gpointer,
                                      check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_remove_interface_check(check_data: gpointer,
                                         check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_value_table_peek(_type: GType) -> *mut GTypeValueTable;
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
    pub fn g_type_check_instance_cast(instance: *mut GTypeInstance,
                                      iface_type: GType)
     -> *mut GTypeInstance;
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance,
                                      iface_type: GType) -> gboolean;
    pub fn g_type_check_instance_is_fundamentally_a(instance:
                                                        *mut GTypeInstance,
                                                    fundamental_type: GType)
     -> gboolean;
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType)
     -> *mut GTypeClass;
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType)
     -> gboolean;
    pub fn g_type_check_is_value_type(_type: GType) -> gboolean;
    pub fn g_type_check_value(value: *mut GValue) -> gboolean;
    pub fn g_type_check_value_holds(value: *mut GValue, _type: GType)
     -> gboolean;
    pub fn g_type_test_flags(_type: GType, flags: guint) -> gboolean;
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance)
     -> *const gchar;
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
    pub fn g_value_unset(value: *mut GValue);
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType)
     -> gboolean;
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType)
     -> gboolean;
    pub fn g_value_transform(src_value: *const GValue,
                             dest_value: *mut GValue) -> gboolean;
    pub fn g_value_register_transform_func(src_type: GType, dest_type: GType,
                                           transform_func: GValueTransform);
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: GQuark)
     -> gpointer;
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: GQuark,
                                  data: gpointer);
    pub fn g_param_spec_set_qdata_full(pspec: *mut GParamSpec, quark: GQuark,
                                       data: gpointer,
                                       destroy: GDestroyNotify);
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: GQuark)
     -> gpointer;
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec)
     -> *mut GParamSpec;
    pub fn g_param_value_set_default(pspec: *mut GParamSpec,
                                     value: *mut GValue);
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *mut GValue)
     -> gboolean;
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue)
     -> gboolean;
    pub fn g_param_value_convert(pspec: *mut GParamSpec,
                                 src_value: *const GValue,
                                 dest_value: *mut GValue,
                                 strict_validation: gboolean) -> gboolean;
    pub fn g_param_values_cmp(pspec: *mut GParamSpec, value1: *const GValue,
                              value2: *const GValue) -> gint;
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_set_param_take_ownership(value: *mut GValue,
                                            param: *mut GParamSpec);
    pub fn g_param_spec_get_default_value(param: *mut GParamSpec)
     -> *const GValue;
    pub fn g_param_spec_get_name_quark(param: *mut GParamSpec) -> GQuark;
    pub fn g_param_type_register_static(name: *const gchar,
                                        pspec_info: *const GParamSpecTypeInfo)
     -> GType;
    pub fn _g_param_type_register_static_constant(name: *const gchar,
                                                  pspec_info:
                                                      *const GParamSpecTypeInfo,
                                                  opt_type: GType) -> GType;
    pub fn g_param_spec_internal(param_type: GType, name: *const gchar,
                                 nick: *const gchar, blurb: *const gchar,
                                 flags: GParamFlags) -> gpointer;
    pub fn g_param_spec_pool_new(type_prefixing: gboolean)
     -> *mut GParamSpecPool;
    pub fn g_param_spec_pool_insert(pool: *mut GParamSpecPool,
                                    pspec: *mut GParamSpec,
                                    owner_type: GType);
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool,
                                    pspec: *mut GParamSpec);
    pub fn g_param_spec_pool_lookup(pool: *mut GParamSpecPool,
                                    param_name: *const gchar,
                                    owner_type: GType,
                                    walk_ancestors: gboolean)
     -> *mut GParamSpec;
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool,
                                        owner_type: GType) -> *mut GList;
    pub fn g_param_spec_pool_list(pool: *mut GParamSpecPool,
                                  owner_type: GType, n_pspecs_p: *mut guint)
     -> *mut *mut GParamSpec;
    pub fn g_cclosure_new(callback_func: GCallback, user_data: gpointer,
                          destroy_data: GClosureNotify) -> *mut GClosure;
    pub fn g_cclosure_new_swap(callback_func: GCallback, user_data: gpointer,
                               destroy_data: GClosureNotify) -> *mut GClosure;
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint)
     -> *mut GClosure;
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
    pub fn g_closure_sink(closure: *mut GClosure);
    pub fn g_closure_unref(closure: *mut GClosure);
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer)
     -> *mut GClosure;
    pub fn g_closure_add_finalize_notifier(closure: *mut GClosure,
                                           notify_data: gpointer,
                                           notify_func: GClosureNotify);
    pub fn g_closure_remove_finalize_notifier(closure: *mut GClosure,
                                              notify_data: gpointer,
                                              notify_func: GClosureNotify);
    pub fn g_closure_add_invalidate_notifier(closure: *mut GClosure,
                                             notify_data: gpointer,
                                             notify_func: GClosureNotify);
    pub fn g_closure_remove_invalidate_notifier(closure: *mut GClosure,
                                                notify_data: gpointer,
                                                notify_func: GClosureNotify);
    pub fn g_closure_add_marshal_guards(closure: *mut GClosure,
                                        pre_marshal_data: gpointer,
                                        pre_marshal_notify: GClosureNotify,
                                        post_marshal_data: gpointer,
                                        post_marshal_notify: GClosureNotify);
    pub fn g_closure_set_marshal(closure: *mut GClosure,
                                 marshal: GClosureMarshal);
    pub fn g_closure_set_meta_marshal(closure: *mut GClosure,
                                      marshal_data: gpointer,
                                      meta_marshal: GClosureMarshal);
    pub fn g_closure_invalidate(closure: *mut GClosure);
    pub fn g_closure_invoke(closure: *mut GClosure, return_value: *mut GValue,
                            n_param_values: guint,
                            param_values: *const GValue,
                            invocation_hint: gpointer);
    pub fn g_cclosure_marshal_generic(closure: *mut GClosure,
                                      return_gvalue: *mut GValue,
                                      n_param_values: guint,
                                      param_values: *const GValue,
                                      invocation_hint: gpointer,
                                      marshal_data: gpointer);
    pub fn g_cclosure_marshal_generic_va(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         instance: gpointer,
                                         args_list: va_list,
                                         marshal_data: gpointer,
                                         n_params: ::std::os::raw::c_int,
                                         param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__VOID(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__VOIDv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::std::os::raw::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__BOOLEAN(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            n_param_values: guint,
                                            param_values: *const GValue,
                                            invocation_hint: gpointer,
                                            marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__BOOLEANv(closure: *mut GClosure,
                                             return_value: *mut GValue,
                                             instance: gpointer,
                                             args: va_list,
                                             marshal_data: gpointer,
                                             n_params: ::std::os::raw::c_int,
                                             param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__CHAR(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__CHARv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::std::os::raw::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UCHAR(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UCHARv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::std::os::raw::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__INT(closure: *mut GClosure,
                                        return_value: *mut GValue,
                                        n_param_values: guint,
                                        param_values: *const GValue,
                                        invocation_hint: gpointer,
                                        marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__INTv(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         instance: gpointer, args: va_list,
                                         marshal_data: gpointer,
                                         n_params: ::std::os::raw::c_int,
                                         param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UINT(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UINTv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::std::os::raw::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__LONG(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__LONGv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::std::os::raw::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__ULONG(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__ULONGv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::std::os::raw::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__ENUM(closure: *mut GClosure,
                                         return_value: *mut GValue,
                                         n_param_values: guint,
                                         param_values: *const GValue,
                                         invocation_hint: gpointer,
                                         marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__ENUMv(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          instance: gpointer, args: va_list,
                                          marshal_data: gpointer,
                                          n_params: ::std::os::raw::c_int,
                                          param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__FLAGS(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__FLAGSv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::std::os::raw::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__FLOAT(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__FLOATv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::std::os::raw::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__DOUBLE(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           n_param_values: guint,
                                           param_values: *const GValue,
                                           invocation_hint: gpointer,
                                           marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__DOUBLEv(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            instance: gpointer, args: va_list,
                                            marshal_data: gpointer,
                                            n_params: ::std::os::raw::c_int,
                                            param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__STRING(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           n_param_values: guint,
                                           param_values: *const GValue,
                                           invocation_hint: gpointer,
                                           marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__STRINGv(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            instance: gpointer, args: va_list,
                                            marshal_data: gpointer,
                                            n_params: ::std::os::raw::c_int,
                                            param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__PARAM(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__PARAMv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::std::os::raw::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__BOXED(closure: *mut GClosure,
                                          return_value: *mut GValue,
                                          n_param_values: guint,
                                          param_values: *const GValue,
                                          invocation_hint: gpointer,
                                          marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__BOXEDv(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           instance: gpointer, args: va_list,
                                           marshal_data: gpointer,
                                           n_params: ::std::os::raw::c_int,
                                           param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__POINTER(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            n_param_values: guint,
                                            param_values: *const GValue,
                                            invocation_hint: gpointer,
                                            marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__POINTERv(closure: *mut GClosure,
                                             return_value: *mut GValue,
                                             instance: gpointer,
                                             args: va_list,
                                             marshal_data: gpointer,
                                             n_params: ::std::os::raw::c_int,
                                             param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__OBJECT(closure: *mut GClosure,
                                           return_value: *mut GValue,
                                           n_param_values: guint,
                                           param_values: *const GValue,
                                           invocation_hint: gpointer,
                                           marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__OBJECTv(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            instance: gpointer, args: va_list,
                                            marshal_data: gpointer,
                                            n_params: ::std::os::raw::c_int,
                                            param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__VARIANT(closure: *mut GClosure,
                                            return_value: *mut GValue,
                                            n_param_values: guint,
                                            param_values: *const GValue,
                                            invocation_hint: gpointer,
                                            marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__VARIANTv(closure: *mut GClosure,
                                             return_value: *mut GValue,
                                             instance: gpointer,
                                             args: va_list,
                                             marshal_data: gpointer,
                                             n_params: ::std::os::raw::c_int,
                                             param_types: *mut GType);
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(closure: *mut GClosure,
                                                 return_value: *mut GValue,
                                                 n_param_values: guint,
                                                 param_values: *const GValue,
                                                 invocation_hint: gpointer,
                                                 marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UINT_POINTERv(closure: *mut GClosure,
                                                  return_value: *mut GValue,
                                                  instance: gpointer,
                                                  args: va_list,
                                                  marshal_data: gpointer,
                                                  n_params:
                                                      ::std::os::raw::c_int,
                                                  param_types: *mut GType);
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(closure: *mut GClosure,
                                             return_value: *mut GValue,
                                             n_param_values: guint,
                                             param_values: *const GValue,
                                             invocation_hint: gpointer,
                                             marshal_data: gpointer);
    pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(closure: *mut GClosure,
                                              return_value: *mut GValue,
                                              instance: gpointer,
                                              args: va_list,
                                              marshal_data: gpointer,
                                              n_params: ::std::os::raw::c_int,
                                              param_types: *mut GType);
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(closure: *mut GClosure,
                                                     return_value:
                                                         *mut GValue,
                                                     n_param_values: guint,
                                                     param_values:
                                                         *const GValue,
                                                     invocation_hint:
                                                         gpointer,
                                                     marshal_data: gpointer);
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(closure: *mut GClosure,
                                                      return_value:
                                                          *mut GValue,
                                                      instance: gpointer,
                                                      args: va_list,
                                                      marshal_data: gpointer,
                                                      n_params:
                                                          ::std::os::raw::c_int,
                                                      param_types:
                                                          *mut GType);
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure: *mut GClosure,
                                                   return_value: *mut GValue,
                                                   n_param_values: guint,
                                                   param_values:
                                                       *const GValue,
                                                   invocation_hint: gpointer,
                                                   marshal_data: gpointer);
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(closure: *mut GClosure,
                                                    return_value: *mut GValue,
                                                    instance: gpointer,
                                                    args: va_list,
                                                    marshal_data: gpointer,
                                                    n_params:
                                                        ::std::os::raw::c_int,
                                                    param_types: *mut GType);
    pub fn g_signal_newv(signal_name: *const gchar, itype: GType,
                         signal_flags: GSignalFlags,
                         class_closure: *mut GClosure,
                         accumulator: GSignalAccumulator, accu_data: gpointer,
                         c_marshaller: GSignalCMarshaller, return_type: GType,
                         n_params: guint, param_types: *mut GType) -> guint;
    pub fn g_signal_new_valist(signal_name: *const gchar, itype: GType,
                               signal_flags: GSignalFlags,
                               class_closure: *mut GClosure,
                               accumulator: GSignalAccumulator,
                               accu_data: gpointer,
                               c_marshaller: GSignalCMarshaller,
                               return_type: GType, n_params: guint,
                               args: va_list) -> guint;
    pub fn g_signal_new(signal_name: *const gchar, itype: GType,
                        signal_flags: GSignalFlags, class_offset: guint,
                        accumulator: GSignalAccumulator, accu_data: gpointer,
                        c_marshaller: GSignalCMarshaller, return_type: GType,
                        n_params: guint, ...) -> guint;
    pub fn g_signal_new_class_handler(signal_name: *const gchar, itype: GType,
                                      signal_flags: GSignalFlags,
                                      class_handler: GCallback,
                                      accumulator: GSignalAccumulator,
                                      accu_data: gpointer,
                                      c_marshaller: GSignalCMarshaller,
                                      return_type: GType,
                                      n_params: guint, ...) -> guint;
    pub fn g_signal_set_va_marshaller(signal_id: guint, instance_type: GType,
                                      va_marshaller: GSignalCVaMarshaller);
    pub fn g_signal_emitv(instance_and_params: *const GValue,
                          signal_id: guint, detail: GQuark,
                          return_value: *mut GValue);
    pub fn g_signal_emit_valist(instance: gpointer, signal_id: guint,
                                detail: GQuark, var_args: va_list);
    pub fn g_signal_emit(instance: gpointer, signal_id: guint,
                         detail: GQuark, ...);
    pub fn g_signal_emit_by_name(instance: gpointer,
                                 detailed_signal: *const gchar, ...);
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut guint) -> *mut guint;
    pub fn g_signal_parse_name(detailed_signal: *const gchar, itype: GType,
                               signal_id_p: *mut guint, detail_p: *mut GQuark,
                               force_detail_quark: gboolean) -> gboolean;
    pub fn g_signal_get_invocation_hint(instance: gpointer)
     -> *mut GSignalInvocationHint;
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint,
                                  detail: GQuark);
    pub fn g_signal_stop_emission_by_name(instance: gpointer,
                                          detailed_signal: *const gchar);
    pub fn g_signal_add_emission_hook(signal_id: guint, detail: GQuark,
                                      hook_func: GSignalEmissionHook,
                                      hook_data: gpointer,
                                      data_destroy: GDestroyNotify) -> gulong;
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
    pub fn g_signal_has_handler_pending(instance: gpointer, signal_id: guint,
                                        detail: GQuark,
                                        may_be_blocked: gboolean) -> gboolean;
    pub fn g_signal_connect_closure_by_id(instance: gpointer,
                                          signal_id: guint, detail: GQuark,
                                          closure: *mut GClosure,
                                          after: gboolean) -> gulong;
    pub fn g_signal_connect_closure(instance: gpointer,
                                    detailed_signal: *const gchar,
                                    closure: *mut GClosure, after: gboolean)
     -> gulong;
    pub fn g_signal_connect_data(instance: gpointer,
                                 detailed_signal: *const gchar,
                                 c_handler: GCallback, data: gpointer,
                                 destroy_data: GClosureNotify,
                                 connect_flags: GConnectFlags) -> gulong;
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
    pub fn g_signal_handler_disconnect(instance: gpointer,
                                       handler_id: gulong);
    pub fn g_signal_handler_is_connected(instance: gpointer,
                                         handler_id: gulong) -> gboolean;
    pub fn g_signal_handler_find(instance: gpointer, mask: GSignalMatchType,
                                 signal_id: guint, detail: GQuark,
                                 closure: *mut GClosure, func: gpointer,
                                 data: gpointer) -> gulong;
    pub fn g_signal_handlers_block_matched(instance: gpointer,
                                           mask: GSignalMatchType,
                                           signal_id: guint, detail: GQuark,
                                           closure: *mut GClosure,
                                           func: gpointer, data: gpointer)
     -> guint;
    pub fn g_signal_handlers_unblock_matched(instance: gpointer,
                                             mask: GSignalMatchType,
                                             signal_id: guint, detail: GQuark,
                                             closure: *mut GClosure,
                                             func: gpointer, data: gpointer)
     -> guint;
    pub fn g_signal_handlers_disconnect_matched(instance: gpointer,
                                                mask: GSignalMatchType,
                                                signal_id: guint,
                                                detail: GQuark,
                                                closure: *mut GClosure,
                                                func: gpointer,
                                                data: gpointer) -> guint;
    pub fn g_signal_override_class_closure(signal_id: guint,
                                           instance_type: GType,
                                           class_closure: *mut GClosure);
    pub fn g_signal_override_class_handler(signal_name: *const gchar,
                                           instance_type: GType,
                                           class_handler: GCallback);
    pub fn g_signal_chain_from_overridden(instance_and_params: *const GValue,
                                          return_value: *mut GValue);
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
    pub fn g_signal_accumulator_true_handled(ihint:
                                                 *mut GSignalInvocationHint,
                                             return_accu: *mut GValue,
                                             handler_return: *const GValue,
                                             dummy: gpointer) -> gboolean;
    pub fn g_signal_accumulator_first_wins(ihint: *mut GSignalInvocationHint,
                                           return_accu: *mut GValue,
                                           handler_return: *const GValue,
                                           dummy: gpointer) -> gboolean;
    pub fn g_signal_handlers_destroy(instance: gpointer);
    pub fn _g_signals_destroy(itype: GType);
    pub fn g_date_get_type() -> GType;
    pub fn g_strv_get_type() -> GType;
    pub fn g_gstring_get_type() -> GType;
    pub fn g_hash_table_get_type() -> GType;
    pub fn g_array_get_type() -> GType;
    pub fn g_byte_array_get_type() -> GType;
    pub fn g_ptr_array_get_type() -> GType;
    pub fn g_bytes_get_type() -> GType;
    pub fn g_variant_type_get_gtype() -> GType;
    pub fn g_regex_get_type() -> GType;
    pub fn g_match_info_get_type() -> GType;
    pub fn g_error_get_type() -> GType;
    pub fn g_date_time_get_type() -> GType;
    pub fn g_time_zone_get_type() -> GType;
    pub fn g_io_channel_get_type() -> GType;
    pub fn g_io_condition_get_type() -> GType;
    pub fn g_variant_builder_get_type() -> GType;
    pub fn g_variant_dict_get_type() -> GType;
    pub fn g_key_file_get_type() -> GType;
    pub fn g_main_loop_get_type() -> GType;
    pub fn g_main_context_get_type() -> GType;
    pub fn g_source_get_type() -> GType;
    pub fn g_pollfd_get_type() -> GType;
    pub fn g_thread_get_type() -> GType;
    pub fn g_checksum_get_type() -> GType;
    pub fn g_markup_parse_context_get_type() -> GType;
    pub fn g_mapped_file_get_type() -> GType;
    pub fn g_option_group_get_type() -> GType;
    pub fn g_variant_get_gtype() -> GType;
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer)
     -> gpointer;
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_static_boxed(value: *mut GValue,
                                    v_boxed: gconstpointer);
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue,
                                            v_boxed: gconstpointer);
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
    pub fn g_boxed_type_register_static(name: *const gchar,
                                        boxed_copy: GBoxedCopyFunc,
                                        boxed_free: GBoxedFreeFunc) -> GType;
    pub fn g_closure_get_type() -> GType;
    pub fn g_value_get_type() -> GType;
    pub fn g_initially_unowned_get_type() -> GType;
    pub fn g_object_class_install_property(oclass: *mut GObjectClass,
                                           property_id: guint,
                                           pspec: *mut GParamSpec);
    pub fn g_object_class_find_property(oclass: *mut GObjectClass,
                                        property_name: *const gchar)
     -> *mut GParamSpec;
    pub fn g_object_class_list_properties(oclass: *mut GObjectClass,
                                          n_properties: *mut guint)
     -> *mut *mut GParamSpec;
    pub fn g_object_class_override_property(oclass: *mut GObjectClass,
                                            property_id: guint,
                                            name: *const gchar);
    pub fn g_object_class_install_properties(oclass: *mut GObjectClass,
                                             n_pspecs: guint,
                                             pspecs: *mut *mut GParamSpec);
    pub fn g_object_interface_install_property(g_iface: gpointer,
                                               pspec: *mut GParamSpec);
    pub fn g_object_interface_find_property(g_iface: gpointer,
                                            property_name: *const gchar)
     -> *mut GParamSpec;
    pub fn g_object_interface_list_properties(g_iface: gpointer,
                                              n_properties_p: *mut guint)
     -> *mut *mut GParamSpec;
    pub fn g_object_get_type() -> GType;
    pub fn g_object_new(object_type: GType,
                        first_property_name: *const gchar, ...) -> gpointer;
    pub fn g_object_newv(object_type: GType, n_parameters: guint,
                         parameters: *mut GParameter) -> gpointer;
    pub fn g_object_new_valist(object_type: GType,
                               first_property_name: *const gchar,
                               var_args: va_list) -> *mut GObject;
    pub fn g_object_set(object: gpointer,
                        first_property_name: *const gchar, ...);
    pub fn g_object_get(object: gpointer,
                        first_property_name: *const gchar, ...);
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...)
     -> gpointer;
    pub fn g_object_disconnect(object: gpointer,
                               signal_spec: *const gchar, ...);
    pub fn g_object_set_valist(object: *mut GObject,
                               first_property_name: *const gchar,
                               var_args: va_list);
    pub fn g_object_get_valist(object: *mut GObject,
                               first_property_name: *const gchar,
                               var_args: va_list);
    pub fn g_object_set_property(object: *mut GObject,
                                 property_name: *const gchar,
                                 value: *const GValue);
    pub fn g_object_get_property(object: *mut GObject,
                                 property_name: *const gchar,
                                 value: *mut GValue);
    pub fn g_object_freeze_notify(object: *mut GObject);
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
    pub fn g_object_notify_by_pspec(object: *mut GObject,
                                    pspec: *mut GParamSpec);
    pub fn g_object_thaw_notify(object: *mut GObject);
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
    pub fn g_object_ref(object: gpointer) -> gpointer;
    pub fn g_object_unref(object: gpointer);
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify,
                             data: gpointer);
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify,
                               data: gpointer);
    pub fn g_object_add_weak_pointer(object: *mut GObject,
                                     weak_pointer_location: *mut gpointer);
    pub fn g_object_remove_weak_pointer(object: *mut GObject,
                                        weak_pointer_location: *mut gpointer);
    pub fn g_object_add_toggle_ref(object: *mut GObject,
                                   notify: GToggleNotify, data: gpointer);
    pub fn g_object_remove_toggle_ref(object: *mut GObject,
                                      notify: GToggleNotify, data: gpointer);
    pub fn g_object_get_qdata(object: *mut GObject, quark: GQuark)
     -> gpointer;
    pub fn g_object_set_qdata(object: *mut GObject, quark: GQuark,
                              data: gpointer);
    pub fn g_object_set_qdata_full(object: *mut GObject, quark: GQuark,
                                   data: gpointer, destroy: GDestroyNotify);
    pub fn g_object_steal_qdata(object: *mut GObject, quark: GQuark)
     -> gpointer;
    pub fn g_object_dup_qdata(object: *mut GObject, quark: GQuark,
                              dup_func: GDuplicateFunc, user_data: gpointer)
     -> gpointer;
    pub fn g_object_replace_qdata(object: *mut GObject, quark: GQuark,
                                  oldval: gpointer, newval: gpointer,
                                  destroy: GDestroyNotify,
                                  old_destroy: *mut GDestroyNotify)
     -> gboolean;
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar)
     -> gpointer;
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar,
                             data: gpointer);
    pub fn g_object_set_data_full(object: *mut GObject, key: *const gchar,
                                  data: gpointer, destroy: GDestroyNotify);
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar)
     -> gpointer;
    pub fn g_object_dup_data(object: *mut GObject, key: *const gchar,
                             dup_func: GDuplicateFunc, user_data: gpointer)
     -> gpointer;
    pub fn g_object_replace_data(object: *mut GObject, key: *const gchar,
                                 oldval: gpointer, newval: gpointer,
                                 destroy: GDestroyNotify,
                                 old_destroy: *mut GDestroyNotify)
     -> gboolean;
    pub fn g_object_watch_closure(object: *mut GObject,
                                  closure: *mut GClosure);
    pub fn g_cclosure_new_object(callback_func: GCallback,
                                 object: *mut GObject) -> *mut GClosure;
    pub fn g_cclosure_new_object_swap(callback_func: GCallback,
                                      object: *mut GObject) -> *mut GClosure;
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject)
     -> *mut GClosure;
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
    pub fn g_signal_connect_object(instance: gpointer,
                                   detailed_signal: *const gchar,
                                   c_handler: GCallback, gobject: gpointer,
                                   connect_flags: GConnectFlags) -> gulong;
    pub fn g_object_force_floating(object: *mut GObject);
    pub fn g_object_run_dispose(object: *mut GObject);
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
    pub fn g_value_set_object_take_ownership(value: *mut GValue,
                                             v_object: gpointer);
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: gpointer);
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> gpointer;
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
    pub fn g_binding_flags_get_type() -> GType;
    pub fn g_binding_get_type() -> GType;
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_source_property(binding: *mut GBinding)
     -> *const gchar;
    pub fn g_binding_get_target_property(binding: *mut GBinding)
     -> *const gchar;
    pub fn g_binding_unbind(binding: *mut GBinding);
    pub fn g_object_bind_property(source: gpointer,
                                  source_property: *const gchar,
                                  target: gpointer,
                                  target_property: *const gchar,
                                  flags: GBindingFlags) -> *mut GBinding;
    pub fn g_object_bind_property_full(source: gpointer,
                                       source_property: *const gchar,
                                       target: gpointer,
                                       target_property: *const gchar,
                                       flags: GBindingFlags,
                                       transform_to: GBindingTransformFunc,
                                       transform_from: GBindingTransformFunc,
                                       user_data: gpointer,
                                       notify: GDestroyNotify)
     -> *mut GBinding;
    pub fn g_object_bind_property_with_closures(source: gpointer,
                                                source_property: *const gchar,
                                                target: gpointer,
                                                target_property: *const gchar,
                                                flags: GBindingFlags,
                                                transform_to: *mut GClosure,
                                                transform_from: *mut GClosure)
     -> *mut GBinding;
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint)
     -> *mut GEnumValue;
    pub fn g_enum_get_value_by_name(enum_class: *mut GEnumClass,
                                    name: *const gchar) -> *mut GEnumValue;
    pub fn g_enum_get_value_by_nick(enum_class: *mut GEnumClass,
                                    nick: *const gchar) -> *mut GEnumValue;
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass,
                                   value: guint) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_name(flags_class: *mut GFlagsClass,
                                     name: *const gchar) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_nick(flags_class: *mut GFlagsClass,
                                     nick: *const gchar) -> *mut GFlagsValue;
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
    pub fn g_value_get_enum(value: *const GValue) -> gint;
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
    pub fn g_value_get_flags(value: *const GValue) -> guint;
    pub fn g_enum_register_static(name: *const gchar,
                                  const_static_values: *const GEnumValue)
     -> GType;
    pub fn g_flags_register_static(name: *const gchar,
                                   const_static_values: *const GFlagsValue)
     -> GType;
    pub fn g_enum_complete_type_info(g_enum_type: GType, info: *mut GTypeInfo,
                                     const_values: *const GEnumValue);
    pub fn g_flags_complete_type_info(g_flags_type: GType,
                                      info: *mut GTypeInfo,
                                      const_values: *const GFlagsValue);
    pub fn g_param_spec_char(name: *const gchar, nick: *const gchar,
                             blurb: *const gchar, minimum: gint8,
                             maximum: gint8, default_value: gint8,
                             flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uchar(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, minimum: guint8,
                              maximum: guint8, default_value: guint8,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_boolean(name: *const gchar, nick: *const gchar,
                                blurb: *const gchar, default_value: gboolean,
                                flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_int(name: *const gchar, nick: *const gchar,
                            blurb: *const gchar, minimum: gint, maximum: gint,
                            default_value: gint, flags: GParamFlags)
     -> *mut GParamSpec;
    pub fn g_param_spec_uint(name: *const gchar, nick: *const gchar,
                             blurb: *const gchar, minimum: guint,
                             maximum: guint, default_value: guint,
                             flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_long(name: *const gchar, nick: *const gchar,
                             blurb: *const gchar, minimum: glong,
                             maximum: glong, default_value: glong,
                             flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_ulong(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, minimum: gulong,
                              maximum: gulong, default_value: gulong,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_int64(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, minimum: gint64,
                              maximum: gint64, default_value: gint64,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uint64(name: *const gchar, nick: *const gchar,
                               blurb: *const gchar, minimum: guint64,
                               maximum: guint64, default_value: guint64,
                               flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_unichar(name: *const gchar, nick: *const gchar,
                                blurb: *const gchar, default_value: gunichar,
                                flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_enum(name: *const gchar, nick: *const gchar,
                             blurb: *const gchar, enum_type: GType,
                             default_value: gint, flags: GParamFlags)
     -> *mut GParamSpec;
    pub fn g_param_spec_flags(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, flags_type: GType,
                              default_value: guint, flags: GParamFlags)
     -> *mut GParamSpec;
    pub fn g_param_spec_float(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, minimum: gfloat,
                              maximum: gfloat, default_value: gfloat,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_double(name: *const gchar, nick: *const gchar,
                               blurb: *const gchar, minimum: gdouble,
                               maximum: gdouble, default_value: gdouble,
                               flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_string(name: *const gchar, nick: *const gchar,
                               blurb: *const gchar,
                               default_value: *const gchar,
                               flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_param(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, param_type: GType,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_boxed(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, boxed_type: GType,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_pointer(name: *const gchar, nick: *const gchar,
                                blurb: *const gchar, flags: GParamFlags)
     -> *mut GParamSpec;
    pub fn g_param_spec_value_array(name: *const gchar, nick: *const gchar,
                                    blurb: *const gchar,
                                    element_spec: *mut GParamSpec,
                                    flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_object(name: *const gchar, nick: *const gchar,
                               blurb: *const gchar, object_type: GType,
                               flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_override(name: *const gchar,
                                 overridden: *mut GParamSpec)
     -> *mut GParamSpec;
    pub fn g_param_spec_gtype(name: *const gchar, nick: *const gchar,
                              blurb: *const gchar, is_a_type: GType,
                              flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_variant(name: *const gchar, nick: *const gchar,
                                blurb: *const gchar,
                                _type: *const GVariantType,
                                default_value: *mut GVariant,
                                flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_source_set_closure(source: *mut GSource, closure: *mut GClosure);
    pub fn g_source_set_dummy_callback(source: *mut GSource);
    pub fn g_type_module_get_type() -> GType;
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
    pub fn g_type_module_unuse(module: *mut GTypeModule);
    pub fn g_type_module_set_name(module: *mut GTypeModule,
                                  name: *const gchar);
    pub fn g_type_module_register_type(module: *mut GTypeModule,
                                       parent_type: GType,
                                       type_name: *const gchar,
                                       type_info: *const GTypeInfo,
                                       flags: GTypeFlags) -> GType;
    pub fn g_type_module_add_interface(module: *mut GTypeModule,
                                       instance_type: GType,
                                       interface_type: GType,
                                       interface_info: *const GInterfaceInfo);
    pub fn g_type_module_register_enum(module: *mut GTypeModule,
                                       name: *const gchar,
                                       const_static_values: *const GEnumValue)
     -> GType;
    pub fn g_type_module_register_flags(module: *mut GTypeModule,
                                        name: *const gchar,
                                        const_static_values:
                                            *const GFlagsValue) -> GType;
    pub fn g_type_plugin_get_type() -> GType;
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
    pub fn g_type_plugin_complete_type_info(plugin: *mut GTypePlugin,
                                            g_type: GType,
                                            info: *mut GTypeInfo,
                                            value_table:
                                                *mut GTypeValueTable);
    pub fn g_type_plugin_complete_interface_info(plugin: *mut GTypePlugin,
                                                 instance_type: GType,
                                                 interface_type: GType,
                                                 info: *mut GInterfaceInfo);
    pub fn g_value_array_get_type() -> GType;
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint)
     -> *mut GValue;
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
    pub fn g_value_array_free(value_array: *mut GValueArray);
    pub fn g_value_array_copy(value_array: *const GValueArray)
     -> *mut GValueArray;
    pub fn g_value_array_prepend(value_array: *mut GValueArray,
                                 value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_append(value_array: *mut GValueArray,
                                value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_insert(value_array: *mut GValueArray, index_: guint,
                                value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint)
     -> *mut GValueArray;
    pub fn g_value_array_sort(value_array: *mut GValueArray,
                              compare_func: GCompareFunc) -> *mut GValueArray;
    pub fn g_value_array_sort_with_data(value_array: *mut GValueArray,
                                        compare_func: GCompareDataFunc,
                                        user_data: gpointer)
     -> *mut GValueArray;
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
    pub fn g_value_get_char(value: *const GValue) -> gchar;
    pub fn g_value_set_schar(value: *mut GValue, v_char: gint8);
    pub fn g_value_get_schar(value: *const GValue) -> gint8;
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: guchar);
    pub fn g_value_get_uchar(value: *const GValue) -> guchar;
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
    pub fn g_value_get_int(value: *const GValue) -> gint;
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
    pub fn g_value_get_uint(value: *const GValue) -> guint;
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
    pub fn g_value_get_long(value: *const GValue) -> glong;
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
    pub fn g_value_set_int64(value: *mut GValue, v_int64: gint64);
    pub fn g_value_get_int64(value: *const GValue) -> gint64;
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: guint64);
    pub fn g_value_get_uint64(value: *const GValue) -> guint64;
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
    pub fn g_value_set_static_string(value: *mut GValue,
                                     v_string: *const gchar);
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
    pub fn g_gtype_get_type() -> GType;
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut GVariant);
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut GVariant);
    pub fn g_value_get_variant(value: *const GValue) -> *mut GVariant;
    pub fn g_value_dup_variant(value: *const GValue) -> *mut GVariant;
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
    pub fn g_value_set_string_take_ownership(value: *mut GValue,
                                             v_string: *mut gchar);
    pub fn hif_advisory_get_type() -> GType;
    pub fn hif_advisory_get_title(advisory: *mut HifAdvisory)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisory_get_id(advisory: *mut HifAdvisory)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisory_get_kind(advisory: *mut HifAdvisory)
     -> HifAdvisoryKind;
    pub fn hif_advisory_get_description(advisory: *mut HifAdvisory)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisory_get_rights(advisory: *mut HifAdvisory)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisory_get_updated(advisory: *mut HifAdvisory) -> guint64;
    pub fn hif_advisory_get_packages(advisory: *mut HifAdvisory)
     -> *mut GPtrArray;
    pub fn hif_advisory_get_references(advisory: *mut HifAdvisory)
     -> *mut GPtrArray;
    pub fn hif_advisory_compare(left: *mut HifAdvisory,
                                right: *mut HifAdvisory)
     -> ::std::os::raw::c_int;
    pub fn hif_advisorypkg_get_type() -> GType;
    pub fn hif_advisorypkg_get_name(advisorypkg: *mut HifAdvisoryPkg)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisorypkg_get_evr(advisorypkg: *mut HifAdvisoryPkg)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisorypkg_get_arch(advisorypkg: *mut HifAdvisoryPkg)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisorypkg_get_filename(advisorypkg: *mut HifAdvisoryPkg)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisorypkg_compare(left: *mut HifAdvisoryPkg,
                                   right: *mut HifAdvisoryPkg)
     -> ::std::os::raw::c_int;
    pub fn hif_advisoryref_get_type() -> GType;
    pub fn hif_advisoryref_get_kind(advisoryref: *mut HifAdvisoryRef)
     -> HifAdvisoryRefKind;
    pub fn hif_advisoryref_get_id(advisoryref: *mut HifAdvisoryRef)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisoryref_get_title(advisoryref: *mut HifAdvisoryRef)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisoryref_get_url(advisoryref: *mut HifAdvisoryRef)
     -> *const ::std::os::raw::c_char;
    pub fn hif_advisoryref_compare(left: *mut HifAdvisoryRef,
                                   right: *mut HifAdvisoryRef)
     -> ::std::os::raw::c_int;
    pub fn g_action_get_type() -> GType;
    pub fn g_action_get_name(action: *mut GAction) -> *const gchar;
    pub fn g_action_get_parameter_type(action: *mut GAction)
     -> *const GVariantType;
    pub fn g_action_get_state_type(action: *mut GAction)
     -> *const GVariantType;
    pub fn g_action_get_state_hint(action: *mut GAction) -> *mut GVariant;
    pub fn g_action_get_enabled(action: *mut GAction) -> gboolean;
    pub fn g_action_get_state(action: *mut GAction) -> *mut GVariant;
    pub fn g_action_change_state(action: *mut GAction, value: *mut GVariant);
    pub fn g_action_activate(action: *mut GAction, parameter: *mut GVariant);
    pub fn g_action_name_is_valid(action_name: *const gchar) -> gboolean;
    pub fn g_action_parse_detailed_name(detailed_name: *const gchar,
                                        action_name: *mut *mut gchar,
                                        target_value: *mut *mut GVariant,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_action_print_detailed_name(action_name: *const gchar,
                                        target_value: *mut GVariant)
     -> *mut gchar;
    pub fn g_action_group_get_type() -> GType;
    pub fn g_action_group_has_action(action_group: *mut GActionGroup,
                                     action_name: *const gchar) -> gboolean;
    pub fn g_action_group_list_actions(action_group: *mut GActionGroup)
     -> *mut *mut gchar;
    pub fn g_action_group_get_action_parameter_type(action_group:
                                                        *mut GActionGroup,
                                                    action_name: *const gchar)
     -> *const GVariantType;
    pub fn g_action_group_get_action_state_type(action_group:
                                                    *mut GActionGroup,
                                                action_name: *const gchar)
     -> *const GVariantType;
    pub fn g_action_group_get_action_state_hint(action_group:
                                                    *mut GActionGroup,
                                                action_name: *const gchar)
     -> *mut GVariant;
    pub fn g_action_group_get_action_enabled(action_group: *mut GActionGroup,
                                             action_name: *const gchar)
     -> gboolean;
    pub fn g_action_group_get_action_state(action_group: *mut GActionGroup,
                                           action_name: *const gchar)
     -> *mut GVariant;
    pub fn g_action_group_change_action_state(action_group: *mut GActionGroup,
                                              action_name: *const gchar,
                                              value: *mut GVariant);
    pub fn g_action_group_activate_action(action_group: *mut GActionGroup,
                                          action_name: *const gchar,
                                          parameter: *mut GVariant);
    pub fn g_action_group_action_added(action_group: *mut GActionGroup,
                                       action_name: *const gchar);
    pub fn g_action_group_action_removed(action_group: *mut GActionGroup,
                                         action_name: *const gchar);
    pub fn g_action_group_action_enabled_changed(action_group:
                                                     *mut GActionGroup,
                                                 action_name: *const gchar,
                                                 enabled: gboolean);
    pub fn g_action_group_action_state_changed(action_group:
                                                   *mut GActionGroup,
                                               action_name: *const gchar,
                                               state: *mut GVariant);
    pub fn g_action_group_query_action(action_group: *mut GActionGroup,
                                       action_name: *const gchar,
                                       enabled: *mut gboolean,
                                       parameter_type:
                                           *mut *const GVariantType,
                                       state_type: *mut *const GVariantType,
                                       state_hint: *mut *mut GVariant,
                                       state: *mut *mut GVariant) -> gboolean;
    pub fn g_dbus_connection_export_action_group(connection:
                                                     *mut GDBusConnection,
                                                 object_path: *const gchar,
                                                 action_group:
                                                     *mut GActionGroup,
                                                 error: *mut *mut GError)
     -> guint;
    pub fn g_dbus_connection_unexport_action_group(connection:
                                                       *mut GDBusConnection,
                                                   export_id: guint);
    pub fn g_action_map_get_type() -> GType;
    pub fn g_action_map_lookup_action(action_map: *mut GActionMap,
                                      action_name: *const gchar)
     -> *mut GAction;
    pub fn g_action_map_add_action(action_map: *mut GActionMap,
                                   action: *mut GAction);
    pub fn g_action_map_remove_action(action_map: *mut GActionMap,
                                      action_name: *const gchar);
    pub fn g_action_map_add_action_entries(action_map: *mut GActionMap,
                                           entries: *const GActionEntry,
                                           n_entries: gint,
                                           user_data: gpointer);
    pub fn g_app_info_get_type() -> GType;
    pub fn g_app_info_create_from_commandline(commandline:
                                                  *const ::std::os::raw::c_char,
                                              application_name:
                                                  *const ::std::os::raw::c_char,
                                              flags: GAppInfoCreateFlags,
                                              error: *mut *mut GError)
     -> *mut GAppInfo;
    pub fn g_app_info_dup(appinfo: *mut GAppInfo) -> *mut GAppInfo;
    pub fn g_app_info_equal(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo)
     -> gboolean;
    pub fn g_app_info_get_id(appinfo: *mut GAppInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_app_info_get_name(appinfo: *mut GAppInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_app_info_get_display_name(appinfo: *mut GAppInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_app_info_get_description(appinfo: *mut GAppInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_app_info_get_executable(appinfo: *mut GAppInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_app_info_get_commandline(appinfo: *mut GAppInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_app_info_get_icon(appinfo: *mut GAppInfo) -> *mut GIcon;
    pub fn g_app_info_launch(appinfo: *mut GAppInfo, files: *mut GList,
                             launch_context: *mut GAppLaunchContext,
                             error: *mut *mut GError) -> gboolean;
    pub fn g_app_info_supports_uris(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_supports_files(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_launch_uris(appinfo: *mut GAppInfo, uris: *mut GList,
                                  launch_context: *mut GAppLaunchContext,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_app_info_should_show(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_set_as_default_for_type(appinfo: *mut GAppInfo,
                                              content_type:
                                                  *const ::std::os::raw::c_char,
                                              error: *mut *mut GError)
     -> gboolean;
    pub fn g_app_info_set_as_default_for_extension(appinfo: *mut GAppInfo,
                                                   extension:
                                                       *const ::std::os::raw::c_char,
                                                   error: *mut *mut GError)
     -> gboolean;
    pub fn g_app_info_add_supports_type(appinfo: *mut GAppInfo,
                                        content_type:
                                            *const ::std::os::raw::c_char,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_app_info_can_remove_supports_type(appinfo: *mut GAppInfo)
     -> gboolean;
    pub fn g_app_info_remove_supports_type(appinfo: *mut GAppInfo,
                                           content_type:
                                               *const ::std::os::raw::c_char,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_app_info_get_supported_types(appinfo: *mut GAppInfo)
     -> *mut *const ::std::os::raw::c_char;
    pub fn g_app_info_can_delete(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_delete(appinfo: *mut GAppInfo) -> gboolean;
    pub fn g_app_info_set_as_last_used_for_type(appinfo: *mut GAppInfo,
                                                content_type:
                                                    *const ::std::os::raw::c_char,
                                                error: *mut *mut GError)
     -> gboolean;
    pub fn g_app_info_get_all() -> *mut GList;
    pub fn g_app_info_get_all_for_type(content_type:
                                           *const ::std::os::raw::c_char)
     -> *mut GList;
    pub fn g_app_info_get_recommended_for_type(content_type: *const gchar)
     -> *mut GList;
    pub fn g_app_info_get_fallback_for_type(content_type: *const gchar)
     -> *mut GList;
    pub fn g_app_info_reset_type_associations(content_type:
                                                  *const ::std::os::raw::c_char);
    pub fn g_app_info_get_default_for_type(content_type:
                                               *const ::std::os::raw::c_char,
                                           must_support_uris: gboolean)
     -> *mut GAppInfo;
    pub fn g_app_info_get_default_for_uri_scheme(uri_scheme:
                                                     *const ::std::os::raw::c_char)
     -> *mut GAppInfo;
    pub fn g_app_info_launch_default_for_uri(uri:
                                                 *const ::std::os::raw::c_char,
                                             launch_context:
                                                 *mut GAppLaunchContext,
                                             error: *mut *mut GError)
     -> gboolean;
    pub fn g_app_launch_context_get_type() -> GType;
    pub fn g_app_launch_context_new() -> *mut GAppLaunchContext;
    pub fn g_app_launch_context_setenv(context: *mut GAppLaunchContext,
                                       variable:
                                           *const ::std::os::raw::c_char,
                                       value: *const ::std::os::raw::c_char);
    pub fn g_app_launch_context_unsetenv(context: *mut GAppLaunchContext,
                                         variable:
                                             *const ::std::os::raw::c_char);
    pub fn g_app_launch_context_get_environment(context:
                                                    *mut GAppLaunchContext)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn g_app_launch_context_get_display(context: *mut GAppLaunchContext,
                                            info: *mut GAppInfo,
                                            files: *mut GList)
     -> *mut ::std::os::raw::c_char;
    pub fn g_app_launch_context_get_startup_notify_id(context:
                                                          *mut GAppLaunchContext,
                                                      info: *mut GAppInfo,
                                                      files: *mut GList)
     -> *mut ::std::os::raw::c_char;
    pub fn g_app_launch_context_launch_failed(context: *mut GAppLaunchContext,
                                              startup_notify_id:
                                                  *const ::std::os::raw::c_char);
    pub fn g_app_info_monitor_get_type() -> GType;
    pub fn g_app_info_monitor_get() -> *mut GAppInfoMonitor;
    pub fn g_application_get_type() -> GType;
    pub fn g_application_id_is_valid(application_id: *const gchar)
     -> gboolean;
    pub fn g_application_new(application_id: *const gchar,
                             flags: GApplicationFlags) -> *mut GApplication;
    pub fn g_application_get_application_id(application: *mut GApplication)
     -> *const gchar;
    pub fn g_application_set_application_id(application: *mut GApplication,
                                            application_id: *const gchar);
    pub fn g_application_get_dbus_connection(application: *mut GApplication)
     -> *mut GDBusConnection;
    pub fn g_application_get_dbus_object_path(application: *mut GApplication)
     -> *const gchar;
    pub fn g_application_get_inactivity_timeout(application:
                                                    *mut GApplication)
     -> guint;
    pub fn g_application_set_inactivity_timeout(application:
                                                    *mut GApplication,
                                                inactivity_timeout: guint);
    pub fn g_application_get_flags(application: *mut GApplication)
     -> GApplicationFlags;
    pub fn g_application_set_flags(application: *mut GApplication,
                                   flags: GApplicationFlags);
    pub fn g_application_get_resource_base_path(application:
                                                    *mut GApplication)
     -> *const gchar;
    pub fn g_application_set_resource_base_path(application:
                                                    *mut GApplication,
                                                resource_path: *const gchar);
    pub fn g_application_set_action_group(application: *mut GApplication,
                                          action_group: *mut GActionGroup);
    pub fn g_application_add_main_option_entries(application:
                                                     *mut GApplication,
                                                 entries:
                                                     *const GOptionEntry);
    pub fn g_application_add_main_option(application: *mut GApplication,
                                         long_name:
                                             *const ::std::os::raw::c_char,
                                         short_name: ::std::os::raw::c_char,
                                         flags: GOptionFlags, arg: GOptionArg,
                                         description:
                                             *const ::std::os::raw::c_char,
                                         arg_description:
                                             *const ::std::os::raw::c_char);
    pub fn g_application_add_option_group(application: *mut GApplication,
                                          group: *mut GOptionGroup);
    pub fn g_application_get_is_registered(application: *mut GApplication)
     -> gboolean;
    pub fn g_application_get_is_remote(application: *mut GApplication)
     -> gboolean;
    pub fn g_application_register(application: *mut GApplication,
                                  cancellable: *mut GCancellable,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_application_hold(application: *mut GApplication);
    pub fn g_application_release(application: *mut GApplication);
    pub fn g_application_activate(application: *mut GApplication);
    pub fn g_application_open(application: *mut GApplication,
                              files: *mut *mut GFile, n_files: gint,
                              hint: *const gchar);
    pub fn g_application_run(application: *mut GApplication,
                             argc: ::std::os::raw::c_int,
                             argv: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn g_application_quit(application: *mut GApplication);
    pub fn g_application_get_default() -> *mut GApplication;
    pub fn g_application_set_default(application: *mut GApplication);
    pub fn g_application_mark_busy(application: *mut GApplication);
    pub fn g_application_unmark_busy(application: *mut GApplication);
    pub fn g_application_get_is_busy(application: *mut GApplication)
     -> gboolean;
    pub fn g_application_send_notification(application: *mut GApplication,
                                           id: *const gchar,
                                           notification: *mut GNotification);
    pub fn g_application_withdraw_notification(application: *mut GApplication,
                                               id: *const gchar);
    pub fn g_application_bind_busy_property(application: *mut GApplication,
                                            object: gpointer,
                                            property: *const gchar);
    pub fn g_application_unbind_busy_property(application: *mut GApplication,
                                              object: gpointer,
                                              property: *const gchar);
    pub fn g_application_command_line_get_type() -> GType;
    pub fn g_application_command_line_get_arguments(cmdline:
                                                        *mut GApplicationCommandLine,
                                                    argc:
                                                        *mut ::std::os::raw::c_int)
     -> *mut *mut gchar;
    pub fn g_application_command_line_get_options_dict(cmdline:
                                                           *mut GApplicationCommandLine)
     -> *mut GVariantDict;
    pub fn g_application_command_line_get_stdin(cmdline:
                                                    *mut GApplicationCommandLine)
     -> *mut GInputStream;
    pub fn g_application_command_line_get_environ(cmdline:
                                                      *mut GApplicationCommandLine)
     -> *const *const gchar;
    pub fn g_application_command_line_getenv(cmdline:
                                                 *mut GApplicationCommandLine,
                                             name: *const gchar)
     -> *const gchar;
    pub fn g_application_command_line_get_cwd(cmdline:
                                                  *mut GApplicationCommandLine)
     -> *const gchar;
    pub fn g_application_command_line_get_is_remote(cmdline:
                                                        *mut GApplicationCommandLine)
     -> gboolean;
    pub fn g_application_command_line_print(cmdline:
                                                *mut GApplicationCommandLine,
                                            format: *const gchar, ...);
    pub fn g_application_command_line_printerr(cmdline:
                                                   *mut GApplicationCommandLine,
                                               format: *const gchar, ...);
    pub fn g_application_command_line_get_exit_status(cmdline:
                                                          *mut GApplicationCommandLine)
     -> ::std::os::raw::c_int;
    pub fn g_application_command_line_set_exit_status(cmdline:
                                                          *mut GApplicationCommandLine,
                                                      exit_status:
                                                          ::std::os::raw::c_int);
    pub fn g_application_command_line_get_platform_data(cmdline:
                                                            *mut GApplicationCommandLine)
     -> *mut GVariant;
    pub fn g_application_command_line_create_file_for_arg(cmdline:
                                                              *mut GApplicationCommandLine,
                                                          arg: *const gchar)
     -> *mut GFile;
    pub fn g_initable_get_type() -> GType;
    pub fn g_initable_init(initable: *mut GInitable,
                           cancellable: *mut GCancellable,
                           error: *mut *mut GError) -> gboolean;
    pub fn g_initable_new(object_type: GType, cancellable: *mut GCancellable,
                          error: *mut *mut GError,
                          first_property_name: *const gchar, ...) -> gpointer;
    pub fn g_initable_newv(object_type: GType, n_parameters: guint,
                           parameters: *mut GParameter,
                           cancellable: *mut GCancellable,
                           error: *mut *mut GError) -> gpointer;
    pub fn g_initable_new_valist(object_type: GType,
                                 first_property_name: *const gchar,
                                 var_args: va_list,
                                 cancellable: *mut GCancellable,
                                 error: *mut *mut GError) -> *mut GObject;
    pub fn g_async_initable_get_type() -> GType;
    pub fn g_async_initable_init_async(initable: *mut GAsyncInitable,
                                       io_priority: ::std::os::raw::c_int,
                                       cancellable: *mut GCancellable,
                                       callback: GAsyncReadyCallback,
                                       user_data: gpointer);
    pub fn g_async_initable_init_finish(initable: *mut GAsyncInitable,
                                        res: *mut GAsyncResult,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_async_initable_new_async(object_type: GType,
                                      io_priority: ::std::os::raw::c_int,
                                      cancellable: *mut GCancellable,
                                      callback: GAsyncReadyCallback,
                                      user_data: gpointer,
                                      first_property_name: *const gchar, ...);
    pub fn g_async_initable_newv_async(object_type: GType,
                                       n_parameters: guint,
                                       parameters: *mut GParameter,
                                       io_priority: ::std::os::raw::c_int,
                                       cancellable: *mut GCancellable,
                                       callback: GAsyncReadyCallback,
                                       user_data: gpointer);
    pub fn g_async_initable_new_valist_async(object_type: GType,
                                             first_property_name:
                                                 *const gchar,
                                             var_args: va_list,
                                             io_priority:
                                                 ::std::os::raw::c_int,
                                             cancellable: *mut GCancellable,
                                             callback: GAsyncReadyCallback,
                                             user_data: gpointer);
    pub fn g_async_initable_new_finish(initable: *mut GAsyncInitable,
                                       res: *mut GAsyncResult,
                                       error: *mut *mut GError)
     -> *mut GObject;
    pub fn g_async_result_get_type() -> GType;
    pub fn g_async_result_get_user_data(res: *mut GAsyncResult) -> gpointer;
    pub fn g_async_result_get_source_object(res: *mut GAsyncResult)
     -> *mut GObject;
    pub fn g_async_result_legacy_propagate_error(res: *mut GAsyncResult,
                                                 error: *mut *mut GError)
     -> gboolean;
    pub fn g_async_result_is_tagged(res: *mut GAsyncResult,
                                    source_tag: gpointer) -> gboolean;
    pub fn g_input_stream_get_type() -> GType;
    pub fn g_input_stream_read(stream: *mut GInputStream,
                               buffer: *mut ::std::os::raw::c_void,
                               count: gsize, cancellable: *mut GCancellable,
                               error: *mut *mut GError) -> gssize;
    pub fn g_input_stream_read_all(stream: *mut GInputStream,
                                   buffer: *mut ::std::os::raw::c_void,
                                   count: gsize, bytes_read: *mut gsize,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_input_stream_read_bytes(stream: *mut GInputStream, count: gsize,
                                     cancellable: *mut GCancellable,
                                     error: *mut *mut GError) -> *mut GBytes;
    pub fn g_input_stream_skip(stream: *mut GInputStream, count: gsize,
                               cancellable: *mut GCancellable,
                               error: *mut *mut GError) -> gssize;
    pub fn g_input_stream_close(stream: *mut GInputStream,
                                cancellable: *mut GCancellable,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_input_stream_read_async(stream: *mut GInputStream,
                                     buffer: *mut ::std::os::raw::c_void,
                                     count: gsize,
                                     io_priority: ::std::os::raw::c_int,
                                     cancellable: *mut GCancellable,
                                     callback: GAsyncReadyCallback,
                                     user_data: gpointer);
    pub fn g_input_stream_read_finish(stream: *mut GInputStream,
                                      result: *mut GAsyncResult,
                                      error: *mut *mut GError) -> gssize;
    pub fn g_input_stream_read_all_async(stream: *mut GInputStream,
                                         buffer: *mut ::std::os::raw::c_void,
                                         count: gsize,
                                         io_priority: ::std::os::raw::c_int,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_input_stream_read_all_finish(stream: *mut GInputStream,
                                          result: *mut GAsyncResult,
                                          bytes_read: *mut gsize,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_input_stream_read_bytes_async(stream: *mut GInputStream,
                                           count: gsize,
                                           io_priority: ::std::os::raw::c_int,
                                           cancellable: *mut GCancellable,
                                           callback: GAsyncReadyCallback,
                                           user_data: gpointer);
    pub fn g_input_stream_read_bytes_finish(stream: *mut GInputStream,
                                            result: *mut GAsyncResult,
                                            error: *mut *mut GError)
     -> *mut GBytes;
    pub fn g_input_stream_skip_async(stream: *mut GInputStream, count: gsize,
                                     io_priority: ::std::os::raw::c_int,
                                     cancellable: *mut GCancellable,
                                     callback: GAsyncReadyCallback,
                                     user_data: gpointer);
    pub fn g_input_stream_skip_finish(stream: *mut GInputStream,
                                      result: *mut GAsyncResult,
                                      error: *mut *mut GError) -> gssize;
    pub fn g_input_stream_close_async(stream: *mut GInputStream,
                                      io_priority: ::std::os::raw::c_int,
                                      cancellable: *mut GCancellable,
                                      callback: GAsyncReadyCallback,
                                      user_data: gpointer);
    pub fn g_input_stream_close_finish(stream: *mut GInputStream,
                                       result: *mut GAsyncResult,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_input_stream_is_closed(stream: *mut GInputStream) -> gboolean;
    pub fn g_input_stream_has_pending(stream: *mut GInputStream) -> gboolean;
    pub fn g_input_stream_set_pending(stream: *mut GInputStream,
                                      error: *mut *mut GError) -> gboolean;
    pub fn g_input_stream_clear_pending(stream: *mut GInputStream);
    pub fn g_filter_input_stream_get_type() -> GType;
    pub fn g_filter_input_stream_get_base_stream(stream:
                                                     *mut GFilterInputStream)
     -> *mut GInputStream;
    pub fn g_filter_input_stream_get_close_base_stream(stream:
                                                           *mut GFilterInputStream)
     -> gboolean;
    pub fn g_filter_input_stream_set_close_base_stream(stream:
                                                           *mut GFilterInputStream,
                                                       close_base: gboolean);
    pub fn g_buffered_input_stream_get_type() -> GType;
    pub fn g_buffered_input_stream_new(base_stream: *mut GInputStream)
     -> *mut GInputStream;
    pub fn g_buffered_input_stream_new_sized(base_stream: *mut GInputStream,
                                             size: gsize)
     -> *mut GInputStream;
    pub fn g_buffered_input_stream_get_buffer_size(stream:
                                                       *mut GBufferedInputStream)
     -> gsize;
    pub fn g_buffered_input_stream_set_buffer_size(stream:
                                                       *mut GBufferedInputStream,
                                                   size: gsize);
    pub fn g_buffered_input_stream_get_available(stream:
                                                     *mut GBufferedInputStream)
     -> gsize;
    pub fn g_buffered_input_stream_peek(stream: *mut GBufferedInputStream,
                                        buffer: *mut ::std::os::raw::c_void,
                                        offset: gsize, count: gsize) -> gsize;
    pub fn g_buffered_input_stream_peek_buffer(stream:
                                                   *mut GBufferedInputStream,
                                               count: *mut gsize)
     -> *const ::std::os::raw::c_void;
    pub fn g_buffered_input_stream_fill(stream: *mut GBufferedInputStream,
                                        count: gssize,
                                        cancellable: *mut GCancellable,
                                        error: *mut *mut GError) -> gssize;
    pub fn g_buffered_input_stream_fill_async(stream:
                                                  *mut GBufferedInputStream,
                                              count: gssize,
                                              io_priority:
                                                  ::std::os::raw::c_int,
                                              cancellable: *mut GCancellable,
                                              callback: GAsyncReadyCallback,
                                              user_data: gpointer);
    pub fn g_buffered_input_stream_fill_finish(stream:
                                                   *mut GBufferedInputStream,
                                               result: *mut GAsyncResult,
                                               error: *mut *mut GError)
     -> gssize;
    pub fn g_buffered_input_stream_read_byte(stream:
                                                 *mut GBufferedInputStream,
                                             cancellable: *mut GCancellable,
                                             error: *mut *mut GError)
     -> ::std::os::raw::c_int;
    pub fn g_output_stream_get_type() -> GType;
    pub fn g_output_stream_write(stream: *mut GOutputStream,
                                 buffer: *const ::std::os::raw::c_void,
                                 count: gsize, cancellable: *mut GCancellable,
                                 error: *mut *mut GError) -> gssize;
    pub fn g_output_stream_write_all(stream: *mut GOutputStream,
                                     buffer: *const ::std::os::raw::c_void,
                                     count: gsize, bytes_written: *mut gsize,
                                     cancellable: *mut GCancellable,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_output_stream_printf(stream: *mut GOutputStream,
                                  bytes_written: *mut gsize,
                                  cancellable: *mut GCancellable,
                                  error: *mut *mut GError,
                                  format: *const gchar, ...) -> gboolean;
    pub fn g_output_stream_vprintf(stream: *mut GOutputStream,
                                   bytes_written: *mut gsize,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError,
                                   format: *const gchar, args: va_list)
     -> gboolean;
    pub fn g_output_stream_write_bytes(stream: *mut GOutputStream,
                                       bytes: *mut GBytes,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError) -> gssize;
    pub fn g_output_stream_splice(stream: *mut GOutputStream,
                                  source: *mut GInputStream,
                                  flags: GOutputStreamSpliceFlags,
                                  cancellable: *mut GCancellable,
                                  error: *mut *mut GError) -> gssize;
    pub fn g_output_stream_flush(stream: *mut GOutputStream,
                                 cancellable: *mut GCancellable,
                                 error: *mut *mut GError) -> gboolean;
    pub fn g_output_stream_close(stream: *mut GOutputStream,
                                 cancellable: *mut GCancellable,
                                 error: *mut *mut GError) -> gboolean;
    pub fn g_output_stream_write_async(stream: *mut GOutputStream,
                                       buffer: *const ::std::os::raw::c_void,
                                       count: gsize,
                                       io_priority: ::std::os::raw::c_int,
                                       cancellable: *mut GCancellable,
                                       callback: GAsyncReadyCallback,
                                       user_data: gpointer);
    pub fn g_output_stream_write_finish(stream: *mut GOutputStream,
                                        result: *mut GAsyncResult,
                                        error: *mut *mut GError) -> gssize;
    pub fn g_output_stream_write_all_async(stream: *mut GOutputStream,
                                           buffer:
                                               *const ::std::os::raw::c_void,
                                           count: gsize,
                                           io_priority: ::std::os::raw::c_int,
                                           cancellable: *mut GCancellable,
                                           callback: GAsyncReadyCallback,
                                           user_data: gpointer);
    pub fn g_output_stream_write_all_finish(stream: *mut GOutputStream,
                                            result: *mut GAsyncResult,
                                            bytes_written: *mut gsize,
                                            error: *mut *mut GError)
     -> gboolean;
    pub fn g_output_stream_write_bytes_async(stream: *mut GOutputStream,
                                             bytes: *mut GBytes,
                                             io_priority:
                                                 ::std::os::raw::c_int,
                                             cancellable: *mut GCancellable,
                                             callback: GAsyncReadyCallback,
                                             user_data: gpointer);
    pub fn g_output_stream_write_bytes_finish(stream: *mut GOutputStream,
                                              result: *mut GAsyncResult,
                                              error: *mut *mut GError)
     -> gssize;
    pub fn g_output_stream_splice_async(stream: *mut GOutputStream,
                                        source: *mut GInputStream,
                                        flags: GOutputStreamSpliceFlags,
                                        io_priority: ::std::os::raw::c_int,
                                        cancellable: *mut GCancellable,
                                        callback: GAsyncReadyCallback,
                                        user_data: gpointer);
    pub fn g_output_stream_splice_finish(stream: *mut GOutputStream,
                                         result: *mut GAsyncResult,
                                         error: *mut *mut GError) -> gssize;
    pub fn g_output_stream_flush_async(stream: *mut GOutputStream,
                                       io_priority: ::std::os::raw::c_int,
                                       cancellable: *mut GCancellable,
                                       callback: GAsyncReadyCallback,
                                       user_data: gpointer);
    pub fn g_output_stream_flush_finish(stream: *mut GOutputStream,
                                        result: *mut GAsyncResult,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_output_stream_close_async(stream: *mut GOutputStream,
                                       io_priority: ::std::os::raw::c_int,
                                       cancellable: *mut GCancellable,
                                       callback: GAsyncReadyCallback,
                                       user_data: gpointer);
    pub fn g_output_stream_close_finish(stream: *mut GOutputStream,
                                        result: *mut GAsyncResult,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_output_stream_is_closed(stream: *mut GOutputStream) -> gboolean;
    pub fn g_output_stream_is_closing(stream: *mut GOutputStream) -> gboolean;
    pub fn g_output_stream_has_pending(stream: *mut GOutputStream)
     -> gboolean;
    pub fn g_output_stream_set_pending(stream: *mut GOutputStream,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_output_stream_clear_pending(stream: *mut GOutputStream);
    pub fn g_filter_output_stream_get_type() -> GType;
    pub fn g_filter_output_stream_get_base_stream(stream:
                                                      *mut GFilterOutputStream)
     -> *mut GOutputStream;
    pub fn g_filter_output_stream_get_close_base_stream(stream:
                                                            *mut GFilterOutputStream)
     -> gboolean;
    pub fn g_filter_output_stream_set_close_base_stream(stream:
                                                            *mut GFilterOutputStream,
                                                        close_base: gboolean);
    pub fn g_buffered_output_stream_get_type() -> GType;
    pub fn g_buffered_output_stream_new(base_stream: *mut GOutputStream)
     -> *mut GOutputStream;
    pub fn g_buffered_output_stream_new_sized(base_stream: *mut GOutputStream,
                                              size: gsize)
     -> *mut GOutputStream;
    pub fn g_buffered_output_stream_get_buffer_size(stream:
                                                        *mut GBufferedOutputStream)
     -> gsize;
    pub fn g_buffered_output_stream_set_buffer_size(stream:
                                                        *mut GBufferedOutputStream,
                                                    size: gsize);
    pub fn g_buffered_output_stream_get_auto_grow(stream:
                                                      *mut GBufferedOutputStream)
     -> gboolean;
    pub fn g_buffered_output_stream_set_auto_grow(stream:
                                                      *mut GBufferedOutputStream,
                                                  auto_grow: gboolean);
    pub fn g_bytes_icon_get_type() -> GType;
    pub fn g_bytes_icon_new(bytes: *mut GBytes) -> *mut GIcon;
    pub fn g_bytes_icon_get_bytes(icon: *mut GBytesIcon) -> *mut GBytes;
    pub fn g_cancellable_get_type() -> GType;
    pub fn g_cancellable_new() -> *mut GCancellable;
    pub fn g_cancellable_is_cancelled(cancellable: *mut GCancellable)
     -> gboolean;
    pub fn g_cancellable_set_error_if_cancelled(cancellable:
                                                    *mut GCancellable,
                                                error: *mut *mut GError)
     -> gboolean;
    pub fn g_cancellable_get_fd(cancellable: *mut GCancellable)
     -> ::std::os::raw::c_int;
    pub fn g_cancellable_make_pollfd(cancellable: *mut GCancellable,
                                     pollfd: *mut GPollFD) -> gboolean;
    pub fn g_cancellable_release_fd(cancellable: *mut GCancellable);
    pub fn g_cancellable_source_new(cancellable: *mut GCancellable)
     -> *mut GSource;
    pub fn g_cancellable_get_current() -> *mut GCancellable;
    pub fn g_cancellable_push_current(cancellable: *mut GCancellable);
    pub fn g_cancellable_pop_current(cancellable: *mut GCancellable);
    pub fn g_cancellable_reset(cancellable: *mut GCancellable);
    pub fn g_cancellable_connect(cancellable: *mut GCancellable,
                                 callback: GCallback, data: gpointer,
                                 data_destroy_func: GDestroyNotify) -> gulong;
    pub fn g_cancellable_disconnect(cancellable: *mut GCancellable,
                                    handler_id: gulong);
    pub fn g_cancellable_cancel(cancellable: *mut GCancellable);
    pub fn g_converter_get_type() -> GType;
    pub fn g_converter_convert(converter: *mut GConverter,
                               inbuf: *const ::std::os::raw::c_void,
                               inbuf_size: gsize,
                               outbuf: *mut ::std::os::raw::c_void,
                               outbuf_size: gsize, flags: GConverterFlags,
                               bytes_read: *mut gsize,
                               bytes_written: *mut gsize,
                               error: *mut *mut GError) -> GConverterResult;
    pub fn g_converter_reset(converter: *mut GConverter);
    pub fn g_charset_converter_get_type() -> GType;
    pub fn g_charset_converter_new(to_charset: *const gchar,
                                   from_charset: *const gchar,
                                   error: *mut *mut GError)
     -> *mut GCharsetConverter;
    pub fn g_charset_converter_set_use_fallback(converter:
                                                    *mut GCharsetConverter,
                                                use_fallback: gboolean);
    pub fn g_charset_converter_get_use_fallback(converter:
                                                    *mut GCharsetConverter)
     -> gboolean;
    pub fn g_charset_converter_get_num_fallbacks(converter:
                                                     *mut GCharsetConverter)
     -> guint;
    pub fn g_content_type_equals(type1: *const gchar, type2: *const gchar)
     -> gboolean;
    pub fn g_content_type_is_a(_type: *const gchar, supertype: *const gchar)
     -> gboolean;
    pub fn g_content_type_is_unknown(_type: *const gchar) -> gboolean;
    pub fn g_content_type_get_description(_type: *const gchar) -> *mut gchar;
    pub fn g_content_type_get_mime_type(_type: *const gchar) -> *mut gchar;
    pub fn g_content_type_get_icon(_type: *const gchar) -> *mut GIcon;
    pub fn g_content_type_get_symbolic_icon(_type: *const gchar)
     -> *mut GIcon;
    pub fn g_content_type_get_generic_icon_name(_type: *const gchar)
     -> *mut gchar;
    pub fn g_content_type_can_be_executable(_type: *const gchar) -> gboolean;
    pub fn g_content_type_from_mime_type(mime_type: *const gchar)
     -> *mut gchar;
    pub fn g_content_type_guess(filename: *const gchar, data: *const guchar,
                                data_size: gsize,
                                result_uncertain: *mut gboolean)
     -> *mut gchar;
    pub fn g_content_type_guess_for_tree(root: *mut GFile) -> *mut *mut gchar;
    pub fn g_content_types_get_registered() -> *mut GList;
    pub fn g_converter_input_stream_get_type() -> GType;
    pub fn g_converter_input_stream_new(base_stream: *mut GInputStream,
                                        converter: *mut GConverter)
     -> *mut GInputStream;
    pub fn g_converter_input_stream_get_converter(converter_stream:
                                                      *mut GConverterInputStream)
     -> *mut GConverter;
    pub fn g_converter_output_stream_get_type() -> GType;
    pub fn g_converter_output_stream_new(base_stream: *mut GOutputStream,
                                         converter: *mut GConverter)
     -> *mut GOutputStream;
    pub fn g_converter_output_stream_get_converter(converter_stream:
                                                       *mut GConverterOutputStream)
     -> *mut GConverter;
    pub fn access(__name: *const ::std::os::raw::c_char,
                  __type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn faccessat(__fd: ::std::os::raw::c_int,
                     __file: *const ::std::os::raw::c_char,
                     __type: ::std::os::raw::c_int,
                     __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn lseek(__fd: ::std::os::raw::c_int, __offset: __off_t,
                 __whence: ::std::os::raw::c_int) -> __off_t;
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn read(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __nbytes: size_t)
     -> ssize_t;
    pub fn write(__fd: ::std::os::raw::c_int,
                 __buf: *const ::std::os::raw::c_void, __n: size_t)
     -> ssize_t;
    pub fn pread(__fd: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_void, __nbytes: size_t,
                 __offset: __off_t) -> ssize_t;
    pub fn pwrite(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: size_t,
                  __offset: __off_t) -> ssize_t;
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t)
     -> __useconds_t;
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
    pub fn pause() -> ::std::os::raw::c_int;
    pub fn chown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                 __group: __gid_t) -> ::std::os::raw::c_int;
    pub fn fchown(__fd: ::std::os::raw::c_int, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
    pub fn lchown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
    pub fn fchownat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __owner: __uid_t,
                    __group: __gid_t, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn chdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn getwd(__buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn execve(__path: *const ::std::os::raw::c_char,
                  __argv: *const *mut ::std::os::raw::c_char,
                  __envp: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn fexecve(__fd: ::std::os::raw::c_int,
                   __argv: *const *mut ::std::os::raw::c_char,
                   __envp: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn execv(__path: *const ::std::os::raw::c_char,
                 __argv: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn execle(__path: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn execl(__path: *const ::std::os::raw::c_char,
                 __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn execvp(__file: *const ::std::os::raw::c_char,
                  __argv: *const *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn execlp(__file: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _exit(__status: ::std::os::raw::c_int);
    pub fn pathconf(__path: *const ::std::os::raw::c_char,
                    __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn fpathconf(__fd: ::std::os::raw::c_int,
                     __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn confstr(__name: ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> size_t;
    pub fn getpid() -> __pid_t;
    pub fn getppid() -> __pid_t;
    pub fn getpgrp() -> __pid_t;
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
    pub fn setpgrp() -> ::std::os::raw::c_int;
    pub fn setsid() -> __pid_t;
    pub fn getsid(__pid: __pid_t) -> __pid_t;
    pub fn getuid() -> __uid_t;
    pub fn geteuid() -> __uid_t;
    pub fn getgid() -> __gid_t;
    pub fn getegid() -> __gid_t;
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t)
     -> ::std::os::raw::c_int;
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t)
     -> ::std::os::raw::c_int;
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t)
     -> ::std::os::raw::c_int;
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn fork() -> __pid_t;
    pub fn vfork() -> __pid_t;
    pub fn ttyname(__fd: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn ttyname_r(__fd: ::std::os::raw::c_int,
                     __buf: *mut ::std::os::raw::c_char, __buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ttyslot() -> ::std::os::raw::c_int;
    pub fn link(__from: *const ::std::os::raw::c_char,
                __to: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn linkat(__fromfd: ::std::os::raw::c_int,
                  __from: *const ::std::os::raw::c_char,
                  __tofd: ::std::os::raw::c_int,
                  __to: *const ::std::os::raw::c_char,
                  __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn symlink(__from: *const ::std::os::raw::c_char,
                   __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn readlink(__path: *const ::std::os::raw::c_char,
                    __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ssize_t;
    pub fn symlinkat(__from: *const ::std::os::raw::c_char,
                     __tofd: ::std::os::raw::c_int,
                     __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn readlinkat(__fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char,
                      __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ssize_t;
    pub fn unlink(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn unlinkat(__fd: ::std::os::raw::c_int,
                    __name: *const ::std::os::raw::c_char,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rmdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t)
     -> ::std::os::raw::c_int;
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
    pub fn getlogin_r(__name: *mut ::std::os::raw::c_char, __name_len: size_t)
     -> ::std::os::raw::c_int;
    pub fn setlogin(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getopt(___argc: ::std::os::raw::c_int,
                  ___argv: *const *mut ::std::os::raw::c_char,
                  __shortopts: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn sethostname(__name: *const ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn getdomainname(__name: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn setdomainname(__name: *const ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn vhangup() -> ::std::os::raw::c_int;
    pub fn revoke(__file: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn profil(__sample_buffer: *mut ::std::os::raw::c_ushort,
                  __size: size_t, __offset: size_t,
                  __scale: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn acct(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
    pub fn endusershell();
    pub fn setusershell();
    pub fn daemon(__nochdir: ::std::os::raw::c_int,
                  __noclose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn chroot(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getpass(__prompt: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn gethostid() -> ::std::os::raw::c_long;
    pub fn sync();
    pub fn getpagesize() -> ::std::os::raw::c_int;
    pub fn getdtablesize() -> ::std::os::raw::c_int;
    pub fn truncate(__file: *const ::std::os::raw::c_char, __length: __off_t)
     -> ::std::os::raw::c_int;
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t)
     -> ::std::os::raw::c_int;
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
    pub fn sbrk(__delta: intptr_t) -> *mut ::std::os::raw::c_void;
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...)
     -> ::std::os::raw::c_long;
    pub fn lockf(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                 __len: __off_t) -> ::std::os::raw::c_int;
    pub fn fdatasync(__fildes: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn g_credentials_get_type() -> GType;
    pub fn g_credentials_new() -> *mut GCredentials;
    pub fn g_credentials_to_string(credentials: *mut GCredentials)
     -> *mut gchar;
    pub fn g_credentials_get_native(credentials: *mut GCredentials,
                                    native_type: GCredentialsType)
     -> gpointer;
    pub fn g_credentials_set_native(credentials: *mut GCredentials,
                                    native_type: GCredentialsType,
                                    native: gpointer);
    pub fn g_credentials_is_same_user(credentials: *mut GCredentials,
                                      other_credentials: *mut GCredentials,
                                      error: *mut *mut GError) -> gboolean;
    pub fn g_credentials_get_unix_pid(credentials: *mut GCredentials,
                                      error: *mut *mut GError) -> pid_t;
    pub fn g_credentials_get_unix_user(credentials: *mut GCredentials,
                                       error: *mut *mut GError) -> uid_t;
    pub fn g_credentials_set_unix_user(credentials: *mut GCredentials,
                                       uid: uid_t, error: *mut *mut GError)
     -> gboolean;
    pub fn g_data_input_stream_get_type() -> GType;
    pub fn g_data_input_stream_new(base_stream: *mut GInputStream)
     -> *mut GDataInputStream;
    pub fn g_data_input_stream_set_byte_order(stream: *mut GDataInputStream,
                                              order: GDataStreamByteOrder);
    pub fn g_data_input_stream_get_byte_order(stream: *mut GDataInputStream)
     -> GDataStreamByteOrder;
    pub fn g_data_input_stream_set_newline_type(stream: *mut GDataInputStream,
                                                _type:
                                                    GDataStreamNewlineType);
    pub fn g_data_input_stream_get_newline_type(stream: *mut GDataInputStream)
     -> GDataStreamNewlineType;
    pub fn g_data_input_stream_read_byte(stream: *mut GDataInputStream,
                                         cancellable: *mut GCancellable,
                                         error: *mut *mut GError) -> guchar;
    pub fn g_data_input_stream_read_int16(stream: *mut GDataInputStream,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError) -> gint16;
    pub fn g_data_input_stream_read_uint16(stream: *mut GDataInputStream,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> guint16;
    pub fn g_data_input_stream_read_int32(stream: *mut GDataInputStream,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError) -> gint32;
    pub fn g_data_input_stream_read_uint32(stream: *mut GDataInputStream,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> guint32;
    pub fn g_data_input_stream_read_int64(stream: *mut GDataInputStream,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError) -> gint64;
    pub fn g_data_input_stream_read_uint64(stream: *mut GDataInputStream,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> guint64;
    pub fn g_data_input_stream_read_line(stream: *mut GDataInputStream,
                                         length: *mut gsize,
                                         cancellable: *mut GCancellable,
                                         error: *mut *mut GError)
     -> *mut ::std::os::raw::c_char;
    pub fn g_data_input_stream_read_line_utf8(stream: *mut GDataInputStream,
                                              length: *mut gsize,
                                              cancellable: *mut GCancellable,
                                              error: *mut *mut GError)
     -> *mut ::std::os::raw::c_char;
    pub fn g_data_input_stream_read_line_async(stream: *mut GDataInputStream,
                                               io_priority: gint,
                                               cancellable: *mut GCancellable,
                                               callback: GAsyncReadyCallback,
                                               user_data: gpointer);
    pub fn g_data_input_stream_read_line_finish(stream: *mut GDataInputStream,
                                                result: *mut GAsyncResult,
                                                length: *mut gsize,
                                                error: *mut *mut GError)
     -> *mut ::std::os::raw::c_char;
    pub fn g_data_input_stream_read_line_finish_utf8(stream:
                                                         *mut GDataInputStream,
                                                     result:
                                                         *mut GAsyncResult,
                                                     length: *mut gsize,
                                                     error: *mut *mut GError)
     -> *mut ::std::os::raw::c_char;
    pub fn g_data_input_stream_read_until(stream: *mut GDataInputStream,
                                          stop_chars: *const gchar,
                                          length: *mut gsize,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError)
     -> *mut ::std::os::raw::c_char;
    pub fn g_data_input_stream_read_until_async(stream: *mut GDataInputStream,
                                                stop_chars: *const gchar,
                                                io_priority: gint,
                                                cancellable:
                                                    *mut GCancellable,
                                                callback: GAsyncReadyCallback,
                                                user_data: gpointer);
    pub fn g_data_input_stream_read_until_finish(stream:
                                                     *mut GDataInputStream,
                                                 result: *mut GAsyncResult,
                                                 length: *mut gsize,
                                                 error: *mut *mut GError)
     -> *mut ::std::os::raw::c_char;
    pub fn g_data_input_stream_read_upto(stream: *mut GDataInputStream,
                                         stop_chars: *const gchar,
                                         stop_chars_len: gssize,
                                         length: *mut gsize,
                                         cancellable: *mut GCancellable,
                                         error: *mut *mut GError)
     -> *mut ::std::os::raw::c_char;
    pub fn g_data_input_stream_read_upto_async(stream: *mut GDataInputStream,
                                               stop_chars: *const gchar,
                                               stop_chars_len: gssize,
                                               io_priority: gint,
                                               cancellable: *mut GCancellable,
                                               callback: GAsyncReadyCallback,
                                               user_data: gpointer);
    pub fn g_data_input_stream_read_upto_finish(stream: *mut GDataInputStream,
                                                result: *mut GAsyncResult,
                                                length: *mut gsize,
                                                error: *mut *mut GError)
     -> *mut ::std::os::raw::c_char;
    pub fn g_data_output_stream_get_type() -> GType;
    pub fn g_data_output_stream_new(base_stream: *mut GOutputStream)
     -> *mut GDataOutputStream;
    pub fn g_data_output_stream_set_byte_order(stream: *mut GDataOutputStream,
                                               order: GDataStreamByteOrder);
    pub fn g_data_output_stream_get_byte_order(stream: *mut GDataOutputStream)
     -> GDataStreamByteOrder;
    pub fn g_data_output_stream_put_byte(stream: *mut GDataOutputStream,
                                         data: guchar,
                                         cancellable: *mut GCancellable,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_data_output_stream_put_int16(stream: *mut GDataOutputStream,
                                          data: gint16,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_data_output_stream_put_uint16(stream: *mut GDataOutputStream,
                                           data: guint16,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_data_output_stream_put_int32(stream: *mut GDataOutputStream,
                                          data: gint32,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_data_output_stream_put_uint32(stream: *mut GDataOutputStream,
                                           data: guint32,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_data_output_stream_put_int64(stream: *mut GDataOutputStream,
                                          data: gint64,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_data_output_stream_put_uint64(stream: *mut GDataOutputStream,
                                           data: guint64,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_data_output_stream_put_string(stream: *mut GDataOutputStream,
                                           str: *const ::std::os::raw::c_char,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_dbus_address_escape_value(string: *const gchar) -> *mut gchar;
    pub fn g_dbus_is_address(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_supported_address(string: *const gchar,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_dbus_address_get_stream(address: *const gchar,
                                     cancellable: *mut GCancellable,
                                     callback: GAsyncReadyCallback,
                                     user_data: gpointer);
    pub fn g_dbus_address_get_stream_finish(res: *mut GAsyncResult,
                                            out_guid: *mut *mut gchar,
                                            error: *mut *mut GError)
     -> *mut GIOStream;
    pub fn g_dbus_address_get_stream_sync(address: *const gchar,
                                          out_guid: *mut *mut gchar,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError)
     -> *mut GIOStream;
    pub fn g_dbus_address_get_for_bus_sync(bus_type: GBusType,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_dbus_auth_observer_get_type() -> GType;
    pub fn g_dbus_auth_observer_new() -> *mut GDBusAuthObserver;
    pub fn g_dbus_auth_observer_authorize_authenticated_peer(observer:
                                                                 *mut GDBusAuthObserver,
                                                             stream:
                                                                 *mut GIOStream,
                                                             credentials:
                                                                 *mut GCredentials)
     -> gboolean;
    pub fn g_dbus_auth_observer_allow_mechanism(observer:
                                                    *mut GDBusAuthObserver,
                                                mechanism: *const gchar)
     -> gboolean;
    pub fn g_dbus_connection_get_type() -> GType;
    pub fn g_bus_get(bus_type: GBusType, cancellable: *mut GCancellable,
                     callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_bus_get_finish(res: *mut GAsyncResult, error: *mut *mut GError)
     -> *mut GDBusConnection;
    pub fn g_bus_get_sync(bus_type: GBusType, cancellable: *mut GCancellable,
                          error: *mut *mut GError) -> *mut GDBusConnection;
    pub fn g_dbus_connection_new(stream: *mut GIOStream, guid: *const gchar,
                                 flags: GDBusConnectionFlags,
                                 observer: *mut GDBusAuthObserver,
                                 cancellable: *mut GCancellable,
                                 callback: GAsyncReadyCallback,
                                 user_data: gpointer);
    pub fn g_dbus_connection_new_finish(res: *mut GAsyncResult,
                                        error: *mut *mut GError)
     -> *mut GDBusConnection;
    pub fn g_dbus_connection_new_sync(stream: *mut GIOStream,
                                      guid: *const gchar,
                                      flags: GDBusConnectionFlags,
                                      observer: *mut GDBusAuthObserver,
                                      cancellable: *mut GCancellable,
                                      error: *mut *mut GError)
     -> *mut GDBusConnection;
    pub fn g_dbus_connection_new_for_address(address: *const gchar,
                                             flags: GDBusConnectionFlags,
                                             observer: *mut GDBusAuthObserver,
                                             cancellable: *mut GCancellable,
                                             callback: GAsyncReadyCallback,
                                             user_data: gpointer);
    pub fn g_dbus_connection_new_for_address_finish(res: *mut GAsyncResult,
                                                    error: *mut *mut GError)
     -> *mut GDBusConnection;
    pub fn g_dbus_connection_new_for_address_sync(address: *const gchar,
                                                  flags: GDBusConnectionFlags,
                                                  observer:
                                                      *mut GDBusAuthObserver,
                                                  cancellable:
                                                      *mut GCancellable,
                                                  error: *mut *mut GError)
     -> *mut GDBusConnection;
    pub fn g_dbus_connection_start_message_processing(connection:
                                                          *mut GDBusConnection);
    pub fn g_dbus_connection_is_closed(connection: *mut GDBusConnection)
     -> gboolean;
    pub fn g_dbus_connection_get_stream(connection: *mut GDBusConnection)
     -> *mut GIOStream;
    pub fn g_dbus_connection_get_guid(connection: *mut GDBusConnection)
     -> *const gchar;
    pub fn g_dbus_connection_get_unique_name(connection: *mut GDBusConnection)
     -> *const gchar;
    pub fn g_dbus_connection_get_peer_credentials(connection:
                                                      *mut GDBusConnection)
     -> *mut GCredentials;
    pub fn g_dbus_connection_get_last_serial(connection: *mut GDBusConnection)
     -> guint32;
    pub fn g_dbus_connection_get_exit_on_close(connection:
                                                   *mut GDBusConnection)
     -> gboolean;
    pub fn g_dbus_connection_set_exit_on_close(connection:
                                                   *mut GDBusConnection,
                                               exit_on_close: gboolean);
    pub fn g_dbus_connection_get_capabilities(connection:
                                                  *mut GDBusConnection)
     -> GDBusCapabilityFlags;
    pub fn g_dbus_connection_close(connection: *mut GDBusConnection,
                                   cancellable: *mut GCancellable,
                                   callback: GAsyncReadyCallback,
                                   user_data: gpointer);
    pub fn g_dbus_connection_close_finish(connection: *mut GDBusConnection,
                                          res: *mut GAsyncResult,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_dbus_connection_close_sync(connection: *mut GDBusConnection,
                                        cancellable: *mut GCancellable,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_dbus_connection_flush(connection: *mut GDBusConnection,
                                   cancellable: *mut GCancellable,
                                   callback: GAsyncReadyCallback,
                                   user_data: gpointer);
    pub fn g_dbus_connection_flush_finish(connection: *mut GDBusConnection,
                                          res: *mut GAsyncResult,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_dbus_connection_flush_sync(connection: *mut GDBusConnection,
                                        cancellable: *mut GCancellable,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_dbus_connection_send_message(connection: *mut GDBusConnection,
                                          message: *mut GDBusMessage,
                                          flags: GDBusSendMessageFlags,
                                          out_serial: *mut guint32,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_dbus_connection_send_message_with_reply(connection:
                                                         *mut GDBusConnection,
                                                     message:
                                                         *mut GDBusMessage,
                                                     flags:
                                                         GDBusSendMessageFlags,
                                                     timeout_msec: gint,
                                                     out_serial: *mut guint32,
                                                     cancellable:
                                                         *mut GCancellable,
                                                     callback:
                                                         GAsyncReadyCallback,
                                                     user_data: gpointer);
    pub fn g_dbus_connection_send_message_with_reply_finish(connection:
                                                                *mut GDBusConnection,
                                                            res:
                                                                *mut GAsyncResult,
                                                            error:
                                                                *mut *mut GError)
     -> *mut GDBusMessage;
    pub fn g_dbus_connection_send_message_with_reply_sync(connection:
                                                              *mut GDBusConnection,
                                                          message:
                                                              *mut GDBusMessage,
                                                          flags:
                                                              GDBusSendMessageFlags,
                                                          timeout_msec: gint,
                                                          out_serial:
                                                              *mut guint32,
                                                          cancellable:
                                                              *mut GCancellable,
                                                          error:
                                                              *mut *mut GError)
     -> *mut GDBusMessage;
    pub fn g_dbus_connection_emit_signal(connection: *mut GDBusConnection,
                                         destination_bus_name: *const gchar,
                                         object_path: *const gchar,
                                         interface_name: *const gchar,
                                         signal_name: *const gchar,
                                         parameters: *mut GVariant,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_dbus_connection_call(connection: *mut GDBusConnection,
                                  bus_name: *const gchar,
                                  object_path: *const gchar,
                                  interface_name: *const gchar,
                                  method_name: *const gchar,
                                  parameters: *mut GVariant,
                                  reply_type: *const GVariantType,
                                  flags: GDBusCallFlags, timeout_msec: gint,
                                  cancellable: *mut GCancellable,
                                  callback: GAsyncReadyCallback,
                                  user_data: gpointer);
    pub fn g_dbus_connection_call_finish(connection: *mut GDBusConnection,
                                         res: *mut GAsyncResult,
                                         error: *mut *mut GError)
     -> *mut GVariant;
    pub fn g_dbus_connection_call_sync(connection: *mut GDBusConnection,
                                       bus_name: *const gchar,
                                       object_path: *const gchar,
                                       interface_name: *const gchar,
                                       method_name: *const gchar,
                                       parameters: *mut GVariant,
                                       reply_type: *const GVariantType,
                                       flags: GDBusCallFlags,
                                       timeout_msec: gint,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError)
     -> *mut GVariant;
    pub fn g_dbus_connection_call_with_unix_fd_list(connection:
                                                        *mut GDBusConnection,
                                                    bus_name: *const gchar,
                                                    object_path: *const gchar,
                                                    interface_name:
                                                        *const gchar,
                                                    method_name: *const gchar,
                                                    parameters: *mut GVariant,
                                                    reply_type:
                                                        *const GVariantType,
                                                    flags: GDBusCallFlags,
                                                    timeout_msec: gint,
                                                    fd_list: *mut GUnixFDList,
                                                    cancellable:
                                                        *mut GCancellable,
                                                    callback:
                                                        GAsyncReadyCallback,
                                                    user_data: gpointer);
    pub fn g_dbus_connection_call_with_unix_fd_list_finish(connection:
                                                               *mut GDBusConnection,
                                                           out_fd_list:
                                                               *mut *mut GUnixFDList,
                                                           res:
                                                               *mut GAsyncResult,
                                                           error:
                                                               *mut *mut GError)
     -> *mut GVariant;
    pub fn g_dbus_connection_call_with_unix_fd_list_sync(connection:
                                                             *mut GDBusConnection,
                                                         bus_name:
                                                             *const gchar,
                                                         object_path:
                                                             *const gchar,
                                                         interface_name:
                                                             *const gchar,
                                                         method_name:
                                                             *const gchar,
                                                         parameters:
                                                             *mut GVariant,
                                                         reply_type:
                                                             *const GVariantType,
                                                         flags:
                                                             GDBusCallFlags,
                                                         timeout_msec: gint,
                                                         fd_list:
                                                             *mut GUnixFDList,
                                                         out_fd_list:
                                                             *mut *mut GUnixFDList,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
     -> *mut GVariant;
    pub fn g_dbus_connection_register_object(connection: *mut GDBusConnection,
                                             object_path: *const gchar,
                                             interface_info:
                                                 *mut GDBusInterfaceInfo,
                                             vtable:
                                                 *const GDBusInterfaceVTable,
                                             user_data: gpointer,
                                             user_data_free_func:
                                                 GDestroyNotify,
                                             error: *mut *mut GError)
     -> guint;
    pub fn g_dbus_connection_register_object_with_closures(connection:
                                                               *mut GDBusConnection,
                                                           object_path:
                                                               *const gchar,
                                                           interface_info:
                                                               *mut GDBusInterfaceInfo,
                                                           method_call_closure:
                                                               *mut GClosure,
                                                           get_property_closure:
                                                               *mut GClosure,
                                                           set_property_closure:
                                                               *mut GClosure,
                                                           error:
                                                               *mut *mut GError)
     -> guint;
    pub fn g_dbus_connection_unregister_object(connection:
                                                   *mut GDBusConnection,
                                               registration_id: guint)
     -> gboolean;
    pub fn g_dbus_connection_register_subtree(connection:
                                                  *mut GDBusConnection,
                                              object_path: *const gchar,
                                              vtable:
                                                  *const GDBusSubtreeVTable,
                                              flags: GDBusSubtreeFlags,
                                              user_data: gpointer,
                                              user_data_free_func:
                                                  GDestroyNotify,
                                              error: *mut *mut GError)
     -> guint;
    pub fn g_dbus_connection_unregister_subtree(connection:
                                                    *mut GDBusConnection,
                                                registration_id: guint)
     -> gboolean;
    pub fn g_dbus_connection_signal_subscribe(connection:
                                                  *mut GDBusConnection,
                                              sender: *const gchar,
                                              interface_name: *const gchar,
                                              member: *const gchar,
                                              object_path: *const gchar,
                                              arg0: *const gchar,
                                              flags: GDBusSignalFlags,
                                              callback: GDBusSignalCallback,
                                              user_data: gpointer,
                                              user_data_free_func:
                                                  GDestroyNotify) -> guint;
    pub fn g_dbus_connection_signal_unsubscribe(connection:
                                                    *mut GDBusConnection,
                                                subscription_id: guint);
    pub fn g_dbus_connection_add_filter(connection: *mut GDBusConnection,
                                        filter_function:
                                            GDBusMessageFilterFunction,
                                        user_data: gpointer,
                                        user_data_free_func: GDestroyNotify)
     -> guint;
    pub fn g_dbus_connection_remove_filter(connection: *mut GDBusConnection,
                                           filter_id: guint);
    pub fn g_dbus_error_quark() -> GQuark;
    pub fn g_dbus_error_is_remote_error(error: *const GError) -> gboolean;
    pub fn g_dbus_error_get_remote_error(error: *const GError) -> *mut gchar;
    pub fn g_dbus_error_strip_remote_error(error: *mut GError) -> gboolean;
    pub fn g_dbus_error_register_error(error_domain: GQuark, error_code: gint,
                                       dbus_error_name: *const gchar)
     -> gboolean;
    pub fn g_dbus_error_unregister_error(error_domain: GQuark,
                                         error_code: gint,
                                         dbus_error_name: *const gchar)
     -> gboolean;
    pub fn g_dbus_error_register_error_domain(error_domain_quark_name:
                                                  *const gchar,
                                              quark_volatile: *mut gsize,
                                              entries: *const GDBusErrorEntry,
                                              num_entries: guint);
    pub fn g_dbus_error_new_for_dbus_error(dbus_error_name: *const gchar,
                                           dbus_error_message: *const gchar)
     -> *mut GError;
    pub fn g_dbus_error_set_dbus_error(error: *mut *mut GError,
                                       dbus_error_name: *const gchar,
                                       dbus_error_message: *const gchar,
                                       format: *const gchar, ...);
    pub fn g_dbus_error_set_dbus_error_valist(error: *mut *mut GError,
                                              dbus_error_name: *const gchar,
                                              dbus_error_message:
                                                  *const gchar,
                                              format: *const gchar,
                                              var_args: va_list);
    pub fn g_dbus_error_encode_gerror(error: *const GError) -> *mut gchar;
    pub fn g_dbus_annotation_info_lookup(annotations:
                                             *mut *mut GDBusAnnotationInfo,
                                         name: *const gchar) -> *const gchar;
    pub fn g_dbus_interface_info_lookup_method(info: *mut GDBusInterfaceInfo,
                                               name: *const gchar)
     -> *mut GDBusMethodInfo;
    pub fn g_dbus_interface_info_lookup_signal(info: *mut GDBusInterfaceInfo,
                                               name: *const gchar)
     -> *mut GDBusSignalInfo;
    pub fn g_dbus_interface_info_lookup_property(info:
                                                     *mut GDBusInterfaceInfo,
                                                 name: *const gchar)
     -> *mut GDBusPropertyInfo;
    pub fn g_dbus_interface_info_cache_build(info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_interface_info_cache_release(info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_interface_info_generate_xml(info: *mut GDBusInterfaceInfo,
                                              indent: guint,
                                              string_builder: *mut GString);
    pub fn g_dbus_node_info_new_for_xml(xml_data: *const gchar,
                                        error: *mut *mut GError)
     -> *mut GDBusNodeInfo;
    pub fn g_dbus_node_info_lookup_interface(info: *mut GDBusNodeInfo,
                                             name: *const gchar)
     -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_node_info_generate_xml(info: *mut GDBusNodeInfo,
                                         indent: guint,
                                         string_builder: *mut GString);
    pub fn g_dbus_node_info_ref(info: *mut GDBusNodeInfo)
     -> *mut GDBusNodeInfo;
    pub fn g_dbus_interface_info_ref(info: *mut GDBusInterfaceInfo)
     -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_method_info_ref(info: *mut GDBusMethodInfo)
     -> *mut GDBusMethodInfo;
    pub fn g_dbus_signal_info_ref(info: *mut GDBusSignalInfo)
     -> *mut GDBusSignalInfo;
    pub fn g_dbus_property_info_ref(info: *mut GDBusPropertyInfo)
     -> *mut GDBusPropertyInfo;
    pub fn g_dbus_arg_info_ref(info: *mut GDBusArgInfo) -> *mut GDBusArgInfo;
    pub fn g_dbus_annotation_info_ref(info: *mut GDBusAnnotationInfo)
     -> *mut GDBusAnnotationInfo;
    pub fn g_dbus_node_info_unref(info: *mut GDBusNodeInfo);
    pub fn g_dbus_interface_info_unref(info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_method_info_unref(info: *mut GDBusMethodInfo);
    pub fn g_dbus_signal_info_unref(info: *mut GDBusSignalInfo);
    pub fn g_dbus_property_info_unref(info: *mut GDBusPropertyInfo);
    pub fn g_dbus_arg_info_unref(info: *mut GDBusArgInfo);
    pub fn g_dbus_annotation_info_unref(info: *mut GDBusAnnotationInfo);
    pub fn g_dbus_node_info_get_type() -> GType;
    pub fn g_dbus_interface_info_get_type() -> GType;
    pub fn g_dbus_method_info_get_type() -> GType;
    pub fn g_dbus_signal_info_get_type() -> GType;
    pub fn g_dbus_property_info_get_type() -> GType;
    pub fn g_dbus_arg_info_get_type() -> GType;
    pub fn g_dbus_annotation_info_get_type() -> GType;
    pub fn g_dbus_message_get_type() -> GType;
    pub fn g_dbus_message_new() -> *mut GDBusMessage;
    pub fn g_dbus_message_new_signal(path: *const gchar,
                                     interface_: *const gchar,
                                     signal: *const gchar)
     -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_call(name: *const gchar,
                                          path: *const gchar,
                                          interface_: *const gchar,
                                          method: *const gchar)
     -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_reply(method_call_message:
                                               *mut GDBusMessage)
     -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_error(method_call_message:
                                               *mut GDBusMessage,
                                           error_name: *const gchar,
                                           error_message_format:
                                               *const gchar, ...)
     -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_error_valist(method_call_message:
                                                      *mut GDBusMessage,
                                                  error_name: *const gchar,
                                                  error_message_format:
                                                      *const gchar,
                                                  var_args: va_list)
     -> *mut GDBusMessage;
    pub fn g_dbus_message_new_method_error_literal(method_call_message:
                                                       *mut GDBusMessage,
                                                   error_name: *const gchar,
                                                   error_message:
                                                       *const gchar)
     -> *mut GDBusMessage;
    pub fn g_dbus_message_print(message: *mut GDBusMessage, indent: guint)
     -> *mut gchar;
    pub fn g_dbus_message_get_locked(message: *mut GDBusMessage) -> gboolean;
    pub fn g_dbus_message_lock(message: *mut GDBusMessage);
    pub fn g_dbus_message_copy(message: *mut GDBusMessage,
                               error: *mut *mut GError) -> *mut GDBusMessage;
    pub fn g_dbus_message_get_byte_order(message: *mut GDBusMessage)
     -> GDBusMessageByteOrder;
    pub fn g_dbus_message_set_byte_order(message: *mut GDBusMessage,
                                         byte_order: GDBusMessageByteOrder);
    pub fn g_dbus_message_get_message_type(message: *mut GDBusMessage)
     -> GDBusMessageType;
    pub fn g_dbus_message_set_message_type(message: *mut GDBusMessage,
                                           _type: GDBusMessageType);
    pub fn g_dbus_message_get_flags(message: *mut GDBusMessage)
     -> GDBusMessageFlags;
    pub fn g_dbus_message_set_flags(message: *mut GDBusMessage,
                                    flags: GDBusMessageFlags);
    pub fn g_dbus_message_get_serial(message: *mut GDBusMessage) -> guint32;
    pub fn g_dbus_message_set_serial(message: *mut GDBusMessage,
                                     serial: guint32);
    pub fn g_dbus_message_get_header(message: *mut GDBusMessage,
                                     header_field: GDBusMessageHeaderField)
     -> *mut GVariant;
    pub fn g_dbus_message_set_header(message: *mut GDBusMessage,
                                     header_field: GDBusMessageHeaderField,
                                     value: *mut GVariant);
    pub fn g_dbus_message_get_header_fields(message: *mut GDBusMessage)
     -> *mut guchar;
    pub fn g_dbus_message_get_body(message: *mut GDBusMessage)
     -> *mut GVariant;
    pub fn g_dbus_message_set_body(message: *mut GDBusMessage,
                                   body: *mut GVariant);
    pub fn g_dbus_message_get_unix_fd_list(message: *mut GDBusMessage)
     -> *mut GUnixFDList;
    pub fn g_dbus_message_set_unix_fd_list(message: *mut GDBusMessage,
                                           fd_list: *mut GUnixFDList);
    pub fn g_dbus_message_get_reply_serial(message: *mut GDBusMessage)
     -> guint32;
    pub fn g_dbus_message_set_reply_serial(message: *mut GDBusMessage,
                                           value: guint32);
    pub fn g_dbus_message_get_interface(message: *mut GDBusMessage)
     -> *const gchar;
    pub fn g_dbus_message_set_interface(message: *mut GDBusMessage,
                                        value: *const gchar);
    pub fn g_dbus_message_get_member(message: *mut GDBusMessage)
     -> *const gchar;
    pub fn g_dbus_message_set_member(message: *mut GDBusMessage,
                                     value: *const gchar);
    pub fn g_dbus_message_get_path(message: *mut GDBusMessage)
     -> *const gchar;
    pub fn g_dbus_message_set_path(message: *mut GDBusMessage,
                                   value: *const gchar);
    pub fn g_dbus_message_get_sender(message: *mut GDBusMessage)
     -> *const gchar;
    pub fn g_dbus_message_set_sender(message: *mut GDBusMessage,
                                     value: *const gchar);
    pub fn g_dbus_message_get_destination(message: *mut GDBusMessage)
     -> *const gchar;
    pub fn g_dbus_message_set_destination(message: *mut GDBusMessage,
                                          value: *const gchar);
    pub fn g_dbus_message_get_error_name(message: *mut GDBusMessage)
     -> *const gchar;
    pub fn g_dbus_message_set_error_name(message: *mut GDBusMessage,
                                         value: *const gchar);
    pub fn g_dbus_message_get_signature(message: *mut GDBusMessage)
     -> *const gchar;
    pub fn g_dbus_message_set_signature(message: *mut GDBusMessage,
                                        value: *const gchar);
    pub fn g_dbus_message_get_num_unix_fds(message: *mut GDBusMessage)
     -> guint32;
    pub fn g_dbus_message_set_num_unix_fds(message: *mut GDBusMessage,
                                           value: guint32);
    pub fn g_dbus_message_get_arg0(message: *mut GDBusMessage)
     -> *const gchar;
    pub fn g_dbus_message_new_from_blob(blob: *mut guchar, blob_len: gsize,
                                        capabilities: GDBusCapabilityFlags,
                                        error: *mut *mut GError)
     -> *mut GDBusMessage;
    pub fn g_dbus_message_bytes_needed(blob: *mut guchar, blob_len: gsize,
                                       error: *mut *mut GError) -> gssize;
    pub fn g_dbus_message_to_blob(message: *mut GDBusMessage,
                                  out_size: *mut gsize,
                                  capabilities: GDBusCapabilityFlags,
                                  error: *mut *mut GError) -> *mut guchar;
    pub fn g_dbus_message_to_gerror(message: *mut GDBusMessage,
                                    error: *mut *mut GError) -> gboolean;
    pub fn g_dbus_method_invocation_get_type() -> GType;
    pub fn g_dbus_method_invocation_get_sender(invocation:
                                                   *mut GDBusMethodInvocation)
     -> *const gchar;
    pub fn g_dbus_method_invocation_get_object_path(invocation:
                                                        *mut GDBusMethodInvocation)
     -> *const gchar;
    pub fn g_dbus_method_invocation_get_interface_name(invocation:
                                                           *mut GDBusMethodInvocation)
     -> *const gchar;
    pub fn g_dbus_method_invocation_get_method_name(invocation:
                                                        *mut GDBusMethodInvocation)
     -> *const gchar;
    pub fn g_dbus_method_invocation_get_method_info(invocation:
                                                        *mut GDBusMethodInvocation)
     -> *const GDBusMethodInfo;
    pub fn g_dbus_method_invocation_get_property_info(invocation:
                                                          *mut GDBusMethodInvocation)
     -> *const GDBusPropertyInfo;
    pub fn g_dbus_method_invocation_get_connection(invocation:
                                                       *mut GDBusMethodInvocation)
     -> *mut GDBusConnection;
    pub fn g_dbus_method_invocation_get_message(invocation:
                                                    *mut GDBusMethodInvocation)
     -> *mut GDBusMessage;
    pub fn g_dbus_method_invocation_get_parameters(invocation:
                                                       *mut GDBusMethodInvocation)
     -> *mut GVariant;
    pub fn g_dbus_method_invocation_get_user_data(invocation:
                                                      *mut GDBusMethodInvocation)
     -> gpointer;
    pub fn g_dbus_method_invocation_return_value(invocation:
                                                     *mut GDBusMethodInvocation,
                                                 parameters: *mut GVariant);
    pub fn g_dbus_method_invocation_return_value_with_unix_fd_list(invocation:
                                                                       *mut GDBusMethodInvocation,
                                                                   parameters:
                                                                       *mut GVariant,
                                                                   fd_list:
                                                                       *mut GUnixFDList);
    pub fn g_dbus_method_invocation_return_error(invocation:
                                                     *mut GDBusMethodInvocation,
                                                 domain: GQuark, code: gint,
                                                 format: *const gchar, ...);
    pub fn g_dbus_method_invocation_return_error_valist(invocation:
                                                            *mut GDBusMethodInvocation,
                                                        domain: GQuark,
                                                        code: gint,
                                                        format: *const gchar,
                                                        var_args: va_list);
    pub fn g_dbus_method_invocation_return_error_literal(invocation:
                                                             *mut GDBusMethodInvocation,
                                                         domain: GQuark,
                                                         code: gint,
                                                         message:
                                                             *const gchar);
    pub fn g_dbus_method_invocation_return_gerror(invocation:
                                                      *mut GDBusMethodInvocation,
                                                  error: *const GError);
    pub fn g_dbus_method_invocation_take_error(invocation:
                                                   *mut GDBusMethodInvocation,
                                               error: *mut GError);
    pub fn g_dbus_method_invocation_return_dbus_error(invocation:
                                                          *mut GDBusMethodInvocation,
                                                      error_name:
                                                          *const gchar,
                                                      error_message:
                                                          *const gchar);
    pub fn g_bus_own_name(bus_type: GBusType, name: *const gchar,
                          flags: GBusNameOwnerFlags,
                          bus_acquired_handler: GBusAcquiredCallback,
                          name_acquired_handler: GBusNameAcquiredCallback,
                          name_lost_handler: GBusNameLostCallback,
                          user_data: gpointer,
                          user_data_free_func: GDestroyNotify) -> guint;
    pub fn g_bus_own_name_on_connection(connection: *mut GDBusConnection,
                                        name: *const gchar,
                                        flags: GBusNameOwnerFlags,
                                        name_acquired_handler:
                                            GBusNameAcquiredCallback,
                                        name_lost_handler:
                                            GBusNameLostCallback,
                                        user_data: gpointer,
                                        user_data_free_func: GDestroyNotify)
     -> guint;
    pub fn g_bus_own_name_with_closures(bus_type: GBusType,
                                        name: *const gchar,
                                        flags: GBusNameOwnerFlags,
                                        bus_acquired_closure: *mut GClosure,
                                        name_acquired_closure: *mut GClosure,
                                        name_lost_closure: *mut GClosure)
     -> guint;
    pub fn g_bus_own_name_on_connection_with_closures(connection:
                                                          *mut GDBusConnection,
                                                      name: *const gchar,
                                                      flags:
                                                          GBusNameOwnerFlags,
                                                      name_acquired_closure:
                                                          *mut GClosure,
                                                      name_lost_closure:
                                                          *mut GClosure)
     -> guint;
    pub fn g_bus_unown_name(owner_id: guint);
    pub fn g_bus_watch_name(bus_type: GBusType, name: *const gchar,
                            flags: GBusNameWatcherFlags,
                            name_appeared_handler: GBusNameAppearedCallback,
                            name_vanished_handler: GBusNameVanishedCallback,
                            user_data: gpointer,
                            user_data_free_func: GDestroyNotify) -> guint;
    pub fn g_bus_watch_name_on_connection(connection: *mut GDBusConnection,
                                          name: *const gchar,
                                          flags: GBusNameWatcherFlags,
                                          name_appeared_handler:
                                              GBusNameAppearedCallback,
                                          name_vanished_handler:
                                              GBusNameVanishedCallback,
                                          user_data: gpointer,
                                          user_data_free_func: GDestroyNotify)
     -> guint;
    pub fn g_bus_watch_name_with_closures(bus_type: GBusType,
                                          name: *const gchar,
                                          flags: GBusNameWatcherFlags,
                                          name_appeared_closure:
                                              *mut GClosure,
                                          name_vanished_closure:
                                              *mut GClosure) -> guint;
    pub fn g_bus_watch_name_on_connection_with_closures(connection:
                                                            *mut GDBusConnection,
                                                        name: *const gchar,
                                                        flags:
                                                            GBusNameWatcherFlags,
                                                        name_appeared_closure:
                                                            *mut GClosure,
                                                        name_vanished_closure:
                                                            *mut GClosure)
     -> guint;
    pub fn g_bus_unwatch_name(watcher_id: guint);
    pub fn g_dbus_proxy_get_type() -> GType;
    pub fn g_dbus_proxy_new(connection: *mut GDBusConnection,
                            flags: GDBusProxyFlags,
                            info: *mut GDBusInterfaceInfo, name: *const gchar,
                            object_path: *const gchar,
                            interface_name: *const gchar,
                            cancellable: *mut GCancellable,
                            callback: GAsyncReadyCallback,
                            user_data: gpointer);
    pub fn g_dbus_proxy_new_finish(res: *mut GAsyncResult,
                                   error: *mut *mut GError)
     -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new_sync(connection: *mut GDBusConnection,
                                 flags: GDBusProxyFlags,
                                 info: *mut GDBusInterfaceInfo,
                                 name: *const gchar,
                                 object_path: *const gchar,
                                 interface_name: *const gchar,
                                 cancellable: *mut GCancellable,
                                 error: *mut *mut GError) -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new_for_bus(bus_type: GBusType,
                                    flags: GDBusProxyFlags,
                                    info: *mut GDBusInterfaceInfo,
                                    name: *const gchar,
                                    object_path: *const gchar,
                                    interface_name: *const gchar,
                                    cancellable: *mut GCancellable,
                                    callback: GAsyncReadyCallback,
                                    user_data: gpointer);
    pub fn g_dbus_proxy_new_for_bus_finish(res: *mut GAsyncResult,
                                           error: *mut *mut GError)
     -> *mut GDBusProxy;
    pub fn g_dbus_proxy_new_for_bus_sync(bus_type: GBusType,
                                         flags: GDBusProxyFlags,
                                         info: *mut GDBusInterfaceInfo,
                                         name: *const gchar,
                                         object_path: *const gchar,
                                         interface_name: *const gchar,
                                         cancellable: *mut GCancellable,
                                         error: *mut *mut GError)
     -> *mut GDBusProxy;
    pub fn g_dbus_proxy_get_connection(proxy: *mut GDBusProxy)
     -> *mut GDBusConnection;
    pub fn g_dbus_proxy_get_flags(proxy: *mut GDBusProxy) -> GDBusProxyFlags;
    pub fn g_dbus_proxy_get_name(proxy: *mut GDBusProxy) -> *const gchar;
    pub fn g_dbus_proxy_get_name_owner(proxy: *mut GDBusProxy) -> *mut gchar;
    pub fn g_dbus_proxy_get_object_path(proxy: *mut GDBusProxy)
     -> *const gchar;
    pub fn g_dbus_proxy_get_interface_name(proxy: *mut GDBusProxy)
     -> *const gchar;
    pub fn g_dbus_proxy_get_default_timeout(proxy: *mut GDBusProxy) -> gint;
    pub fn g_dbus_proxy_set_default_timeout(proxy: *mut GDBusProxy,
                                            timeout_msec: gint);
    pub fn g_dbus_proxy_get_interface_info(proxy: *mut GDBusProxy)
     -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_proxy_set_interface_info(proxy: *mut GDBusProxy,
                                           info: *mut GDBusInterfaceInfo);
    pub fn g_dbus_proxy_get_cached_property(proxy: *mut GDBusProxy,
                                            property_name: *const gchar)
     -> *mut GVariant;
    pub fn g_dbus_proxy_set_cached_property(proxy: *mut GDBusProxy,
                                            property_name: *const gchar,
                                            value: *mut GVariant);
    pub fn g_dbus_proxy_get_cached_property_names(proxy: *mut GDBusProxy)
     -> *mut *mut gchar;
    pub fn g_dbus_proxy_call(proxy: *mut GDBusProxy,
                             method_name: *const gchar,
                             parameters: *mut GVariant, flags: GDBusCallFlags,
                             timeout_msec: gint,
                             cancellable: *mut GCancellable,
                             callback: GAsyncReadyCallback,
                             user_data: gpointer);
    pub fn g_dbus_proxy_call_finish(proxy: *mut GDBusProxy,
                                    res: *mut GAsyncResult,
                                    error: *mut *mut GError) -> *mut GVariant;
    pub fn g_dbus_proxy_call_sync(proxy: *mut GDBusProxy,
                                  method_name: *const gchar,
                                  parameters: *mut GVariant,
                                  flags: GDBusCallFlags, timeout_msec: gint,
                                  cancellable: *mut GCancellable,
                                  error: *mut *mut GError) -> *mut GVariant;
    pub fn g_dbus_proxy_call_with_unix_fd_list(proxy: *mut GDBusProxy,
                                               method_name: *const gchar,
                                               parameters: *mut GVariant,
                                               flags: GDBusCallFlags,
                                               timeout_msec: gint,
                                               fd_list: *mut GUnixFDList,
                                               cancellable: *mut GCancellable,
                                               callback: GAsyncReadyCallback,
                                               user_data: gpointer);
    pub fn g_dbus_proxy_call_with_unix_fd_list_finish(proxy: *mut GDBusProxy,
                                                      out_fd_list:
                                                          *mut *mut GUnixFDList,
                                                      res: *mut GAsyncResult,
                                                      error: *mut *mut GError)
     -> *mut GVariant;
    pub fn g_dbus_proxy_call_with_unix_fd_list_sync(proxy: *mut GDBusProxy,
                                                    method_name: *const gchar,
                                                    parameters: *mut GVariant,
                                                    flags: GDBusCallFlags,
                                                    timeout_msec: gint,
                                                    fd_list: *mut GUnixFDList,
                                                    out_fd_list:
                                                        *mut *mut GUnixFDList,
                                                    cancellable:
                                                        *mut GCancellable,
                                                    error: *mut *mut GError)
     -> *mut GVariant;
    pub fn g_dbus_server_get_type() -> GType;
    pub fn g_dbus_server_new_sync(address: *const gchar,
                                  flags: GDBusServerFlags, guid: *const gchar,
                                  observer: *mut GDBusAuthObserver,
                                  cancellable: *mut GCancellable,
                                  error: *mut *mut GError)
     -> *mut GDBusServer;
    pub fn g_dbus_server_get_client_address(server: *mut GDBusServer)
     -> *const gchar;
    pub fn g_dbus_server_get_guid(server: *mut GDBusServer) -> *const gchar;
    pub fn g_dbus_server_get_flags(server: *mut GDBusServer)
     -> GDBusServerFlags;
    pub fn g_dbus_server_start(server: *mut GDBusServer);
    pub fn g_dbus_server_stop(server: *mut GDBusServer);
    pub fn g_dbus_server_is_active(server: *mut GDBusServer) -> gboolean;
    pub fn g_dbus_is_guid(string: *const gchar) -> gboolean;
    pub fn g_dbus_generate_guid() -> *mut gchar;
    pub fn g_dbus_is_name(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_unique_name(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_member_name(string: *const gchar) -> gboolean;
    pub fn g_dbus_is_interface_name(string: *const gchar) -> gboolean;
    pub fn g_dbus_gvariant_to_gvalue(value: *mut GVariant,
                                     out_gvalue: *mut GValue);
    pub fn g_dbus_gvalue_to_gvariant(gvalue: *const GValue,
                                     _type: *const GVariantType)
     -> *mut GVariant;
    pub fn g_drive_get_type() -> GType;
    pub fn g_drive_get_name(drive: *mut GDrive)
     -> *mut ::std::os::raw::c_char;
    pub fn g_drive_get_icon(drive: *mut GDrive) -> *mut GIcon;
    pub fn g_drive_get_symbolic_icon(drive: *mut GDrive) -> *mut GIcon;
    pub fn g_drive_has_volumes(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_get_volumes(drive: *mut GDrive) -> *mut GList;
    pub fn g_drive_is_media_removable(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_has_media(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_is_media_check_automatic(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_poll_for_media(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_eject(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_eject(drive: *mut GDrive, flags: GMountUnmountFlags,
                         cancellable: *mut GCancellable,
                         callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_drive_eject_finish(drive: *mut GDrive, result: *mut GAsyncResult,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_drive_poll_for_media(drive: *mut GDrive,
                                  cancellable: *mut GCancellable,
                                  callback: GAsyncReadyCallback,
                                  user_data: gpointer);
    pub fn g_drive_poll_for_media_finish(drive: *mut GDrive,
                                         result: *mut GAsyncResult,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_drive_get_identifier(drive: *mut GDrive,
                                  kind: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn g_drive_enumerate_identifiers(drive: *mut GDrive)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn g_drive_get_start_stop_type(drive: *mut GDrive)
     -> GDriveStartStopType;
    pub fn g_drive_can_start(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_can_start_degraded(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_start(drive: *mut GDrive, flags: GDriveStartFlags,
                         mount_operation: *mut GMountOperation,
                         cancellable: *mut GCancellable,
                         callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_drive_start_finish(drive: *mut GDrive, result: *mut GAsyncResult,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_drive_can_stop(drive: *mut GDrive) -> gboolean;
    pub fn g_drive_stop(drive: *mut GDrive, flags: GMountUnmountFlags,
                        mount_operation: *mut GMountOperation,
                        cancellable: *mut GCancellable,
                        callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_drive_stop_finish(drive: *mut GDrive, result: *mut GAsyncResult,
                               error: *mut *mut GError) -> gboolean;
    pub fn g_drive_eject_with_operation(drive: *mut GDrive,
                                        flags: GMountUnmountFlags,
                                        mount_operation: *mut GMountOperation,
                                        cancellable: *mut GCancellable,
                                        callback: GAsyncReadyCallback,
                                        user_data: gpointer);
    pub fn g_drive_eject_with_operation_finish(drive: *mut GDrive,
                                               result: *mut GAsyncResult,
                                               error: *mut *mut GError)
     -> gboolean;
    pub fn g_drive_get_sort_key(drive: *mut GDrive) -> *const gchar;
    pub fn g_icon_get_type() -> GType;
    pub fn g_icon_hash(icon: gconstpointer) -> guint;
    pub fn g_icon_equal(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean;
    pub fn g_icon_to_string(icon: *mut GIcon) -> *mut gchar;
    pub fn g_icon_new_for_string(str: *const gchar, error: *mut *mut GError)
     -> *mut GIcon;
    pub fn g_icon_serialize(icon: *mut GIcon) -> *mut GVariant;
    pub fn g_icon_deserialize(value: *mut GVariant) -> *mut GIcon;
    pub fn g_emblem_get_type() -> GType;
    pub fn g_emblem_new(icon: *mut GIcon) -> *mut GEmblem;
    pub fn g_emblem_new_with_origin(icon: *mut GIcon, origin: GEmblemOrigin)
     -> *mut GEmblem;
    pub fn g_emblem_get_icon(emblem: *mut GEmblem) -> *mut GIcon;
    pub fn g_emblem_get_origin(emblem: *mut GEmblem) -> GEmblemOrigin;
    pub fn g_emblemed_icon_get_type() -> GType;
    pub fn g_emblemed_icon_new(icon: *mut GIcon, emblem: *mut GEmblem)
     -> *mut GIcon;
    pub fn g_emblemed_icon_get_icon(emblemed: *mut GEmblemedIcon)
     -> *mut GIcon;
    pub fn g_emblemed_icon_get_emblems(emblemed: *mut GEmblemedIcon)
     -> *mut GList;
    pub fn g_emblemed_icon_add_emblem(emblemed: *mut GEmblemedIcon,
                                      emblem: *mut GEmblem);
    pub fn g_emblemed_icon_clear_emblems(emblemed: *mut GEmblemedIcon);
    pub fn g_file_attribute_info_list_get_type() -> GType;
    pub fn g_file_attribute_info_list_new() -> *mut GFileAttributeInfoList;
    pub fn g_file_attribute_info_list_ref(list: *mut GFileAttributeInfoList)
     -> *mut GFileAttributeInfoList;
    pub fn g_file_attribute_info_list_unref(list:
                                                *mut GFileAttributeInfoList);
    pub fn g_file_attribute_info_list_dup(list: *mut GFileAttributeInfoList)
     -> *mut GFileAttributeInfoList;
    pub fn g_file_attribute_info_list_lookup(list:
                                                 *mut GFileAttributeInfoList,
                                             name:
                                                 *const ::std::os::raw::c_char)
     -> *const GFileAttributeInfo;
    pub fn g_file_attribute_info_list_add(list: *mut GFileAttributeInfoList,
                                          name: *const ::std::os::raw::c_char,
                                          _type: GFileAttributeType,
                                          flags: GFileAttributeInfoFlags);
    pub fn g_file_enumerator_get_type() -> GType;
    pub fn g_file_enumerator_next_file(enumerator: *mut GFileEnumerator,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_file_enumerator_close(enumerator: *mut GFileEnumerator,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_file_enumerator_next_files_async(enumerator:
                                                  *mut GFileEnumerator,
                                              num_files:
                                                  ::std::os::raw::c_int,
                                              io_priority:
                                                  ::std::os::raw::c_int,
                                              cancellable: *mut GCancellable,
                                              callback: GAsyncReadyCallback,
                                              user_data: gpointer);
    pub fn g_file_enumerator_next_files_finish(enumerator:
                                                   *mut GFileEnumerator,
                                               result: *mut GAsyncResult,
                                               error: *mut *mut GError)
     -> *mut GList;
    pub fn g_file_enumerator_close_async(enumerator: *mut GFileEnumerator,
                                         io_priority: ::std::os::raw::c_int,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_file_enumerator_close_finish(enumerator: *mut GFileEnumerator,
                                          result: *mut GAsyncResult,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_enumerator_is_closed(enumerator: *mut GFileEnumerator)
     -> gboolean;
    pub fn g_file_enumerator_has_pending(enumerator: *mut GFileEnumerator)
     -> gboolean;
    pub fn g_file_enumerator_set_pending(enumerator: *mut GFileEnumerator,
                                         pending: gboolean);
    pub fn g_file_enumerator_get_container(enumerator: *mut GFileEnumerator)
     -> *mut GFile;
    pub fn g_file_enumerator_get_child(enumerator: *mut GFileEnumerator,
                                       info: *mut GFileInfo) -> *mut GFile;
    pub fn g_file_enumerator_iterate(direnum: *mut GFileEnumerator,
                                     out_info: *mut *mut GFileInfo,
                                     out_child: *mut *mut GFile,
                                     cancellable: *mut GCancellable,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_file_get_type() -> GType;
    pub fn g_file_new_for_path(path: *const ::std::os::raw::c_char)
     -> *mut GFile;
    pub fn g_file_new_for_uri(uri: *const ::std::os::raw::c_char)
     -> *mut GFile;
    pub fn g_file_new_for_commandline_arg(arg: *const ::std::os::raw::c_char)
     -> *mut GFile;
    pub fn g_file_new_for_commandline_arg_and_cwd(arg: *const gchar,
                                                  cwd: *const gchar)
     -> *mut GFile;
    pub fn g_file_new_tmp(tmpl: *const ::std::os::raw::c_char,
                          iostream: *mut *mut GFileIOStream,
                          error: *mut *mut GError) -> *mut GFile;
    pub fn g_file_parse_name(parse_name: *const ::std::os::raw::c_char)
     -> *mut GFile;
    pub fn g_file_dup(file: *mut GFile) -> *mut GFile;
    pub fn g_file_hash(file: gconstpointer) -> guint;
    pub fn g_file_equal(file1: *mut GFile, file2: *mut GFile) -> gboolean;
    pub fn g_file_get_basename(file: *mut GFile)
     -> *mut ::std::os::raw::c_char;
    pub fn g_file_get_path(file: *mut GFile) -> *mut ::std::os::raw::c_char;
    pub fn g_file_get_uri(file: *mut GFile) -> *mut ::std::os::raw::c_char;
    pub fn g_file_get_parse_name(file: *mut GFile)
     -> *mut ::std::os::raw::c_char;
    pub fn g_file_get_parent(file: *mut GFile) -> *mut GFile;
    pub fn g_file_has_parent(file: *mut GFile, parent: *mut GFile)
     -> gboolean;
    pub fn g_file_get_child(file: *mut GFile,
                            name: *const ::std::os::raw::c_char)
     -> *mut GFile;
    pub fn g_file_get_child_for_display_name(file: *mut GFile,
                                             display_name:
                                                 *const ::std::os::raw::c_char,
                                             error: *mut *mut GError)
     -> *mut GFile;
    pub fn g_file_has_prefix(file: *mut GFile, prefix: *mut GFile)
     -> gboolean;
    pub fn g_file_get_relative_path(parent: *mut GFile,
                                    descendant: *mut GFile)
     -> *mut ::std::os::raw::c_char;
    pub fn g_file_resolve_relative_path(file: *mut GFile,
                                        relative_path:
                                            *const ::std::os::raw::c_char)
     -> *mut GFile;
    pub fn g_file_is_native(file: *mut GFile) -> gboolean;
    pub fn g_file_has_uri_scheme(file: *mut GFile,
                                 uri_scheme: *const ::std::os::raw::c_char)
     -> gboolean;
    pub fn g_file_get_uri_scheme(file: *mut GFile)
     -> *mut ::std::os::raw::c_char;
    pub fn g_file_read(file: *mut GFile, cancellable: *mut GCancellable,
                       error: *mut *mut GError) -> *mut GFileInputStream;
    pub fn g_file_read_async(file: *mut GFile,
                             io_priority: ::std::os::raw::c_int,
                             cancellable: *mut GCancellable,
                             callback: GAsyncReadyCallback,
                             user_data: gpointer);
    pub fn g_file_read_finish(file: *mut GFile, res: *mut GAsyncResult,
                              error: *mut *mut GError)
     -> *mut GFileInputStream;
    pub fn g_file_append_to(file: *mut GFile, flags: GFileCreateFlags,
                            cancellable: *mut GCancellable,
                            error: *mut *mut GError)
     -> *mut GFileOutputStream;
    pub fn g_file_create(file: *mut GFile, flags: GFileCreateFlags,
                         cancellable: *mut GCancellable,
                         error: *mut *mut GError) -> *mut GFileOutputStream;
    pub fn g_file_replace(file: *mut GFile,
                          etag: *const ::std::os::raw::c_char,
                          make_backup: gboolean, flags: GFileCreateFlags,
                          cancellable: *mut GCancellable,
                          error: *mut *mut GError) -> *mut GFileOutputStream;
    pub fn g_file_append_to_async(file: *mut GFile, flags: GFileCreateFlags,
                                  io_priority: ::std::os::raw::c_int,
                                  cancellable: *mut GCancellable,
                                  callback: GAsyncReadyCallback,
                                  user_data: gpointer);
    pub fn g_file_append_to_finish(file: *mut GFile, res: *mut GAsyncResult,
                                   error: *mut *mut GError)
     -> *mut GFileOutputStream;
    pub fn g_file_create_async(file: *mut GFile, flags: GFileCreateFlags,
                               io_priority: ::std::os::raw::c_int,
                               cancellable: *mut GCancellable,
                               callback: GAsyncReadyCallback,
                               user_data: gpointer);
    pub fn g_file_create_finish(file: *mut GFile, res: *mut GAsyncResult,
                                error: *mut *mut GError)
     -> *mut GFileOutputStream;
    pub fn g_file_replace_async(file: *mut GFile,
                                etag: *const ::std::os::raw::c_char,
                                make_backup: gboolean,
                                flags: GFileCreateFlags,
                                io_priority: ::std::os::raw::c_int,
                                cancellable: *mut GCancellable,
                                callback: GAsyncReadyCallback,
                                user_data: gpointer);
    pub fn g_file_replace_finish(file: *mut GFile, res: *mut GAsyncResult,
                                 error: *mut *mut GError)
     -> *mut GFileOutputStream;
    pub fn g_file_open_readwrite(file: *mut GFile,
                                 cancellable: *mut GCancellable,
                                 error: *mut *mut GError)
     -> *mut GFileIOStream;
    pub fn g_file_open_readwrite_async(file: *mut GFile,
                                       io_priority: ::std::os::raw::c_int,
                                       cancellable: *mut GCancellable,
                                       callback: GAsyncReadyCallback,
                                       user_data: gpointer);
    pub fn g_file_open_readwrite_finish(file: *mut GFile,
                                        res: *mut GAsyncResult,
                                        error: *mut *mut GError)
     -> *mut GFileIOStream;
    pub fn g_file_create_readwrite(file: *mut GFile, flags: GFileCreateFlags,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError)
     -> *mut GFileIOStream;
    pub fn g_file_create_readwrite_async(file: *mut GFile,
                                         flags: GFileCreateFlags,
                                         io_priority: ::std::os::raw::c_int,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_file_create_readwrite_finish(file: *mut GFile,
                                          res: *mut GAsyncResult,
                                          error: *mut *mut GError)
     -> *mut GFileIOStream;
    pub fn g_file_replace_readwrite(file: *mut GFile,
                                    etag: *const ::std::os::raw::c_char,
                                    make_backup: gboolean,
                                    flags: GFileCreateFlags,
                                    cancellable: *mut GCancellable,
                                    error: *mut *mut GError)
     -> *mut GFileIOStream;
    pub fn g_file_replace_readwrite_async(file: *mut GFile,
                                          etag: *const ::std::os::raw::c_char,
                                          make_backup: gboolean,
                                          flags: GFileCreateFlags,
                                          io_priority: ::std::os::raw::c_int,
                                          cancellable: *mut GCancellable,
                                          callback: GAsyncReadyCallback,
                                          user_data: gpointer);
    pub fn g_file_replace_readwrite_finish(file: *mut GFile,
                                           res: *mut GAsyncResult,
                                           error: *mut *mut GError)
     -> *mut GFileIOStream;
    pub fn g_file_query_exists(file: *mut GFile,
                               cancellable: *mut GCancellable) -> gboolean;
    pub fn g_file_query_file_type(file: *mut GFile,
                                  flags: GFileQueryInfoFlags,
                                  cancellable: *mut GCancellable)
     -> GFileType;
    pub fn g_file_query_info(file: *mut GFile,
                             attributes: *const ::std::os::raw::c_char,
                             flags: GFileQueryInfoFlags,
                             cancellable: *mut GCancellable,
                             error: *mut *mut GError) -> *mut GFileInfo;
    pub fn g_file_query_info_async(file: *mut GFile,
                                   attributes: *const ::std::os::raw::c_char,
                                   flags: GFileQueryInfoFlags,
                                   io_priority: ::std::os::raw::c_int,
                                   cancellable: *mut GCancellable,
                                   callback: GAsyncReadyCallback,
                                   user_data: gpointer);
    pub fn g_file_query_info_finish(file: *mut GFile, res: *mut GAsyncResult,
                                    error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_file_query_filesystem_info(file: *mut GFile,
                                        attributes:
                                            *const ::std::os::raw::c_char,
                                        cancellable: *mut GCancellable,
                                        error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_file_query_filesystem_info_async(file: *mut GFile,
                                              attributes:
                                                  *const ::std::os::raw::c_char,
                                              io_priority:
                                                  ::std::os::raw::c_int,
                                              cancellable: *mut GCancellable,
                                              callback: GAsyncReadyCallback,
                                              user_data: gpointer);
    pub fn g_file_query_filesystem_info_finish(file: *mut GFile,
                                               res: *mut GAsyncResult,
                                               error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_file_find_enclosing_mount(file: *mut GFile,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError)
     -> *mut GMount;
    pub fn g_file_find_enclosing_mount_async(file: *mut GFile,
                                             io_priority:
                                                 ::std::os::raw::c_int,
                                             cancellable: *mut GCancellable,
                                             callback: GAsyncReadyCallback,
                                             user_data: gpointer);
    pub fn g_file_find_enclosing_mount_finish(file: *mut GFile,
                                              res: *mut GAsyncResult,
                                              error: *mut *mut GError)
     -> *mut GMount;
    pub fn g_file_enumerate_children(file: *mut GFile,
                                     attributes:
                                         *const ::std::os::raw::c_char,
                                     flags: GFileQueryInfoFlags,
                                     cancellable: *mut GCancellable,
                                     error: *mut *mut GError)
     -> *mut GFileEnumerator;
    pub fn g_file_enumerate_children_async(file: *mut GFile,
                                           attributes:
                                               *const ::std::os::raw::c_char,
                                           flags: GFileQueryInfoFlags,
                                           io_priority: ::std::os::raw::c_int,
                                           cancellable: *mut GCancellable,
                                           callback: GAsyncReadyCallback,
                                           user_data: gpointer);
    pub fn g_file_enumerate_children_finish(file: *mut GFile,
                                            res: *mut GAsyncResult,
                                            error: *mut *mut GError)
     -> *mut GFileEnumerator;
    pub fn g_file_set_display_name(file: *mut GFile,
                                   display_name:
                                       *const ::std::os::raw::c_char,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError) -> *mut GFile;
    pub fn g_file_set_display_name_async(file: *mut GFile,
                                         display_name:
                                             *const ::std::os::raw::c_char,
                                         io_priority: ::std::os::raw::c_int,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_file_set_display_name_finish(file: *mut GFile,
                                          res: *mut GAsyncResult,
                                          error: *mut *mut GError)
     -> *mut GFile;
    pub fn g_file_delete(file: *mut GFile, cancellable: *mut GCancellable,
                         error: *mut *mut GError) -> gboolean;
    pub fn g_file_delete_async(file: *mut GFile,
                               io_priority: ::std::os::raw::c_int,
                               cancellable: *mut GCancellable,
                               callback: GAsyncReadyCallback,
                               user_data: gpointer);
    pub fn g_file_delete_finish(file: *mut GFile, result: *mut GAsyncResult,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_file_trash(file: *mut GFile, cancellable: *mut GCancellable,
                        error: *mut *mut GError) -> gboolean;
    pub fn g_file_trash_async(file: *mut GFile,
                              io_priority: ::std::os::raw::c_int,
                              cancellable: *mut GCancellable,
                              callback: GAsyncReadyCallback,
                              user_data: gpointer);
    pub fn g_file_trash_finish(file: *mut GFile, result: *mut GAsyncResult,
                               error: *mut *mut GError) -> gboolean;
    pub fn g_file_copy(source: *mut GFile, destination: *mut GFile,
                       flags: GFileCopyFlags, cancellable: *mut GCancellable,
                       progress_callback: GFileProgressCallback,
                       progress_callback_data: gpointer,
                       error: *mut *mut GError) -> gboolean;
    pub fn g_file_copy_async(source: *mut GFile, destination: *mut GFile,
                             flags: GFileCopyFlags,
                             io_priority: ::std::os::raw::c_int,
                             cancellable: *mut GCancellable,
                             progress_callback: GFileProgressCallback,
                             progress_callback_data: gpointer,
                             callback: GAsyncReadyCallback,
                             user_data: gpointer);
    pub fn g_file_copy_finish(file: *mut GFile, res: *mut GAsyncResult,
                              error: *mut *mut GError) -> gboolean;
    pub fn g_file_move(source: *mut GFile, destination: *mut GFile,
                       flags: GFileCopyFlags, cancellable: *mut GCancellable,
                       progress_callback: GFileProgressCallback,
                       progress_callback_data: gpointer,
                       error: *mut *mut GError) -> gboolean;
    pub fn g_file_make_directory(file: *mut GFile,
                                 cancellable: *mut GCancellable,
                                 error: *mut *mut GError) -> gboolean;
    pub fn g_file_make_directory_async(file: *mut GFile,
                                       io_priority: ::std::os::raw::c_int,
                                       cancellable: *mut GCancellable,
                                       callback: GAsyncReadyCallback,
                                       user_data: gpointer);
    pub fn g_file_make_directory_finish(file: *mut GFile,
                                        result: *mut GAsyncResult,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_file_make_directory_with_parents(file: *mut GFile,
                                              cancellable: *mut GCancellable,
                                              error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_make_symbolic_link(file: *mut GFile,
                                     symlink_value:
                                         *const ::std::os::raw::c_char,
                                     cancellable: *mut GCancellable,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_file_query_settable_attributes(file: *mut GFile,
                                            cancellable: *mut GCancellable,
                                            error: *mut *mut GError)
     -> *mut GFileAttributeInfoList;
    pub fn g_file_query_writable_namespaces(file: *mut GFile,
                                            cancellable: *mut GCancellable,
                                            error: *mut *mut GError)
     -> *mut GFileAttributeInfoList;
    pub fn g_file_set_attribute(file: *mut GFile,
                                attribute: *const ::std::os::raw::c_char,
                                _type: GFileAttributeType, value_p: gpointer,
                                flags: GFileQueryInfoFlags,
                                cancellable: *mut GCancellable,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_file_set_attributes_from_info(file: *mut GFile,
                                           info: *mut GFileInfo,
                                           flags: GFileQueryInfoFlags,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_set_attributes_async(file: *mut GFile, info: *mut GFileInfo,
                                       flags: GFileQueryInfoFlags,
                                       io_priority: ::std::os::raw::c_int,
                                       cancellable: *mut GCancellable,
                                       callback: GAsyncReadyCallback,
                                       user_data: gpointer);
    pub fn g_file_set_attributes_finish(file: *mut GFile,
                                        result: *mut GAsyncResult,
                                        info: *mut *mut GFileInfo,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_file_set_attribute_string(file: *mut GFile,
                                       attribute:
                                           *const ::std::os::raw::c_char,
                                       value: *const ::std::os::raw::c_char,
                                       flags: GFileQueryInfoFlags,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_file_set_attribute_byte_string(file: *mut GFile,
                                            attribute:
                                                *const ::std::os::raw::c_char,
                                            value:
                                                *const ::std::os::raw::c_char,
                                            flags: GFileQueryInfoFlags,
                                            cancellable: *mut GCancellable,
                                            error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_set_attribute_uint32(file: *mut GFile,
                                       attribute:
                                           *const ::std::os::raw::c_char,
                                       value: guint32,
                                       flags: GFileQueryInfoFlags,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_file_set_attribute_int32(file: *mut GFile,
                                      attribute:
                                          *const ::std::os::raw::c_char,
                                      value: gint32,
                                      flags: GFileQueryInfoFlags,
                                      cancellable: *mut GCancellable,
                                      error: *mut *mut GError) -> gboolean;
    pub fn g_file_set_attribute_uint64(file: *mut GFile,
                                       attribute:
                                           *const ::std::os::raw::c_char,
                                       value: guint64,
                                       flags: GFileQueryInfoFlags,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_file_set_attribute_int64(file: *mut GFile,
                                      attribute:
                                          *const ::std::os::raw::c_char,
                                      value: gint64,
                                      flags: GFileQueryInfoFlags,
                                      cancellable: *mut GCancellable,
                                      error: *mut *mut GError) -> gboolean;
    pub fn g_file_mount_enclosing_volume(location: *mut GFile,
                                         flags: GMountMountFlags,
                                         mount_operation:
                                             *mut GMountOperation,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_file_mount_enclosing_volume_finish(location: *mut GFile,
                                                result: *mut GAsyncResult,
                                                error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_mount_mountable(file: *mut GFile, flags: GMountMountFlags,
                                  mount_operation: *mut GMountOperation,
                                  cancellable: *mut GCancellable,
                                  callback: GAsyncReadyCallback,
                                  user_data: gpointer);
    pub fn g_file_mount_mountable_finish(file: *mut GFile,
                                         result: *mut GAsyncResult,
                                         error: *mut *mut GError)
     -> *mut GFile;
    pub fn g_file_unmount_mountable(file: *mut GFile,
                                    flags: GMountUnmountFlags,
                                    cancellable: *mut GCancellable,
                                    callback: GAsyncReadyCallback,
                                    user_data: gpointer);
    pub fn g_file_unmount_mountable_finish(file: *mut GFile,
                                           result: *mut GAsyncResult,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_unmount_mountable_with_operation(file: *mut GFile,
                                                   flags: GMountUnmountFlags,
                                                   mount_operation:
                                                       *mut GMountOperation,
                                                   cancellable:
                                                       *mut GCancellable,
                                                   callback:
                                                       GAsyncReadyCallback,
                                                   user_data: gpointer);
    pub fn g_file_unmount_mountable_with_operation_finish(file: *mut GFile,
                                                          result:
                                                              *mut GAsyncResult,
                                                          error:
                                                              *mut *mut GError)
     -> gboolean;
    pub fn g_file_eject_mountable(file: *mut GFile, flags: GMountUnmountFlags,
                                  cancellable: *mut GCancellable,
                                  callback: GAsyncReadyCallback,
                                  user_data: gpointer);
    pub fn g_file_eject_mountable_finish(file: *mut GFile,
                                         result: *mut GAsyncResult,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_file_eject_mountable_with_operation(file: *mut GFile,
                                                 flags: GMountUnmountFlags,
                                                 mount_operation:
                                                     *mut GMountOperation,
                                                 cancellable:
                                                     *mut GCancellable,
                                                 callback:
                                                     GAsyncReadyCallback,
                                                 user_data: gpointer);
    pub fn g_file_eject_mountable_with_operation_finish(file: *mut GFile,
                                                        result:
                                                            *mut GAsyncResult,
                                                        error:
                                                            *mut *mut GError)
     -> gboolean;
    pub fn g_file_copy_attributes(source: *mut GFile, destination: *mut GFile,
                                  flags: GFileCopyFlags,
                                  cancellable: *mut GCancellable,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_file_monitor_directory(file: *mut GFile,
                                    flags: GFileMonitorFlags,
                                    cancellable: *mut GCancellable,
                                    error: *mut *mut GError)
     -> *mut GFileMonitor;
    pub fn g_file_monitor_file(file: *mut GFile, flags: GFileMonitorFlags,
                               cancellable: *mut GCancellable,
                               error: *mut *mut GError) -> *mut GFileMonitor;
    pub fn g_file_monitor(file: *mut GFile, flags: GFileMonitorFlags,
                          cancellable: *mut GCancellable,
                          error: *mut *mut GError) -> *mut GFileMonitor;
    pub fn g_file_measure_disk_usage(file: *mut GFile,
                                     flags: GFileMeasureFlags,
                                     cancellable: *mut GCancellable,
                                     progress_callback:
                                         GFileMeasureProgressCallback,
                                     progress_data: gpointer,
                                     disk_usage: *mut guint64,
                                     num_dirs: *mut guint64,
                                     num_files: *mut guint64,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_file_measure_disk_usage_async(file: *mut GFile,
                                           flags: GFileMeasureFlags,
                                           io_priority: gint,
                                           cancellable: *mut GCancellable,
                                           progress_callback:
                                               GFileMeasureProgressCallback,
                                           progress_data: gpointer,
                                           callback: GAsyncReadyCallback,
                                           user_data: gpointer);
    pub fn g_file_measure_disk_usage_finish(file: *mut GFile,
                                            result: *mut GAsyncResult,
                                            disk_usage: *mut guint64,
                                            num_dirs: *mut guint64,
                                            num_files: *mut guint64,
                                            error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_start_mountable(file: *mut GFile, flags: GDriveStartFlags,
                                  start_operation: *mut GMountOperation,
                                  cancellable: *mut GCancellable,
                                  callback: GAsyncReadyCallback,
                                  user_data: gpointer);
    pub fn g_file_start_mountable_finish(file: *mut GFile,
                                         result: *mut GAsyncResult,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_file_stop_mountable(file: *mut GFile, flags: GMountUnmountFlags,
                                 mount_operation: *mut GMountOperation,
                                 cancellable: *mut GCancellable,
                                 callback: GAsyncReadyCallback,
                                 user_data: gpointer);
    pub fn g_file_stop_mountable_finish(file: *mut GFile,
                                        result: *mut GAsyncResult,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_file_poll_mountable(file: *mut GFile,
                                 cancellable: *mut GCancellable,
                                 callback: GAsyncReadyCallback,
                                 user_data: gpointer);
    pub fn g_file_poll_mountable_finish(file: *mut GFile,
                                        result: *mut GAsyncResult,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_file_query_default_handler(file: *mut GFile,
                                        cancellable: *mut GCancellable,
                                        error: *mut *mut GError)
     -> *mut GAppInfo;
    pub fn g_file_load_contents(file: *mut GFile,
                                cancellable: *mut GCancellable,
                                contents: *mut *mut ::std::os::raw::c_char,
                                length: *mut gsize,
                                etag_out: *mut *mut ::std::os::raw::c_char,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_file_load_contents_async(file: *mut GFile,
                                      cancellable: *mut GCancellable,
                                      callback: GAsyncReadyCallback,
                                      user_data: gpointer);
    pub fn g_file_load_contents_finish(file: *mut GFile,
                                       res: *mut GAsyncResult,
                                       contents:
                                           *mut *mut ::std::os::raw::c_char,
                                       length: *mut gsize,
                                       etag_out:
                                           *mut *mut ::std::os::raw::c_char,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_file_load_partial_contents_async(file: *mut GFile,
                                              cancellable: *mut GCancellable,
                                              read_more_callback:
                                                  GFileReadMoreCallback,
                                              callback: GAsyncReadyCallback,
                                              user_data: gpointer);
    pub fn g_file_load_partial_contents_finish(file: *mut GFile,
                                               res: *mut GAsyncResult,
                                               contents:
                                                   *mut *mut ::std::os::raw::c_char,
                                               length: *mut gsize,
                                               etag_out:
                                                   *mut *mut ::std::os::raw::c_char,
                                               error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_replace_contents(file: *mut GFile,
                                   contents: *const ::std::os::raw::c_char,
                                   length: gsize,
                                   etag: *const ::std::os::raw::c_char,
                                   make_backup: gboolean,
                                   flags: GFileCreateFlags,
                                   new_etag: *mut *mut ::std::os::raw::c_char,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_file_replace_contents_async(file: *mut GFile,
                                         contents:
                                             *const ::std::os::raw::c_char,
                                         length: gsize,
                                         etag: *const ::std::os::raw::c_char,
                                         make_backup: gboolean,
                                         flags: GFileCreateFlags,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_file_replace_contents_bytes_async(file: *mut GFile,
                                               contents: *mut GBytes,
                                               etag:
                                                   *const ::std::os::raw::c_char,
                                               make_backup: gboolean,
                                               flags: GFileCreateFlags,
                                               cancellable: *mut GCancellable,
                                               callback: GAsyncReadyCallback,
                                               user_data: gpointer);
    pub fn g_file_replace_contents_finish(file: *mut GFile,
                                          res: *mut GAsyncResult,
                                          new_etag:
                                              *mut *mut ::std::os::raw::c_char,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_file_supports_thread_contexts(file: *mut GFile) -> gboolean;
    pub fn g_file_icon_get_type() -> GType;
    pub fn g_file_icon_new(file: *mut GFile) -> *mut GIcon;
    pub fn g_file_icon_get_file(icon: *mut GFileIcon) -> *mut GFile;
    pub fn g_file_info_get_type() -> GType;
    pub fn g_file_info_new() -> *mut GFileInfo;
    pub fn g_file_info_dup(other: *mut GFileInfo) -> *mut GFileInfo;
    pub fn g_file_info_copy_into(src_info: *mut GFileInfo,
                                 dest_info: *mut GFileInfo);
    pub fn g_file_info_has_attribute(info: *mut GFileInfo,
                                     attribute: *const ::std::os::raw::c_char)
     -> gboolean;
    pub fn g_file_info_has_namespace(info: *mut GFileInfo,
                                     name_space:
                                         *const ::std::os::raw::c_char)
     -> gboolean;
    pub fn g_file_info_list_attributes(info: *mut GFileInfo,
                                       name_space:
                                           *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn g_file_info_get_attribute_data(info: *mut GFileInfo,
                                          attribute:
                                              *const ::std::os::raw::c_char,
                                          _type: *mut GFileAttributeType,
                                          value_pp: *mut gpointer,
                                          status: *mut GFileAttributeStatus)
     -> gboolean;
    pub fn g_file_info_get_attribute_type(info: *mut GFileInfo,
                                          attribute:
                                              *const ::std::os::raw::c_char)
     -> GFileAttributeType;
    pub fn g_file_info_remove_attribute(info: *mut GFileInfo,
                                        attribute:
                                            *const ::std::os::raw::c_char);
    pub fn g_file_info_get_attribute_status(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char)
     -> GFileAttributeStatus;
    pub fn g_file_info_set_attribute_status(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char,
                                            status: GFileAttributeStatus)
     -> gboolean;
    pub fn g_file_info_get_attribute_as_string(info: *mut GFileInfo,
                                               attribute:
                                                   *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn g_file_info_get_attribute_string(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn g_file_info_get_attribute_byte_string(info: *mut GFileInfo,
                                                 attribute:
                                                     *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn g_file_info_get_attribute_boolean(info: *mut GFileInfo,
                                             attribute:
                                                 *const ::std::os::raw::c_char)
     -> gboolean;
    pub fn g_file_info_get_attribute_uint32(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char)
     -> guint32;
    pub fn g_file_info_get_attribute_int32(info: *mut GFileInfo,
                                           attribute:
                                               *const ::std::os::raw::c_char)
     -> gint32;
    pub fn g_file_info_get_attribute_uint64(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char)
     -> guint64;
    pub fn g_file_info_get_attribute_int64(info: *mut GFileInfo,
                                           attribute:
                                               *const ::std::os::raw::c_char)
     -> gint64;
    pub fn g_file_info_get_attribute_object(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char)
     -> *mut GObject;
    pub fn g_file_info_get_attribute_stringv(info: *mut GFileInfo,
                                             attribute:
                                                 *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn g_file_info_set_attribute(info: *mut GFileInfo,
                                     attribute: *const ::std::os::raw::c_char,
                                     _type: GFileAttributeType,
                                     value_p: gpointer);
    pub fn g_file_info_set_attribute_string(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char,
                                            attr_value:
                                                *const ::std::os::raw::c_char);
    pub fn g_file_info_set_attribute_byte_string(info: *mut GFileInfo,
                                                 attribute:
                                                     *const ::std::os::raw::c_char,
                                                 attr_value:
                                                     *const ::std::os::raw::c_char);
    pub fn g_file_info_set_attribute_boolean(info: *mut GFileInfo,
                                             attribute:
                                                 *const ::std::os::raw::c_char,
                                             attr_value: gboolean);
    pub fn g_file_info_set_attribute_uint32(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char,
                                            attr_value: guint32);
    pub fn g_file_info_set_attribute_int32(info: *mut GFileInfo,
                                           attribute:
                                               *const ::std::os::raw::c_char,
                                           attr_value: gint32);
    pub fn g_file_info_set_attribute_uint64(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char,
                                            attr_value: guint64);
    pub fn g_file_info_set_attribute_int64(info: *mut GFileInfo,
                                           attribute:
                                               *const ::std::os::raw::c_char,
                                           attr_value: gint64);
    pub fn g_file_info_set_attribute_object(info: *mut GFileInfo,
                                            attribute:
                                                *const ::std::os::raw::c_char,
                                            attr_value: *mut GObject);
    pub fn g_file_info_set_attribute_stringv(info: *mut GFileInfo,
                                             attribute:
                                                 *const ::std::os::raw::c_char,
                                             attr_value:
                                                 *mut *mut ::std::os::raw::c_char);
    pub fn g_file_info_clear_status(info: *mut GFileInfo);
    pub fn g_file_info_get_deletion_date(info: *mut GFileInfo)
     -> *mut GDateTime;
    pub fn g_file_info_get_file_type(info: *mut GFileInfo) -> GFileType;
    pub fn g_file_info_get_is_hidden(info: *mut GFileInfo) -> gboolean;
    pub fn g_file_info_get_is_backup(info: *mut GFileInfo) -> gboolean;
    pub fn g_file_info_get_is_symlink(info: *mut GFileInfo) -> gboolean;
    pub fn g_file_info_get_name(info: *mut GFileInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_file_info_get_display_name(info: *mut GFileInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_file_info_get_edit_name(info: *mut GFileInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_file_info_get_icon(info: *mut GFileInfo) -> *mut GIcon;
    pub fn g_file_info_get_symbolic_icon(info: *mut GFileInfo) -> *mut GIcon;
    pub fn g_file_info_get_content_type(info: *mut GFileInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_file_info_get_size(info: *mut GFileInfo) -> goffset;
    pub fn g_file_info_get_modification_time(info: *mut GFileInfo,
                                             result: *mut GTimeVal);
    pub fn g_file_info_get_symlink_target(info: *mut GFileInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_file_info_get_etag(info: *mut GFileInfo)
     -> *const ::std::os::raw::c_char;
    pub fn g_file_info_get_sort_order(info: *mut GFileInfo) -> gint32;
    pub fn g_file_info_set_attribute_mask(info: *mut GFileInfo,
                                          mask: *mut GFileAttributeMatcher);
    pub fn g_file_info_unset_attribute_mask(info: *mut GFileInfo);
    pub fn g_file_info_set_file_type(info: *mut GFileInfo, _type: GFileType);
    pub fn g_file_info_set_is_hidden(info: *mut GFileInfo,
                                     is_hidden: gboolean);
    pub fn g_file_info_set_is_symlink(info: *mut GFileInfo,
                                      is_symlink: gboolean);
    pub fn g_file_info_set_name(info: *mut GFileInfo,
                                name: *const ::std::os::raw::c_char);
    pub fn g_file_info_set_display_name(info: *mut GFileInfo,
                                        display_name:
                                            *const ::std::os::raw::c_char);
    pub fn g_file_info_set_edit_name(info: *mut GFileInfo,
                                     edit_name:
                                         *const ::std::os::raw::c_char);
    pub fn g_file_info_set_icon(info: *mut GFileInfo, icon: *mut GIcon);
    pub fn g_file_info_set_symbolic_icon(info: *mut GFileInfo,
                                         icon: *mut GIcon);
    pub fn g_file_info_set_content_type(info: *mut GFileInfo,
                                        content_type:
                                            *const ::std::os::raw::c_char);
    pub fn g_file_info_set_size(info: *mut GFileInfo, size: goffset);
    pub fn g_file_info_set_modification_time(info: *mut GFileInfo,
                                             mtime: *mut GTimeVal);
    pub fn g_file_info_set_symlink_target(info: *mut GFileInfo,
                                          symlink_target:
                                              *const ::std::os::raw::c_char);
    pub fn g_file_info_set_sort_order(info: *mut GFileInfo,
                                      sort_order: gint32);
    pub fn g_file_attribute_matcher_get_type() -> GType;
    pub fn g_file_attribute_matcher_new(attributes:
                                            *const ::std::os::raw::c_char)
     -> *mut GFileAttributeMatcher;
    pub fn g_file_attribute_matcher_ref(matcher: *mut GFileAttributeMatcher)
     -> *mut GFileAttributeMatcher;
    pub fn g_file_attribute_matcher_unref(matcher:
                                              *mut GFileAttributeMatcher);
    pub fn g_file_attribute_matcher_subtract(matcher:
                                                 *mut GFileAttributeMatcher,
                                             subtract:
                                                 *mut GFileAttributeMatcher)
     -> *mut GFileAttributeMatcher;
    pub fn g_file_attribute_matcher_matches(matcher:
                                                *mut GFileAttributeMatcher,
                                            attribute:
                                                *const ::std::os::raw::c_char)
     -> gboolean;
    pub fn g_file_attribute_matcher_matches_only(matcher:
                                                     *mut GFileAttributeMatcher,
                                                 attribute:
                                                     *const ::std::os::raw::c_char)
     -> gboolean;
    pub fn g_file_attribute_matcher_enumerate_namespace(matcher:
                                                            *mut GFileAttributeMatcher,
                                                        ns:
                                                            *const ::std::os::raw::c_char)
     -> gboolean;
    pub fn g_file_attribute_matcher_enumerate_next(matcher:
                                                       *mut GFileAttributeMatcher)
     -> *const ::std::os::raw::c_char;
    pub fn g_file_attribute_matcher_to_string(matcher:
                                                  *mut GFileAttributeMatcher)
     -> *mut ::std::os::raw::c_char;
    pub fn g_file_input_stream_get_type() -> GType;
    pub fn g_file_input_stream_query_info(stream: *mut GFileInputStream,
                                          attributes:
                                              *const ::std::os::raw::c_char,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_file_input_stream_query_info_async(stream: *mut GFileInputStream,
                                                attributes:
                                                    *const ::std::os::raw::c_char,
                                                io_priority:
                                                    ::std::os::raw::c_int,
                                                cancellable:
                                                    *mut GCancellable,
                                                callback: GAsyncReadyCallback,
                                                user_data: gpointer);
    pub fn g_file_input_stream_query_info_finish(stream:
                                                     *mut GFileInputStream,
                                                 result: *mut GAsyncResult,
                                                 error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_io_error_quark() -> GQuark;
    pub fn g_io_error_from_errno(err_no: gint) -> GIOErrorEnum;
    pub fn g_io_stream_get_type() -> GType;
    pub fn g_io_stream_get_input_stream(stream: *mut GIOStream)
     -> *mut GInputStream;
    pub fn g_io_stream_get_output_stream(stream: *mut GIOStream)
     -> *mut GOutputStream;
    pub fn g_io_stream_splice_async(stream1: *mut GIOStream,
                                    stream2: *mut GIOStream,
                                    flags: GIOStreamSpliceFlags,
                                    io_priority: ::std::os::raw::c_int,
                                    cancellable: *mut GCancellable,
                                    callback: GAsyncReadyCallback,
                                    user_data: gpointer);
    pub fn g_io_stream_splice_finish(result: *mut GAsyncResult,
                                     error: *mut *mut GError) -> gboolean;
    pub fn g_io_stream_close(stream: *mut GIOStream,
                             cancellable: *mut GCancellable,
                             error: *mut *mut GError) -> gboolean;
    pub fn g_io_stream_close_async(stream: *mut GIOStream,
                                   io_priority: ::std::os::raw::c_int,
                                   cancellable: *mut GCancellable,
                                   callback: GAsyncReadyCallback,
                                   user_data: gpointer);
    pub fn g_io_stream_close_finish(stream: *mut GIOStream,
                                    result: *mut GAsyncResult,
                                    error: *mut *mut GError) -> gboolean;
    pub fn g_io_stream_is_closed(stream: *mut GIOStream) -> gboolean;
    pub fn g_io_stream_has_pending(stream: *mut GIOStream) -> gboolean;
    pub fn g_io_stream_set_pending(stream: *mut GIOStream,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_io_stream_clear_pending(stream: *mut GIOStream);
    pub fn g_file_io_stream_get_type() -> GType;
    pub fn g_file_io_stream_query_info(stream: *mut GFileIOStream,
                                       attributes:
                                           *const ::std::os::raw::c_char,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_file_io_stream_query_info_async(stream: *mut GFileIOStream,
                                             attributes:
                                                 *const ::std::os::raw::c_char,
                                             io_priority:
                                                 ::std::os::raw::c_int,
                                             cancellable: *mut GCancellable,
                                             callback: GAsyncReadyCallback,
                                             user_data: gpointer);
    pub fn g_file_io_stream_query_info_finish(stream: *mut GFileIOStream,
                                              result: *mut GAsyncResult,
                                              error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_file_io_stream_get_etag(stream: *mut GFileIOStream)
     -> *mut ::std::os::raw::c_char;
    pub fn g_file_monitor_get_type() -> GType;
    pub fn g_file_monitor_cancel(monitor: *mut GFileMonitor) -> gboolean;
    pub fn g_file_monitor_is_cancelled(monitor: *mut GFileMonitor)
     -> gboolean;
    pub fn g_file_monitor_set_rate_limit(monitor: *mut GFileMonitor,
                                         limit_msecs: gint);
    pub fn g_file_monitor_emit_event(monitor: *mut GFileMonitor,
                                     child: *mut GFile,
                                     other_file: *mut GFile,
                                     event_type: GFileMonitorEvent);
    pub fn g_filename_completer_get_type() -> GType;
    pub fn g_filename_completer_new() -> *mut GFilenameCompleter;
    pub fn g_filename_completer_get_completion_suffix(completer:
                                                          *mut GFilenameCompleter,
                                                      initial_text:
                                                          *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn g_filename_completer_get_completions(completer:
                                                    *mut GFilenameCompleter,
                                                initial_text:
                                                    *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn g_filename_completer_set_dirs_only(completer:
                                                  *mut GFilenameCompleter,
                                              dirs_only: gboolean);
    pub fn g_file_output_stream_get_type() -> GType;
    pub fn g_file_output_stream_query_info(stream: *mut GFileOutputStream,
                                           attributes:
                                               *const ::std::os::raw::c_char,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_file_output_stream_query_info_async(stream:
                                                     *mut GFileOutputStream,
                                                 attributes:
                                                     *const ::std::os::raw::c_char,
                                                 io_priority:
                                                     ::std::os::raw::c_int,
                                                 cancellable:
                                                     *mut GCancellable,
                                                 callback:
                                                     GAsyncReadyCallback,
                                                 user_data: gpointer);
    pub fn g_file_output_stream_query_info_finish(stream:
                                                      *mut GFileOutputStream,
                                                  result: *mut GAsyncResult,
                                                  error: *mut *mut GError)
     -> *mut GFileInfo;
    pub fn g_file_output_stream_get_etag(stream: *mut GFileOutputStream)
     -> *mut ::std::os::raw::c_char;
    pub fn g_inet_address_get_type() -> GType;
    pub fn g_inet_address_new_from_string(string: *const gchar)
     -> *mut GInetAddress;
    pub fn g_inet_address_new_from_bytes(bytes: *const guint8,
                                         family: GSocketFamily)
     -> *mut GInetAddress;
    pub fn g_inet_address_new_loopback(family: GSocketFamily)
     -> *mut GInetAddress;
    pub fn g_inet_address_new_any(family: GSocketFamily) -> *mut GInetAddress;
    pub fn g_inet_address_equal(address: *mut GInetAddress,
                                other_address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_to_string(address: *mut GInetAddress) -> *mut gchar;
    pub fn g_inet_address_to_bytes(address: *mut GInetAddress)
     -> *const guint8;
    pub fn g_inet_address_get_native_size(address: *mut GInetAddress)
     -> gsize;
    pub fn g_inet_address_get_family(address: *mut GInetAddress)
     -> GSocketFamily;
    pub fn g_inet_address_get_is_any(address: *mut GInetAddress) -> gboolean;
    pub fn g_inet_address_get_is_loopback(address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_get_is_link_local(address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_get_is_site_local(address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_get_is_multicast(address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_get_is_mc_global(address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_get_is_mc_link_local(address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_get_is_mc_node_local(address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_get_is_mc_org_local(address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_get_is_mc_site_local(address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_mask_get_type() -> GType;
    pub fn g_inet_address_mask_new(addr: *mut GInetAddress, length: guint,
                                   error: *mut *mut GError)
     -> *mut GInetAddressMask;
    pub fn g_inet_address_mask_new_from_string(mask_string: *const gchar,
                                               error: *mut *mut GError)
     -> *mut GInetAddressMask;
    pub fn g_inet_address_mask_to_string(mask: *mut GInetAddressMask)
     -> *mut gchar;
    pub fn g_inet_address_mask_get_family(mask: *mut GInetAddressMask)
     -> GSocketFamily;
    pub fn g_inet_address_mask_get_address(mask: *mut GInetAddressMask)
     -> *mut GInetAddress;
    pub fn g_inet_address_mask_get_length(mask: *mut GInetAddressMask)
     -> guint;
    pub fn g_inet_address_mask_matches(mask: *mut GInetAddressMask,
                                       address: *mut GInetAddress)
     -> gboolean;
    pub fn g_inet_address_mask_equal(mask: *mut GInetAddressMask,
                                     mask2: *mut GInetAddressMask)
     -> gboolean;
    pub fn g_socket_address_get_type() -> GType;
    pub fn g_socket_address_get_family(address: *mut GSocketAddress)
     -> GSocketFamily;
    pub fn g_socket_address_new_from_native(native: gpointer, len: gsize)
     -> *mut GSocketAddress;
    pub fn g_socket_address_to_native(address: *mut GSocketAddress,
                                      dest: gpointer, destlen: gsize,
                                      error: *mut *mut GError) -> gboolean;
    pub fn g_socket_address_get_native_size(address: *mut GSocketAddress)
     -> gssize;
    pub fn g_inet_socket_address_get_type() -> GType;
    pub fn g_inet_socket_address_new(address: *mut GInetAddress,
                                     port: guint16) -> *mut GSocketAddress;
    pub fn g_inet_socket_address_new_from_string(address:
                                                     *const ::std::os::raw::c_char,
                                                 port: guint)
     -> *mut GSocketAddress;
    pub fn g_inet_socket_address_get_address(address: *mut GInetSocketAddress)
     -> *mut GInetAddress;
    pub fn g_inet_socket_address_get_port(address: *mut GInetSocketAddress)
     -> guint16;
    pub fn g_inet_socket_address_get_flowinfo(address:
                                                  *mut GInetSocketAddress)
     -> guint32;
    pub fn g_inet_socket_address_get_scope_id(address:
                                                  *mut GInetSocketAddress)
     -> guint32;
    pub fn g_app_info_create_flags_get_type() -> GType;
    pub fn g_converter_flags_get_type() -> GType;
    pub fn g_converter_result_get_type() -> GType;
    pub fn g_data_stream_byte_order_get_type() -> GType;
    pub fn g_data_stream_newline_type_get_type() -> GType;
    pub fn g_file_attribute_type_get_type() -> GType;
    pub fn g_file_attribute_info_flags_get_type() -> GType;
    pub fn g_file_attribute_status_get_type() -> GType;
    pub fn g_file_query_info_flags_get_type() -> GType;
    pub fn g_file_create_flags_get_type() -> GType;
    pub fn g_file_measure_flags_get_type() -> GType;
    pub fn g_mount_mount_flags_get_type() -> GType;
    pub fn g_mount_unmount_flags_get_type() -> GType;
    pub fn g_drive_start_flags_get_type() -> GType;
    pub fn g_drive_start_stop_type_get_type() -> GType;
    pub fn g_file_copy_flags_get_type() -> GType;
    pub fn g_file_monitor_flags_get_type() -> GType;
    pub fn g_file_type_get_type() -> GType;
    pub fn g_filesystem_preview_type_get_type() -> GType;
    pub fn g_file_monitor_event_get_type() -> GType;
    pub fn g_io_error_enum_get_type() -> GType;
    pub fn g_ask_password_flags_get_type() -> GType;
    pub fn g_password_save_get_type() -> GType;
    pub fn g_mount_operation_result_get_type() -> GType;
    pub fn g_output_stream_splice_flags_get_type() -> GType;
    pub fn g_io_stream_splice_flags_get_type() -> GType;
    pub fn g_emblem_origin_get_type() -> GType;
    pub fn g_resolver_error_get_type() -> GType;
    pub fn g_resolver_record_type_get_type() -> GType;
    pub fn g_resource_error_get_type() -> GType;
    pub fn g_resource_flags_get_type() -> GType;
    pub fn g_resource_lookup_flags_get_type() -> GType;
    pub fn g_socket_family_get_type() -> GType;
    pub fn g_socket_type_get_type() -> GType;
    pub fn g_socket_msg_flags_get_type() -> GType;
    pub fn g_socket_protocol_get_type() -> GType;
    pub fn g_zlib_compressor_format_get_type() -> GType;
    pub fn g_unix_socket_address_type_get_type() -> GType;
    pub fn g_bus_type_get_type() -> GType;
    pub fn g_bus_name_owner_flags_get_type() -> GType;
    pub fn g_bus_name_watcher_flags_get_type() -> GType;
    pub fn g_dbus_proxy_flags_get_type() -> GType;
    pub fn g_dbus_error_get_type() -> GType;
    pub fn g_dbus_connection_flags_get_type() -> GType;
    pub fn g_dbus_capability_flags_get_type() -> GType;
    pub fn g_dbus_call_flags_get_type() -> GType;
    pub fn g_dbus_message_type_get_type() -> GType;
    pub fn g_dbus_message_flags_get_type() -> GType;
    pub fn g_dbus_message_header_field_get_type() -> GType;
    pub fn g_dbus_property_info_flags_get_type() -> GType;
    pub fn g_dbus_subtree_flags_get_type() -> GType;
    pub fn g_dbus_server_flags_get_type() -> GType;
    pub fn g_dbus_signal_flags_get_type() -> GType;
    pub fn g_dbus_send_message_flags_get_type() -> GType;
    pub fn g_credentials_type_get_type() -> GType;
    pub fn g_dbus_message_byte_order_get_type() -> GType;
    pub fn g_application_flags_get_type() -> GType;
    pub fn g_tls_error_get_type() -> GType;
    pub fn g_tls_certificate_flags_get_type() -> GType;
    pub fn g_tls_authentication_mode_get_type() -> GType;
    pub fn g_tls_rehandshake_mode_get_type() -> GType;
    pub fn g_tls_password_flags_get_type() -> GType;
    pub fn g_tls_interaction_result_get_type() -> GType;
    pub fn g_dbus_interface_skeleton_flags_get_type() -> GType;
    pub fn g_dbus_object_manager_client_flags_get_type() -> GType;
    pub fn g_tls_database_verify_flags_get_type() -> GType;
    pub fn g_tls_database_lookup_flags_get_type() -> GType;
    pub fn g_tls_certificate_request_flags_get_type() -> GType;
    pub fn g_io_module_scope_flags_get_type() -> GType;
    pub fn g_socket_client_event_get_type() -> GType;
    pub fn g_socket_listener_event_get_type() -> GType;
    pub fn g_test_dbus_flags_get_type() -> GType;
    pub fn g_subprocess_flags_get_type() -> GType;
    pub fn g_notification_priority_get_type() -> GType;
    pub fn g_network_connectivity_get_type() -> GType;
    pub fn g_settings_bind_flags_get_type() -> GType;
    pub fn g_module_supported() -> gboolean;
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags)
     -> *mut GModule;
    pub fn g_module_close(module: *mut GModule) -> gboolean;
    pub fn g_module_make_resident(module: *mut GModule);
    pub fn g_module_error() -> *const gchar;
    pub fn g_module_symbol(module: *mut GModule, symbol_name: *const gchar,
                           symbol: *mut gpointer) -> gboolean;
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
    pub fn g_module_build_path(directory: *const gchar,
                               module_name: *const gchar) -> *mut gchar;
    pub fn g_io_module_scope_new(flags: GIOModuleScopeFlags)
     -> *mut GIOModuleScope;
    pub fn g_io_module_scope_free(scope: *mut GIOModuleScope);
    pub fn g_io_module_scope_block(scope: *mut GIOModuleScope,
                                   basename: *const gchar);
    pub fn g_io_module_get_type() -> GType;
    pub fn g_io_module_new(filename: *const gchar) -> *mut GIOModule;
    pub fn g_io_modules_scan_all_in_directory(dirname:
                                                  *const ::std::os::raw::c_char);
    pub fn g_io_modules_load_all_in_directory(dirname: *const gchar)
     -> *mut GList;
    pub fn g_io_modules_scan_all_in_directory_with_scope(dirname:
                                                             *const gchar,
                                                         scope:
                                                             *mut GIOModuleScope);
    pub fn g_io_modules_load_all_in_directory_with_scope(dirname:
                                                             *const gchar,
                                                         scope:
                                                             *mut GIOModuleScope)
     -> *mut GList;
    pub fn g_io_extension_point_register(name: *const ::std::os::raw::c_char)
     -> *mut GIOExtensionPoint;
    pub fn g_io_extension_point_lookup(name: *const ::std::os::raw::c_char)
     -> *mut GIOExtensionPoint;
    pub fn g_io_extension_point_set_required_type(extension_point:
                                                      *mut GIOExtensionPoint,
                                                  _type: GType);
    pub fn g_io_extension_point_get_required_type(extension_point:
                                                      *mut GIOExtensionPoint)
     -> GType;
    pub fn g_io_extension_point_get_extensions(extension_point:
                                                   *mut GIOExtensionPoint)
     -> *mut GList;
    pub fn g_io_extension_point_get_extension_by_name(extension_point:
                                                          *mut GIOExtensionPoint,
                                                      name:
                                                          *const ::std::os::raw::c_char)
     -> *mut GIOExtension;
    pub fn g_io_extension_point_implement(extension_point_name:
                                              *const ::std::os::raw::c_char,
                                          _type: GType,
                                          extension_name:
                                              *const ::std::os::raw::c_char,
                                          priority: gint)
     -> *mut GIOExtension;
    pub fn g_io_extension_get_type(extension: *mut GIOExtension) -> GType;
    pub fn g_io_extension_get_name(extension: *mut GIOExtension)
     -> *const ::std::os::raw::c_char;
    pub fn g_io_extension_get_priority(extension: *mut GIOExtension) -> gint;
    pub fn g_io_extension_ref_class(extension: *mut GIOExtension)
     -> *mut GTypeClass;
    pub fn g_io_module_load(module: *mut GIOModule);
    pub fn g_io_module_unload(module: *mut GIOModule);
    pub fn g_io_module_query() -> *mut *mut ::std::os::raw::c_char;
    pub fn g_io_scheduler_push_job(job_func: GIOSchedulerJobFunc,
                                   user_data: gpointer,
                                   notify: GDestroyNotify, io_priority: gint,
                                   cancellable: *mut GCancellable);
    pub fn g_io_scheduler_cancel_all_jobs();
    pub fn g_io_scheduler_job_send_to_mainloop(job: *mut GIOSchedulerJob,
                                               func: GSourceFunc,
                                               user_data: gpointer,
                                               notify: GDestroyNotify)
     -> gboolean;
    pub fn g_io_scheduler_job_send_to_mainloop_async(job:
                                                         *mut GIOSchedulerJob,
                                                     func: GSourceFunc,
                                                     user_data: gpointer,
                                                     notify: GDestroyNotify);
    pub fn g_loadable_icon_get_type() -> GType;
    pub fn g_loadable_icon_load(icon: *mut GLoadableIcon,
                                size: ::std::os::raw::c_int,
                                _type: *mut *mut ::std::os::raw::c_char,
                                cancellable: *mut GCancellable,
                                error: *mut *mut GError) -> *mut GInputStream;
    pub fn g_loadable_icon_load_async(icon: *mut GLoadableIcon,
                                      size: ::std::os::raw::c_int,
                                      cancellable: *mut GCancellable,
                                      callback: GAsyncReadyCallback,
                                      user_data: gpointer);
    pub fn g_loadable_icon_load_finish(icon: *mut GLoadableIcon,
                                       res: *mut GAsyncResult,
                                       _type:
                                           *mut *mut ::std::os::raw::c_char,
                                       error: *mut *mut GError)
     -> *mut GInputStream;
    pub fn g_memory_input_stream_get_type() -> GType;
    pub fn g_memory_input_stream_new() -> *mut GInputStream;
    pub fn g_memory_input_stream_new_from_data(data:
                                                   *const ::std::os::raw::c_void,
                                               len: gssize,
                                               destroy: GDestroyNotify)
     -> *mut GInputStream;
    pub fn g_memory_input_stream_new_from_bytes(bytes: *mut GBytes)
     -> *mut GInputStream;
    pub fn g_memory_input_stream_add_data(stream: *mut GMemoryInputStream,
                                          data: *const ::std::os::raw::c_void,
                                          len: gssize,
                                          destroy: GDestroyNotify);
    pub fn g_memory_input_stream_add_bytes(stream: *mut GMemoryInputStream,
                                           bytes: *mut GBytes);
    pub fn g_memory_output_stream_get_type() -> GType;
    pub fn g_memory_output_stream_new(data: gpointer, size: gsize,
                                      realloc_function: GReallocFunc,
                                      destroy_function: GDestroyNotify)
     -> *mut GOutputStream;
    pub fn g_memory_output_stream_new_resizable() -> *mut GOutputStream;
    pub fn g_memory_output_stream_get_data(ostream: *mut GMemoryOutputStream)
     -> gpointer;
    pub fn g_memory_output_stream_get_size(ostream: *mut GMemoryOutputStream)
     -> gsize;
    pub fn g_memory_output_stream_get_data_size(ostream:
                                                    *mut GMemoryOutputStream)
     -> gsize;
    pub fn g_memory_output_stream_steal_data(ostream:
                                                 *mut GMemoryOutputStream)
     -> gpointer;
    pub fn g_memory_output_stream_steal_as_bytes(ostream:
                                                     *mut GMemoryOutputStream)
     -> *mut GBytes;
    pub fn g_mount_get_type() -> GType;
    pub fn g_mount_get_root(mount: *mut GMount) -> *mut GFile;
    pub fn g_mount_get_default_location(mount: *mut GMount) -> *mut GFile;
    pub fn g_mount_get_name(mount: *mut GMount)
     -> *mut ::std::os::raw::c_char;
    pub fn g_mount_get_icon(mount: *mut GMount) -> *mut GIcon;
    pub fn g_mount_get_symbolic_icon(mount: *mut GMount) -> *mut GIcon;
    pub fn g_mount_get_uuid(mount: *mut GMount)
     -> *mut ::std::os::raw::c_char;
    pub fn g_mount_get_volume(mount: *mut GMount) -> *mut GVolume;
    pub fn g_mount_get_drive(mount: *mut GMount) -> *mut GDrive;
    pub fn g_mount_can_unmount(mount: *mut GMount) -> gboolean;
    pub fn g_mount_can_eject(mount: *mut GMount) -> gboolean;
    pub fn g_mount_unmount(mount: *mut GMount, flags: GMountUnmountFlags,
                           cancellable: *mut GCancellable,
                           callback: GAsyncReadyCallback,
                           user_data: gpointer);
    pub fn g_mount_unmount_finish(mount: *mut GMount,
                                  result: *mut GAsyncResult,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_mount_eject(mount: *mut GMount, flags: GMountUnmountFlags,
                         cancellable: *mut GCancellable,
                         callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_mount_eject_finish(mount: *mut GMount, result: *mut GAsyncResult,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_mount_remount(mount: *mut GMount, flags: GMountMountFlags,
                           mount_operation: *mut GMountOperation,
                           cancellable: *mut GCancellable,
                           callback: GAsyncReadyCallback,
                           user_data: gpointer);
    pub fn g_mount_remount_finish(mount: *mut GMount,
                                  result: *mut GAsyncResult,
                                  error: *mut *mut GError) -> gboolean;
    pub fn g_mount_guess_content_type(mount: *mut GMount,
                                      force_rescan: gboolean,
                                      cancellable: *mut GCancellable,
                                      callback: GAsyncReadyCallback,
                                      user_data: gpointer);
    pub fn g_mount_guess_content_type_finish(mount: *mut GMount,
                                             result: *mut GAsyncResult,
                                             error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_mount_guess_content_type_sync(mount: *mut GMount,
                                           force_rescan: gboolean,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_mount_is_shadowed(mount: *mut GMount) -> gboolean;
    pub fn g_mount_shadow(mount: *mut GMount);
    pub fn g_mount_unshadow(mount: *mut GMount);
    pub fn g_mount_unmount_with_operation(mount: *mut GMount,
                                          flags: GMountUnmountFlags,
                                          mount_operation:
                                              *mut GMountOperation,
                                          cancellable: *mut GCancellable,
                                          callback: GAsyncReadyCallback,
                                          user_data: gpointer);
    pub fn g_mount_unmount_with_operation_finish(mount: *mut GMount,
                                                 result: *mut GAsyncResult,
                                                 error: *mut *mut GError)
     -> gboolean;
    pub fn g_mount_eject_with_operation(mount: *mut GMount,
                                        flags: GMountUnmountFlags,
                                        mount_operation: *mut GMountOperation,
                                        cancellable: *mut GCancellable,
                                        callback: GAsyncReadyCallback,
                                        user_data: gpointer);
    pub fn g_mount_eject_with_operation_finish(mount: *mut GMount,
                                               result: *mut GAsyncResult,
                                               error: *mut *mut GError)
     -> gboolean;
    pub fn g_mount_get_sort_key(mount: *mut GMount) -> *const gchar;
    pub fn g_mount_operation_get_type() -> GType;
    pub fn g_mount_operation_new() -> *mut GMountOperation;
    pub fn g_mount_operation_get_username(op: *mut GMountOperation)
     -> *const ::std::os::raw::c_char;
    pub fn g_mount_operation_set_username(op: *mut GMountOperation,
                                          username:
                                              *const ::std::os::raw::c_char);
    pub fn g_mount_operation_get_password(op: *mut GMountOperation)
     -> *const ::std::os::raw::c_char;
    pub fn g_mount_operation_set_password(op: *mut GMountOperation,
                                          password:
                                              *const ::std::os::raw::c_char);
    pub fn g_mount_operation_get_anonymous(op: *mut GMountOperation)
     -> gboolean;
    pub fn g_mount_operation_set_anonymous(op: *mut GMountOperation,
                                           anonymous: gboolean);
    pub fn g_mount_operation_get_domain(op: *mut GMountOperation)
     -> *const ::std::os::raw::c_char;
    pub fn g_mount_operation_set_domain(op: *mut GMountOperation,
                                        domain:
                                            *const ::std::os::raw::c_char);
    pub fn g_mount_operation_get_password_save(op: *mut GMountOperation)
     -> GPasswordSave;
    pub fn g_mount_operation_set_password_save(op: *mut GMountOperation,
                                               save: GPasswordSave);
    pub fn g_mount_operation_get_choice(op: *mut GMountOperation)
     -> ::std::os::raw::c_int;
    pub fn g_mount_operation_set_choice(op: *mut GMountOperation,
                                        choice: ::std::os::raw::c_int);
    pub fn g_mount_operation_reply(op: *mut GMountOperation,
                                   result: GMountOperationResult);
    pub fn g_volume_monitor_get_type() -> GType;
    pub fn g_volume_monitor_get() -> *mut GVolumeMonitor;
    pub fn g_volume_monitor_get_connected_drives(volume_monitor:
                                                     *mut GVolumeMonitor)
     -> *mut GList;
    pub fn g_volume_monitor_get_volumes(volume_monitor: *mut GVolumeMonitor)
     -> *mut GList;
    pub fn g_volume_monitor_get_mounts(volume_monitor: *mut GVolumeMonitor)
     -> *mut GList;
    pub fn g_volume_monitor_get_volume_for_uuid(volume_monitor:
                                                    *mut GVolumeMonitor,
                                                uuid:
                                                    *const ::std::os::raw::c_char)
     -> *mut GVolume;
    pub fn g_volume_monitor_get_mount_for_uuid(volume_monitor:
                                                   *mut GVolumeMonitor,
                                               uuid:
                                                   *const ::std::os::raw::c_char)
     -> *mut GMount;
    pub fn g_volume_monitor_adopt_orphan_mount(mount: *mut GMount)
     -> *mut GVolume;
    pub fn g_native_volume_monitor_get_type() -> GType;
    pub fn g_network_address_get_type() -> GType;
    pub fn g_network_address_new(hostname: *const gchar, port: guint16)
     -> *mut GSocketConnectable;
    pub fn g_network_address_new_loopback(port: guint16)
     -> *mut GSocketConnectable;
    pub fn g_network_address_parse(host_and_port: *const gchar,
                                   default_port: guint16,
                                   error: *mut *mut GError)
     -> *mut GSocketConnectable;
    pub fn g_network_address_parse_uri(uri: *const gchar,
                                       default_port: guint16,
                                       error: *mut *mut GError)
     -> *mut GSocketConnectable;
    pub fn g_network_address_get_hostname(addr: *mut GNetworkAddress)
     -> *const gchar;
    pub fn g_network_address_get_port(addr: *mut GNetworkAddress) -> guint16;
    pub fn g_network_address_get_scheme(addr: *mut GNetworkAddress)
     -> *const gchar;
    pub fn g_network_monitor_get_type() -> GType;
    pub fn g_network_monitor_get_default() -> *mut GNetworkMonitor;
    pub fn g_network_monitor_get_network_available(monitor:
                                                       *mut GNetworkMonitor)
     -> gboolean;
    pub fn g_network_monitor_get_network_metered(monitor:
                                                     *mut GNetworkMonitor)
     -> gboolean;
    pub fn g_network_monitor_get_connectivity(monitor: *mut GNetworkMonitor)
     -> GNetworkConnectivity;
    pub fn g_network_monitor_can_reach(monitor: *mut GNetworkMonitor,
                                       connectable: *mut GSocketConnectable,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_network_monitor_can_reach_async(monitor: *mut GNetworkMonitor,
                                             connectable:
                                                 *mut GSocketConnectable,
                                             cancellable: *mut GCancellable,
                                             callback: GAsyncReadyCallback,
                                             user_data: gpointer);
    pub fn g_network_monitor_can_reach_finish(monitor: *mut GNetworkMonitor,
                                              result: *mut GAsyncResult,
                                              error: *mut *mut GError)
     -> gboolean;
    pub fn g_network_service_get_type() -> GType;
    pub fn g_network_service_new(service: *const gchar,
                                 protocol: *const gchar, domain: *const gchar)
     -> *mut GSocketConnectable;
    pub fn g_network_service_get_service(srv: *mut GNetworkService)
     -> *const gchar;
    pub fn g_network_service_get_protocol(srv: *mut GNetworkService)
     -> *const gchar;
    pub fn g_network_service_get_domain(srv: *mut GNetworkService)
     -> *const gchar;
    pub fn g_network_service_get_scheme(srv: *mut GNetworkService)
     -> *const gchar;
    pub fn g_network_service_set_scheme(srv: *mut GNetworkService,
                                        scheme: *const gchar);
    pub fn g_permission_get_type() -> GType;
    pub fn g_permission_acquire(permission: *mut GPermission,
                                cancellable: *mut GCancellable,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_permission_acquire_async(permission: *mut GPermission,
                                      cancellable: *mut GCancellable,
                                      callback: GAsyncReadyCallback,
                                      user_data: gpointer);
    pub fn g_permission_acquire_finish(permission: *mut GPermission,
                                       result: *mut GAsyncResult,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_permission_release(permission: *mut GPermission,
                                cancellable: *mut GCancellable,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_permission_release_async(permission: *mut GPermission,
                                      cancellable: *mut GCancellable,
                                      callback: GAsyncReadyCallback,
                                      user_data: gpointer);
    pub fn g_permission_release_finish(permission: *mut GPermission,
                                       result: *mut GAsyncResult,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_permission_get_allowed(permission: *mut GPermission) -> gboolean;
    pub fn g_permission_get_can_acquire(permission: *mut GPermission)
     -> gboolean;
    pub fn g_permission_get_can_release(permission: *mut GPermission)
     -> gboolean;
    pub fn g_permission_impl_update(permission: *mut GPermission,
                                    allowed: gboolean, can_acquire: gboolean,
                                    can_release: gboolean);
    pub fn g_pollable_input_stream_get_type() -> GType;
    pub fn g_pollable_input_stream_can_poll(stream: *mut GPollableInputStream)
     -> gboolean;
    pub fn g_pollable_input_stream_is_readable(stream:
                                                   *mut GPollableInputStream)
     -> gboolean;
    pub fn g_pollable_input_stream_create_source(stream:
                                                     *mut GPollableInputStream,
                                                 cancellable:
                                                     *mut GCancellable)
     -> *mut GSource;
    pub fn g_pollable_input_stream_read_nonblocking(stream:
                                                        *mut GPollableInputStream,
                                                    buffer:
                                                        *mut ::std::os::raw::c_void,
                                                    count: gsize,
                                                    cancellable:
                                                        *mut GCancellable,
                                                    error: *mut *mut GError)
     -> gssize;
    pub fn g_pollable_output_stream_get_type() -> GType;
    pub fn g_pollable_output_stream_can_poll(stream:
                                                 *mut GPollableOutputStream)
     -> gboolean;
    pub fn g_pollable_output_stream_is_writable(stream:
                                                    *mut GPollableOutputStream)
     -> gboolean;
    pub fn g_pollable_output_stream_create_source(stream:
                                                      *mut GPollableOutputStream,
                                                  cancellable:
                                                      *mut GCancellable)
     -> *mut GSource;
    pub fn g_pollable_output_stream_write_nonblocking(stream:
                                                          *mut GPollableOutputStream,
                                                      buffer:
                                                          *const ::std::os::raw::c_void,
                                                      count: gsize,
                                                      cancellable:
                                                          *mut GCancellable,
                                                      error: *mut *mut GError)
     -> gssize;
    pub fn g_pollable_source_new(pollable_stream: *mut GObject)
     -> *mut GSource;
    pub fn g_pollable_source_new_full(pollable_stream: gpointer,
                                      child_source: *mut GSource,
                                      cancellable: *mut GCancellable)
     -> *mut GSource;
    pub fn g_pollable_stream_read(stream: *mut GInputStream,
                                  buffer: *mut ::std::os::raw::c_void,
                                  count: gsize, blocking: gboolean,
                                  cancellable: *mut GCancellable,
                                  error: *mut *mut GError) -> gssize;
    pub fn g_pollable_stream_write(stream: *mut GOutputStream,
                                   buffer: *const ::std::os::raw::c_void,
                                   count: gsize, blocking: gboolean,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError) -> gssize;
    pub fn g_pollable_stream_write_all(stream: *mut GOutputStream,
                                       buffer: *const ::std::os::raw::c_void,
                                       count: gsize, blocking: gboolean,
                                       bytes_written: *mut gsize,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_property_action_get_type() -> GType;
    pub fn g_property_action_new(name: *const gchar, object: gpointer,
                                 property_name: *const gchar)
     -> *mut GPropertyAction;
    pub fn g_proxy_get_type() -> GType;
    pub fn g_proxy_get_default_for_protocol(protocol: *const gchar)
     -> *mut GProxy;
    pub fn g_proxy_connect(proxy: *mut GProxy, connection: *mut GIOStream,
                           proxy_address: *mut GProxyAddress,
                           cancellable: *mut GCancellable,
                           error: *mut *mut GError) -> *mut GIOStream;
    pub fn g_proxy_connect_async(proxy: *mut GProxy,
                                 connection: *mut GIOStream,
                                 proxy_address: *mut GProxyAddress,
                                 cancellable: *mut GCancellable,
                                 callback: GAsyncReadyCallback,
                                 user_data: gpointer);
    pub fn g_proxy_connect_finish(proxy: *mut GProxy,
                                  result: *mut GAsyncResult,
                                  error: *mut *mut GError) -> *mut GIOStream;
    pub fn g_proxy_supports_hostname(proxy: *mut GProxy) -> gboolean;
    pub fn g_proxy_address_get_type() -> GType;
    pub fn g_proxy_address_new(inetaddr: *mut GInetAddress, port: guint16,
                               protocol: *const gchar,
                               dest_hostname: *const gchar,
                               dest_port: guint16, username: *const gchar,
                               password: *const gchar) -> *mut GSocketAddress;
    pub fn g_proxy_address_get_protocol(proxy: *mut GProxyAddress)
     -> *const gchar;
    pub fn g_proxy_address_get_destination_protocol(proxy: *mut GProxyAddress)
     -> *const gchar;
    pub fn g_proxy_address_get_destination_hostname(proxy: *mut GProxyAddress)
     -> *const gchar;
    pub fn g_proxy_address_get_destination_port(proxy: *mut GProxyAddress)
     -> guint16;
    pub fn g_proxy_address_get_username(proxy: *mut GProxyAddress)
     -> *const gchar;
    pub fn g_proxy_address_get_password(proxy: *mut GProxyAddress)
     -> *const gchar;
    pub fn g_proxy_address_get_uri(proxy: *mut GProxyAddress) -> *const gchar;
    pub fn g_socket_address_enumerator_get_type() -> GType;
    pub fn g_socket_address_enumerator_next(enumerator:
                                                *mut GSocketAddressEnumerator,
                                            cancellable: *mut GCancellable,
                                            error: *mut *mut GError)
     -> *mut GSocketAddress;
    pub fn g_socket_address_enumerator_next_async(enumerator:
                                                      *mut GSocketAddressEnumerator,
                                                  cancellable:
                                                      *mut GCancellable,
                                                  callback:
                                                      GAsyncReadyCallback,
                                                  user_data: gpointer);
    pub fn g_socket_address_enumerator_next_finish(enumerator:
                                                       *mut GSocketAddressEnumerator,
                                                   result: *mut GAsyncResult,
                                                   error: *mut *mut GError)
     -> *mut GSocketAddress;
    pub fn g_proxy_address_enumerator_get_type() -> GType;
    pub fn g_proxy_resolver_get_type() -> GType;
    pub fn g_proxy_resolver_get_default() -> *mut GProxyResolver;
    pub fn g_proxy_resolver_is_supported(resolver: *mut GProxyResolver)
     -> gboolean;
    pub fn g_proxy_resolver_lookup(resolver: *mut GProxyResolver,
                                   uri: *const gchar,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_proxy_resolver_lookup_async(resolver: *mut GProxyResolver,
                                         uri: *const gchar,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_proxy_resolver_lookup_finish(resolver: *mut GProxyResolver,
                                          result: *mut GAsyncResult,
                                          error: *mut *mut GError)
     -> *mut *mut gchar;
    pub fn g_resolver_get_type() -> GType;
    pub fn g_resolver_get_default() -> *mut GResolver;
    pub fn g_resolver_set_default(resolver: *mut GResolver);
    pub fn g_resolver_lookup_by_name(resolver: *mut GResolver,
                                     hostname: *const gchar,
                                     cancellable: *mut GCancellable,
                                     error: *mut *mut GError) -> *mut GList;
    pub fn g_resolver_lookup_by_name_async(resolver: *mut GResolver,
                                           hostname: *const gchar,
                                           cancellable: *mut GCancellable,
                                           callback: GAsyncReadyCallback,
                                           user_data: gpointer);
    pub fn g_resolver_lookup_by_name_finish(resolver: *mut GResolver,
                                            result: *mut GAsyncResult,
                                            error: *mut *mut GError)
     -> *mut GList;
    pub fn g_resolver_free_addresses(addresses: *mut GList);
    pub fn g_resolver_lookup_by_address(resolver: *mut GResolver,
                                        address: *mut GInetAddress,
                                        cancellable: *mut GCancellable,
                                        error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_resolver_lookup_by_address_async(resolver: *mut GResolver,
                                              address: *mut GInetAddress,
                                              cancellable: *mut GCancellable,
                                              callback: GAsyncReadyCallback,
                                              user_data: gpointer);
    pub fn g_resolver_lookup_by_address_finish(resolver: *mut GResolver,
                                               result: *mut GAsyncResult,
                                               error: *mut *mut GError)
     -> *mut gchar;
    pub fn g_resolver_lookup_service(resolver: *mut GResolver,
                                     service: *const gchar,
                                     protocol: *const gchar,
                                     domain: *const gchar,
                                     cancellable: *mut GCancellable,
                                     error: *mut *mut GError) -> *mut GList;
    pub fn g_resolver_lookup_service_async(resolver: *mut GResolver,
                                           service: *const gchar,
                                           protocol: *const gchar,
                                           domain: *const gchar,
                                           cancellable: *mut GCancellable,
                                           callback: GAsyncReadyCallback,
                                           user_data: gpointer);
    pub fn g_resolver_lookup_service_finish(resolver: *mut GResolver,
                                            result: *mut GAsyncResult,
                                            error: *mut *mut GError)
     -> *mut GList;
    pub fn g_resolver_lookup_records(resolver: *mut GResolver,
                                     rrname: *const gchar,
                                     record_type: GResolverRecordType,
                                     cancellable: *mut GCancellable,
                                     error: *mut *mut GError) -> *mut GList;
    pub fn g_resolver_lookup_records_async(resolver: *mut GResolver,
                                           rrname: *const gchar,
                                           record_type: GResolverRecordType,
                                           cancellable: *mut GCancellable,
                                           callback: GAsyncReadyCallback,
                                           user_data: gpointer);
    pub fn g_resolver_lookup_records_finish(resolver: *mut GResolver,
                                            result: *mut GAsyncResult,
                                            error: *mut *mut GError)
     -> *mut GList;
    pub fn g_resolver_free_targets(targets: *mut GList);
    pub fn g_resolver_error_quark() -> GQuark;
    pub fn g_resource_error_quark() -> GQuark;
    pub fn g_resource_get_type() -> GType;
    pub fn g_resource_new_from_data(data: *mut GBytes,
                                    error: *mut *mut GError)
     -> *mut GResource;
    pub fn g_resource_ref(resource: *mut GResource) -> *mut GResource;
    pub fn g_resource_unref(resource: *mut GResource);
    pub fn g_resource_load(filename: *const gchar, error: *mut *mut GError)
     -> *mut GResource;
    pub fn g_resource_open_stream(resource: *mut GResource,
                                  path: *const ::std::os::raw::c_char,
                                  lookup_flags: GResourceLookupFlags,
                                  error: *mut *mut GError)
     -> *mut GInputStream;
    pub fn g_resource_lookup_data(resource: *mut GResource,
                                  path: *const ::std::os::raw::c_char,
                                  lookup_flags: GResourceLookupFlags,
                                  error: *mut *mut GError) -> *mut GBytes;
    pub fn g_resource_enumerate_children(resource: *mut GResource,
                                         path: *const ::std::os::raw::c_char,
                                         lookup_flags: GResourceLookupFlags,
                                         error: *mut *mut GError)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn g_resource_get_info(resource: *mut GResource,
                               path: *const ::std::os::raw::c_char,
                               lookup_flags: GResourceLookupFlags,
                               size: *mut gsize, flags: *mut guint32,
                               error: *mut *mut GError) -> gboolean;
    pub fn g_resources_register(resource: *mut GResource);
    pub fn g_resources_unregister(resource: *mut GResource);
    pub fn g_resources_open_stream(path: *const ::std::os::raw::c_char,
                                   lookup_flags: GResourceLookupFlags,
                                   error: *mut *mut GError)
     -> *mut GInputStream;
    pub fn g_resources_lookup_data(path: *const ::std::os::raw::c_char,
                                   lookup_flags: GResourceLookupFlags,
                                   error: *mut *mut GError) -> *mut GBytes;
    pub fn g_resources_enumerate_children(path: *const ::std::os::raw::c_char,
                                          lookup_flags: GResourceLookupFlags,
                                          error: *mut *mut GError)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn g_resources_get_info(path: *const ::std::os::raw::c_char,
                                lookup_flags: GResourceLookupFlags,
                                size: *mut gsize, flags: *mut guint32,
                                error: *mut *mut GError) -> gboolean;
    pub fn g_static_resource_init(static_resource: *mut GStaticResource);
    pub fn g_static_resource_fini(static_resource: *mut GStaticResource);
    pub fn g_static_resource_get_resource(static_resource:
                                              *mut GStaticResource)
     -> *mut GResource;
    pub fn g_seekable_get_type() -> GType;
    pub fn g_seekable_tell(seekable: *mut GSeekable) -> goffset;
    pub fn g_seekable_can_seek(seekable: *mut GSeekable) -> gboolean;
    pub fn g_seekable_seek(seekable: *mut GSeekable, offset: goffset,
                           _type: GSeekType, cancellable: *mut GCancellable,
                           error: *mut *mut GError) -> gboolean;
    pub fn g_seekable_can_truncate(seekable: *mut GSeekable) -> gboolean;
    pub fn g_seekable_truncate(seekable: *mut GSeekable, offset: goffset,
                               cancellable: *mut GCancellable,
                               error: *mut *mut GError) -> gboolean;
    pub fn g_settings_schema_source_get_type() -> GType;
    pub fn g_settings_schema_source_get_default()
     -> *mut GSettingsSchemaSource;
    pub fn g_settings_schema_source_ref(source: *mut GSettingsSchemaSource)
     -> *mut GSettingsSchemaSource;
    pub fn g_settings_schema_source_unref(source: *mut GSettingsSchemaSource);
    pub fn g_settings_schema_source_new_from_directory(directory:
                                                           *const gchar,
                                                       parent:
                                                           *mut GSettingsSchemaSource,
                                                       trusted: gboolean,
                                                       error:
                                                           *mut *mut GError)
     -> *mut GSettingsSchemaSource;
    pub fn g_settings_schema_source_lookup(source: *mut GSettingsSchemaSource,
                                           schema_id: *const gchar,
                                           recursive: gboolean)
     -> *mut GSettingsSchema;
    pub fn g_settings_schema_source_list_schemas(source:
                                                     *mut GSettingsSchemaSource,
                                                 recursive: gboolean,
                                                 non_relocatable:
                                                     *mut *mut *mut gchar,
                                                 relocatable:
                                                     *mut *mut *mut gchar);
    pub fn g_settings_schema_get_type() -> GType;
    pub fn g_settings_schema_ref(schema: *mut GSettingsSchema)
     -> *mut GSettingsSchema;
    pub fn g_settings_schema_unref(schema: *mut GSettingsSchema);
    pub fn g_settings_schema_get_id(schema: *mut GSettingsSchema)
     -> *const gchar;
    pub fn g_settings_schema_get_path(schema: *mut GSettingsSchema)
     -> *const gchar;
    pub fn g_settings_schema_get_key(schema: *mut GSettingsSchema,
                                     name: *const gchar)
     -> *mut GSettingsSchemaKey;
    pub fn g_settings_schema_has_key(schema: *mut GSettingsSchema,
                                     name: *const gchar) -> gboolean;
    pub fn g_settings_schema_list_keys(schema: *mut GSettingsSchema)
     -> *mut *mut gchar;
    pub fn g_settings_schema_list_children(schema: *mut GSettingsSchema)
     -> *mut *mut gchar;
    pub fn g_settings_schema_key_get_type() -> GType;
    pub fn g_settings_schema_key_ref(key: *mut GSettingsSchemaKey)
     -> *mut GSettingsSchemaKey;
    pub fn g_settings_schema_key_unref(key: *mut GSettingsSchemaKey);
    pub fn g_settings_schema_key_get_value_type(key: *mut GSettingsSchemaKey)
     -> *const GVariantType;
    pub fn g_settings_schema_key_get_default_value(key:
                                                       *mut GSettingsSchemaKey)
     -> *mut GVariant;
    pub fn g_settings_schema_key_get_range(key: *mut GSettingsSchemaKey)
     -> *mut GVariant;
    pub fn g_settings_schema_key_range_check(key: *mut GSettingsSchemaKey,
                                             value: *mut GVariant)
     -> gboolean;
    pub fn g_settings_schema_key_get_name(key: *mut GSettingsSchemaKey)
     -> *const gchar;
    pub fn g_settings_schema_key_get_summary(key: *mut GSettingsSchemaKey)
     -> *const gchar;
    pub fn g_settings_schema_key_get_description(key: *mut GSettingsSchemaKey)
     -> *const gchar;
    pub fn g_settings_get_type() -> GType;
    pub fn g_settings_list_schemas() -> *const *const gchar;
    pub fn g_settings_list_relocatable_schemas() -> *const *const gchar;
    pub fn g_settings_new(schema_id: *const gchar) -> *mut GSettings;
    pub fn g_settings_new_with_path(schema_id: *const gchar,
                                    path: *const gchar) -> *mut GSettings;
    pub fn g_settings_new_with_backend(schema_id: *const gchar,
                                       backend: *mut GSettingsBackend)
     -> *mut GSettings;
    pub fn g_settings_new_with_backend_and_path(schema_id: *const gchar,
                                                backend:
                                                    *mut GSettingsBackend,
                                                path: *const gchar)
     -> *mut GSettings;
    pub fn g_settings_new_full(schema: *mut GSettingsSchema,
                               backend: *mut GSettingsBackend,
                               path: *const gchar) -> *mut GSettings;
    pub fn g_settings_list_children(settings: *mut GSettings)
     -> *mut *mut gchar;
    pub fn g_settings_list_keys(settings: *mut GSettings) -> *mut *mut gchar;
    pub fn g_settings_get_range(settings: *mut GSettings, key: *const gchar)
     -> *mut GVariant;
    pub fn g_settings_range_check(settings: *mut GSettings, key: *const gchar,
                                  value: *mut GVariant) -> gboolean;
    pub fn g_settings_set_value(settings: *mut GSettings, key: *const gchar,
                                value: *mut GVariant) -> gboolean;
    pub fn g_settings_get_value(settings: *mut GSettings, key: *const gchar)
     -> *mut GVariant;
    pub fn g_settings_get_user_value(settings: *mut GSettings,
                                     key: *const gchar) -> *mut GVariant;
    pub fn g_settings_get_default_value(settings: *mut GSettings,
                                        key: *const gchar) -> *mut GVariant;
    pub fn g_settings_set(settings: *mut GSettings, key: *const gchar,
                          format: *const gchar, ...) -> gboolean;
    pub fn g_settings_get(settings: *mut GSettings, key: *const gchar,
                          format: *const gchar, ...);
    pub fn g_settings_reset(settings: *mut GSettings, key: *const gchar);
    pub fn g_settings_get_int(settings: *mut GSettings, key: *const gchar)
     -> gint;
    pub fn g_settings_set_int(settings: *mut GSettings, key: *const gchar,
                              value: gint) -> gboolean;
    pub fn g_settings_get_uint(settings: *mut GSettings, key: *const gchar)
     -> guint;
    pub fn g_settings_set_uint(settings: *mut GSettings, key: *const gchar,
                               value: guint) -> gboolean;
    pub fn g_settings_get_string(settings: *mut GSettings, key: *const gchar)
     -> *mut gchar;
    pub fn g_settings_set_string(settings: *mut GSettings, key: *const gchar,
                                 value: *const gchar) -> gboolean;
    pub fn g_settings_get_boolean(settings: *mut GSettings, key: *const gchar)
     -> gboolean;
    pub fn g_settings_set_boolean(settings: *mut GSettings, key: *const gchar,
                                  value: gboolean) -> gboolean;
    pub fn g_settings_get_double(settings: *mut GSettings, key: *const gchar)
     -> gdouble;
    pub fn g_settings_set_double(settings: *mut GSettings, key: *const gchar,
                                 value: gdouble) -> gboolean;
    pub fn g_settings_get_strv(settings: *mut GSettings, key: *const gchar)
     -> *mut *mut gchar;
    pub fn g_settings_set_strv(settings: *mut GSettings, key: *const gchar,
                               value: *const *const gchar) -> gboolean;
    pub fn g_settings_get_enum(settings: *mut GSettings, key: *const gchar)
     -> gint;
    pub fn g_settings_set_enum(settings: *mut GSettings, key: *const gchar,
                               value: gint) -> gboolean;
    pub fn g_settings_get_flags(settings: *mut GSettings, key: *const gchar)
     -> guint;
    pub fn g_settings_set_flags(settings: *mut GSettings, key: *const gchar,
                                value: guint) -> gboolean;
    pub fn g_settings_get_child(settings: *mut GSettings, name: *const gchar)
     -> *mut GSettings;
    pub fn g_settings_is_writable(settings: *mut GSettings,
                                  name: *const gchar) -> gboolean;
    pub fn g_settings_delay(settings: *mut GSettings);
    pub fn g_settings_apply(settings: *mut GSettings);
    pub fn g_settings_revert(settings: *mut GSettings);
    pub fn g_settings_get_has_unapplied(settings: *mut GSettings) -> gboolean;
    pub fn g_settings_sync();
    pub fn g_settings_bind(settings: *mut GSettings, key: *const gchar,
                           object: gpointer, property: *const gchar,
                           flags: GSettingsBindFlags);
    pub fn g_settings_bind_with_mapping(settings: *mut GSettings,
                                        key: *const gchar, object: gpointer,
                                        property: *const gchar,
                                        flags: GSettingsBindFlags,
                                        get_mapping: GSettingsBindGetMapping,
                                        set_mapping: GSettingsBindSetMapping,
                                        user_data: gpointer,
                                        destroy: GDestroyNotify);
    pub fn g_settings_bind_writable(settings: *mut GSettings,
                                    key: *const gchar, object: gpointer,
                                    property: *const gchar,
                                    inverted: gboolean);
    pub fn g_settings_unbind(object: gpointer, property: *const gchar);
    pub fn g_settings_create_action(settings: *mut GSettings,
                                    key: *const gchar) -> *mut GAction;
    pub fn g_settings_get_mapped(settings: *mut GSettings, key: *const gchar,
                                 mapping: GSettingsGetMapping,
                                 user_data: gpointer) -> gpointer;
    pub fn g_simple_action_get_type() -> GType;
    pub fn g_simple_action_new(name: *const gchar,
                               parameter_type: *const GVariantType)
     -> *mut GSimpleAction;
    pub fn g_simple_action_new_stateful(name: *const gchar,
                                        parameter_type: *const GVariantType,
                                        state: *mut GVariant)
     -> *mut GSimpleAction;
    pub fn g_simple_action_set_enabled(simple: *mut GSimpleAction,
                                       enabled: gboolean);
    pub fn g_simple_action_set_state(simple: *mut GSimpleAction,
                                     value: *mut GVariant);
    pub fn g_simple_action_set_state_hint(simple: *mut GSimpleAction,
                                          state_hint: *mut GVariant);
    pub fn g_simple_action_group_get_type() -> GType;
    pub fn g_simple_action_group_new() -> *mut GSimpleActionGroup;
    pub fn g_simple_action_group_lookup(simple: *mut GSimpleActionGroup,
                                        action_name: *const gchar)
     -> *mut GAction;
    pub fn g_simple_action_group_insert(simple: *mut GSimpleActionGroup,
                                        action: *mut GAction);
    pub fn g_simple_action_group_remove(simple: *mut GSimpleActionGroup,
                                        action_name: *const gchar);
    pub fn g_simple_action_group_add_entries(simple: *mut GSimpleActionGroup,
                                             entries: *const GActionEntry,
                                             n_entries: gint,
                                             user_data: gpointer);
    pub fn g_simple_async_result_get_type() -> GType;
    pub fn g_simple_async_result_new(source_object: *mut GObject,
                                     callback: GAsyncReadyCallback,
                                     user_data: gpointer,
                                     source_tag: gpointer)
     -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_new_error(source_object: *mut GObject,
                                           callback: GAsyncReadyCallback,
                                           user_data: gpointer,
                                           domain: GQuark, code: gint,
                                           format:
                                               *const ::std::os::raw::c_char, ...)
     -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_new_from_error(source_object: *mut GObject,
                                                callback: GAsyncReadyCallback,
                                                user_data: gpointer,
                                                error: *const GError)
     -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_new_take_error(source_object: *mut GObject,
                                                callback: GAsyncReadyCallback,
                                                user_data: gpointer,
                                                error: *mut GError)
     -> *mut GSimpleAsyncResult;
    pub fn g_simple_async_result_set_op_res_gpointer(simple:
                                                         *mut GSimpleAsyncResult,
                                                     op_res: gpointer,
                                                     destroy_op_res:
                                                         GDestroyNotify);
    pub fn g_simple_async_result_get_op_res_gpointer(simple:
                                                         *mut GSimpleAsyncResult)
     -> gpointer;
    pub fn g_simple_async_result_set_op_res_gssize(simple:
                                                       *mut GSimpleAsyncResult,
                                                   op_res: gssize);
    pub fn g_simple_async_result_get_op_res_gssize(simple:
                                                       *mut GSimpleAsyncResult)
     -> gssize;
    pub fn g_simple_async_result_set_op_res_gboolean(simple:
                                                         *mut GSimpleAsyncResult,
                                                     op_res: gboolean);
    pub fn g_simple_async_result_get_op_res_gboolean(simple:
                                                         *mut GSimpleAsyncResult)
     -> gboolean;
    pub fn g_simple_async_result_set_check_cancellable(simple:
                                                           *mut GSimpleAsyncResult,
                                                       check_cancellable:
                                                           *mut GCancellable);
    pub fn g_simple_async_result_get_source_tag(simple:
                                                    *mut GSimpleAsyncResult)
     -> gpointer;
    pub fn g_simple_async_result_set_handle_cancellation(simple:
                                                             *mut GSimpleAsyncResult,
                                                         handle_cancellation:
                                                             gboolean);
    pub fn g_simple_async_result_complete(simple: *mut GSimpleAsyncResult);
    pub fn g_simple_async_result_complete_in_idle(simple:
                                                      *mut GSimpleAsyncResult);
    pub fn g_simple_async_result_run_in_thread(simple:
                                                   *mut GSimpleAsyncResult,
                                               func: GSimpleAsyncThreadFunc,
                                               io_priority:
                                                   ::std::os::raw::c_int,
                                               cancellable:
                                                   *mut GCancellable);
    pub fn g_simple_async_result_set_from_error(simple:
                                                    *mut GSimpleAsyncResult,
                                                error: *const GError);
    pub fn g_simple_async_result_take_error(simple: *mut GSimpleAsyncResult,
                                            error: *mut GError);
    pub fn g_simple_async_result_propagate_error(simple:
                                                     *mut GSimpleAsyncResult,
                                                 dest: *mut *mut GError)
     -> gboolean;
    pub fn g_simple_async_result_set_error(simple: *mut GSimpleAsyncResult,
                                           domain: GQuark, code: gint,
                                           format:
                                               *const ::std::os::raw::c_char, ...);
    pub fn g_simple_async_result_set_error_va(simple: *mut GSimpleAsyncResult,
                                              domain: GQuark, code: gint,
                                              format:
                                                  *const ::std::os::raw::c_char,
                                              args: va_list);
    pub fn g_simple_async_result_is_valid(result: *mut GAsyncResult,
                                          source: *mut GObject,
                                          source_tag: gpointer) -> gboolean;
    pub fn g_simple_async_report_error_in_idle(object: *mut GObject,
                                               callback: GAsyncReadyCallback,
                                               user_data: gpointer,
                                               domain: GQuark, code: gint,
                                               format:
                                                   *const ::std::os::raw::c_char, ...);
    pub fn g_simple_async_report_gerror_in_idle(object: *mut GObject,
                                                callback: GAsyncReadyCallback,
                                                user_data: gpointer,
                                                error: *const GError);
    pub fn g_simple_async_report_take_gerror_in_idle(object: *mut GObject,
                                                     callback:
                                                         GAsyncReadyCallback,
                                                     user_data: gpointer,
                                                     error: *mut GError);
    pub fn g_simple_io_stream_get_type() -> GType;
    pub fn g_simple_io_stream_new(input_stream: *mut GInputStream,
                                  output_stream: *mut GOutputStream)
     -> *mut GIOStream;
    pub fn g_simple_permission_get_type() -> GType;
    pub fn g_simple_permission_new(allowed: gboolean) -> *mut GPermission;
    pub fn g_socket_client_get_type() -> GType;
    pub fn g_socket_client_new() -> *mut GSocketClient;
    pub fn g_socket_client_get_family(client: *mut GSocketClient)
     -> GSocketFamily;
    pub fn g_socket_client_set_family(client: *mut GSocketClient,
                                      family: GSocketFamily);
    pub fn g_socket_client_get_socket_type(client: *mut GSocketClient)
     -> GSocketType;
    pub fn g_socket_client_set_socket_type(client: *mut GSocketClient,
                                           _type: GSocketType);
    pub fn g_socket_client_get_protocol(client: *mut GSocketClient)
     -> GSocketProtocol;
    pub fn g_socket_client_set_protocol(client: *mut GSocketClient,
                                        protocol: GSocketProtocol);
    pub fn g_socket_client_get_local_address(client: *mut GSocketClient)
     -> *mut GSocketAddress;
    pub fn g_socket_client_set_local_address(client: *mut GSocketClient,
                                             address: *mut GSocketAddress);
    pub fn g_socket_client_get_timeout(client: *mut GSocketClient) -> guint;
    pub fn g_socket_client_set_timeout(client: *mut GSocketClient,
                                       timeout: guint);
    pub fn g_socket_client_get_enable_proxy(client: *mut GSocketClient)
     -> gboolean;
    pub fn g_socket_client_set_enable_proxy(client: *mut GSocketClient,
                                            enable: gboolean);
    pub fn g_socket_client_get_tls(client: *mut GSocketClient) -> gboolean;
    pub fn g_socket_client_set_tls(client: *mut GSocketClient, tls: gboolean);
    pub fn g_socket_client_get_tls_validation_flags(client:
                                                        *mut GSocketClient)
     -> GTlsCertificateFlags;
    pub fn g_socket_client_set_tls_validation_flags(client:
                                                        *mut GSocketClient,
                                                    flags:
                                                        GTlsCertificateFlags);
    pub fn g_socket_client_get_proxy_resolver(client: *mut GSocketClient)
     -> *mut GProxyResolver;
    pub fn g_socket_client_set_proxy_resolver(client: *mut GSocketClient,
                                              proxy_resolver:
                                                  *mut GProxyResolver);
    pub fn g_socket_client_connect(client: *mut GSocketClient,
                                   connectable: *mut GSocketConnectable,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_host(client: *mut GSocketClient,
                                           host_and_port: *const gchar,
                                           default_port: guint16,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_service(client: *mut GSocketClient,
                                              domain: *const gchar,
                                              service: *const gchar,
                                              cancellable: *mut GCancellable,
                                              error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_uri(client: *mut GSocketClient,
                                          uri: *const gchar,
                                          default_port: guint16,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_client_connect_async(client: *mut GSocketClient,
                                         connectable: *mut GSocketConnectable,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_socket_client_connect_finish(client: *mut GSocketClient,
                                          result: *mut GAsyncResult,
                                          error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_host_async(client: *mut GSocketClient,
                                                 host_and_port: *const gchar,
                                                 default_port: guint16,
                                                 cancellable:
                                                     *mut GCancellable,
                                                 callback:
                                                     GAsyncReadyCallback,
                                                 user_data: gpointer);
    pub fn g_socket_client_connect_to_host_finish(client: *mut GSocketClient,
                                                  result: *mut GAsyncResult,
                                                  error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_service_async(client:
                                                        *mut GSocketClient,
                                                    domain: *const gchar,
                                                    service: *const gchar,
                                                    cancellable:
                                                        *mut GCancellable,
                                                    callback:
                                                        GAsyncReadyCallback,
                                                    user_data: gpointer);
    pub fn g_socket_client_connect_to_service_finish(client:
                                                         *mut GSocketClient,
                                                     result:
                                                         *mut GAsyncResult,
                                                     error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_client_connect_to_uri_async(client: *mut GSocketClient,
                                                uri: *const gchar,
                                                default_port: guint16,
                                                cancellable:
                                                    *mut GCancellable,
                                                callback: GAsyncReadyCallback,
                                                user_data: gpointer);
    pub fn g_socket_client_connect_to_uri_finish(client: *mut GSocketClient,
                                                 result: *mut GAsyncResult,
                                                 error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_client_add_application_proxy(client: *mut GSocketClient,
                                                 protocol: *const gchar);
    pub fn g_socket_connectable_get_type() -> GType;
    pub fn g_socket_connectable_enumerate(connectable:
                                              *mut GSocketConnectable)
     -> *mut GSocketAddressEnumerator;
    pub fn g_socket_connectable_proxy_enumerate(connectable:
                                                    *mut GSocketConnectable)
     -> *mut GSocketAddressEnumerator;
    pub fn g_socket_get_type() -> GType;
    pub fn g_socket_new(family: GSocketFamily, _type: GSocketType,
                        protocol: GSocketProtocol, error: *mut *mut GError)
     -> *mut GSocket;
    pub fn g_socket_new_from_fd(fd: gint, error: *mut *mut GError)
     -> *mut GSocket;
    pub fn g_socket_get_fd(socket: *mut GSocket) -> ::std::os::raw::c_int;
    pub fn g_socket_get_family(socket: *mut GSocket) -> GSocketFamily;
    pub fn g_socket_get_socket_type(socket: *mut GSocket) -> GSocketType;
    pub fn g_socket_get_protocol(socket: *mut GSocket) -> GSocketProtocol;
    pub fn g_socket_get_local_address(socket: *mut GSocket,
                                      error: *mut *mut GError)
     -> *mut GSocketAddress;
    pub fn g_socket_get_remote_address(socket: *mut GSocket,
                                       error: *mut *mut GError)
     -> *mut GSocketAddress;
    pub fn g_socket_set_blocking(socket: *mut GSocket, blocking: gboolean);
    pub fn g_socket_get_blocking(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_set_keepalive(socket: *mut GSocket, keepalive: gboolean);
    pub fn g_socket_get_keepalive(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_listen_backlog(socket: *mut GSocket) -> gint;
    pub fn g_socket_set_listen_backlog(socket: *mut GSocket, backlog: gint);
    pub fn g_socket_get_timeout(socket: *mut GSocket) -> guint;
    pub fn g_socket_set_timeout(socket: *mut GSocket, timeout: guint);
    pub fn g_socket_get_ttl(socket: *mut GSocket) -> guint;
    pub fn g_socket_set_ttl(socket: *mut GSocket, ttl: guint);
    pub fn g_socket_get_broadcast(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_set_broadcast(socket: *mut GSocket, broadcast: gboolean);
    pub fn g_socket_get_multicast_loopback(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_set_multicast_loopback(socket: *mut GSocket,
                                           loopback: gboolean);
    pub fn g_socket_get_multicast_ttl(socket: *mut GSocket) -> guint;
    pub fn g_socket_set_multicast_ttl(socket: *mut GSocket, ttl: guint);
    pub fn g_socket_is_connected(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_bind(socket: *mut GSocket, address: *mut GSocketAddress,
                         allow_reuse: gboolean, error: *mut *mut GError)
     -> gboolean;
    pub fn g_socket_join_multicast_group(socket: *mut GSocket,
                                         group: *mut GInetAddress,
                                         source_specific: gboolean,
                                         iface: *const gchar,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_socket_leave_multicast_group(socket: *mut GSocket,
                                          group: *mut GInetAddress,
                                          source_specific: gboolean,
                                          iface: *const gchar,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_socket_connect(socket: *mut GSocket,
                            address: *mut GSocketAddress,
                            cancellable: *mut GCancellable,
                            error: *mut *mut GError) -> gboolean;
    pub fn g_socket_check_connect_result(socket: *mut GSocket,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_socket_get_available_bytes(socket: *mut GSocket) -> gssize;
    pub fn g_socket_condition_check(socket: *mut GSocket,
                                    condition: GIOCondition) -> GIOCondition;
    pub fn g_socket_condition_wait(socket: *mut GSocket,
                                   condition: GIOCondition,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_socket_condition_timed_wait(socket: *mut GSocket,
                                         condition: GIOCondition,
                                         timeout: gint64,
                                         cancellable: *mut GCancellable,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_socket_accept(socket: *mut GSocket,
                           cancellable: *mut GCancellable,
                           error: *mut *mut GError) -> *mut GSocket;
    pub fn g_socket_listen(socket: *mut GSocket, error: *mut *mut GError)
     -> gboolean;
    pub fn g_socket_receive(socket: *mut GSocket, buffer: *mut gchar,
                            size: gsize, cancellable: *mut GCancellable,
                            error: *mut *mut GError) -> gssize;
    pub fn g_socket_receive_from(socket: *mut GSocket,
                                 address: *mut *mut GSocketAddress,
                                 buffer: *mut gchar, size: gsize,
                                 cancellable: *mut GCancellable,
                                 error: *mut *mut GError) -> gssize;
    pub fn g_socket_send(socket: *mut GSocket, buffer: *const gchar,
                         size: gsize, cancellable: *mut GCancellable,
                         error: *mut *mut GError) -> gssize;
    pub fn g_socket_send_to(socket: *mut GSocket,
                            address: *mut GSocketAddress,
                            buffer: *const gchar, size: gsize,
                            cancellable: *mut GCancellable,
                            error: *mut *mut GError) -> gssize;
    pub fn g_socket_receive_message(socket: *mut GSocket,
                                    address: *mut *mut GSocketAddress,
                                    vectors: *mut GInputVector,
                                    num_vectors: gint,
                                    messages:
                                        *mut *mut *mut GSocketControlMessage,
                                    num_messages: *mut gint, flags: *mut gint,
                                    cancellable: *mut GCancellable,
                                    error: *mut *mut GError) -> gssize;
    pub fn g_socket_send_message(socket: *mut GSocket,
                                 address: *mut GSocketAddress,
                                 vectors: *mut GOutputVector,
                                 num_vectors: gint,
                                 messages: *mut *mut GSocketControlMessage,
                                 num_messages: gint, flags: gint,
                                 cancellable: *mut GCancellable,
                                 error: *mut *mut GError) -> gssize;
    pub fn g_socket_send_messages(socket: *mut GSocket,
                                  messages: *mut GOutputMessage,
                                  num_messages: guint, flags: gint,
                                  cancellable: *mut GCancellable,
                                  error: *mut *mut GError) -> gint;
    pub fn g_socket_close(socket: *mut GSocket, error: *mut *mut GError)
     -> gboolean;
    pub fn g_socket_shutdown(socket: *mut GSocket, shutdown_read: gboolean,
                             shutdown_write: gboolean,
                             error: *mut *mut GError) -> gboolean;
    pub fn g_socket_is_closed(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_create_source(socket: *mut GSocket,
                                  condition: GIOCondition,
                                  cancellable: *mut GCancellable)
     -> *mut GSource;
    pub fn g_socket_speaks_ipv4(socket: *mut GSocket) -> gboolean;
    pub fn g_socket_get_credentials(socket: *mut GSocket,
                                    error: *mut *mut GError)
     -> *mut GCredentials;
    pub fn g_socket_receive_with_blocking(socket: *mut GSocket,
                                          buffer: *mut gchar, size: gsize,
                                          blocking: gboolean,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError) -> gssize;
    pub fn g_socket_send_with_blocking(socket: *mut GSocket,
                                       buffer: *const gchar, size: gsize,
                                       blocking: gboolean,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError) -> gssize;
    pub fn g_socket_get_option(socket: *mut GSocket, level: gint,
                               optname: gint, value: *mut gint,
                               error: *mut *mut GError) -> gboolean;
    pub fn g_socket_set_option(socket: *mut GSocket, level: gint,
                               optname: gint, value: gint,
                               error: *mut *mut GError) -> gboolean;
    pub fn g_socket_connection_get_type() -> GType;
    pub fn g_socket_connection_is_connected(connection:
                                                *mut GSocketConnection)
     -> gboolean;
    pub fn g_socket_connection_connect(connection: *mut GSocketConnection,
                                       address: *mut GSocketAddress,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError) -> gboolean;
    pub fn g_socket_connection_connect_async(connection:
                                                 *mut GSocketConnection,
                                             address: *mut GSocketAddress,
                                             cancellable: *mut GCancellable,
                                             callback: GAsyncReadyCallback,
                                             user_data: gpointer);
    pub fn g_socket_connection_connect_finish(connection:
                                                  *mut GSocketConnection,
                                              result: *mut GAsyncResult,
                                              error: *mut *mut GError)
     -> gboolean;
    pub fn g_socket_connection_get_socket(connection: *mut GSocketConnection)
     -> *mut GSocket;
    pub fn g_socket_connection_get_local_address(connection:
                                                     *mut GSocketConnection,
                                                 error: *mut *mut GError)
     -> *mut GSocketAddress;
    pub fn g_socket_connection_get_remote_address(connection:
                                                      *mut GSocketConnection,
                                                  error: *mut *mut GError)
     -> *mut GSocketAddress;
    pub fn g_socket_connection_factory_register_type(g_type: GType,
                                                     family: GSocketFamily,
                                                     _type: GSocketType,
                                                     protocol: gint);
    pub fn g_socket_connection_factory_lookup_type(family: GSocketFamily,
                                                   _type: GSocketType,
                                                   protocol_id: gint)
     -> GType;
    pub fn g_socket_connection_factory_create_connection(socket: *mut GSocket)
     -> *mut GSocketConnection;
    pub fn g_socket_control_message_get_type() -> GType;
    pub fn g_socket_control_message_get_size(message:
                                                 *mut GSocketControlMessage)
     -> gsize;
    pub fn g_socket_control_message_get_level(message:
                                                  *mut GSocketControlMessage)
     -> ::std::os::raw::c_int;
    pub fn g_socket_control_message_get_msg_type(message:
                                                     *mut GSocketControlMessage)
     -> ::std::os::raw::c_int;
    pub fn g_socket_control_message_serialize(message:
                                                  *mut GSocketControlMessage,
                                              data: gpointer);
    pub fn g_socket_control_message_deserialize(level: ::std::os::raw::c_int,
                                                _type: ::std::os::raw::c_int,
                                                size: gsize, data: gpointer)
     -> *mut GSocketControlMessage;
    pub fn g_socket_listener_get_type() -> GType;
    pub fn g_socket_listener_new() -> *mut GSocketListener;
    pub fn g_socket_listener_set_backlog(listener: *mut GSocketListener,
                                         listen_backlog:
                                             ::std::os::raw::c_int);
    pub fn g_socket_listener_add_socket(listener: *mut GSocketListener,
                                        socket: *mut GSocket,
                                        source_object: *mut GObject,
                                        error: *mut *mut GError) -> gboolean;
    pub fn g_socket_listener_add_address(listener: *mut GSocketListener,
                                         address: *mut GSocketAddress,
                                         _type: GSocketType,
                                         protocol: GSocketProtocol,
                                         source_object: *mut GObject,
                                         effective_address:
                                             *mut *mut GSocketAddress,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_socket_listener_add_inet_port(listener: *mut GSocketListener,
                                           port: guint16,
                                           source_object: *mut GObject,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_socket_listener_add_any_inet_port(listener: *mut GSocketListener,
                                               source_object: *mut GObject,
                                               error: *mut *mut GError)
     -> guint16;
    pub fn g_socket_listener_accept_socket(listener: *mut GSocketListener,
                                           source_object: *mut *mut GObject,
                                           cancellable: *mut GCancellable,
                                           error: *mut *mut GError)
     -> *mut GSocket;
    pub fn g_socket_listener_accept_socket_async(listener:
                                                     *mut GSocketListener,
                                                 cancellable:
                                                     *mut GCancellable,
                                                 callback:
                                                     GAsyncReadyCallback,
                                                 user_data: gpointer);
    pub fn g_socket_listener_accept_socket_finish(listener:
                                                      *mut GSocketListener,
                                                  result: *mut GAsyncResult,
                                                  source_object:
                                                      *mut *mut GObject,
                                                  error: *mut *mut GError)
     -> *mut GSocket;
    pub fn g_socket_listener_accept(listener: *mut GSocketListener,
                                    source_object: *mut *mut GObject,
                                    cancellable: *mut GCancellable,
                                    error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_listener_accept_async(listener: *mut GSocketListener,
                                          cancellable: *mut GCancellable,
                                          callback: GAsyncReadyCallback,
                                          user_data: gpointer);
    pub fn g_socket_listener_accept_finish(listener: *mut GSocketListener,
                                           result: *mut GAsyncResult,
                                           source_object: *mut *mut GObject,
                                           error: *mut *mut GError)
     -> *mut GSocketConnection;
    pub fn g_socket_listener_close(listener: *mut GSocketListener);
    pub fn g_socket_service_get_type() -> GType;
    pub fn g_socket_service_new() -> *mut GSocketService;
    pub fn g_socket_service_start(service: *mut GSocketService);
    pub fn g_socket_service_stop(service: *mut GSocketService);
    pub fn g_socket_service_is_active(service: *mut GSocketService)
     -> gboolean;
    pub fn g_srv_target_get_type() -> GType;
    pub fn g_srv_target_new(hostname: *const gchar, port: guint16,
                            priority: guint16, weight: guint16)
     -> *mut GSrvTarget;
    pub fn g_srv_target_copy(target: *mut GSrvTarget) -> *mut GSrvTarget;
    pub fn g_srv_target_free(target: *mut GSrvTarget);
    pub fn g_srv_target_get_hostname(target: *mut GSrvTarget) -> *const gchar;
    pub fn g_srv_target_get_port(target: *mut GSrvTarget) -> guint16;
    pub fn g_srv_target_get_priority(target: *mut GSrvTarget) -> guint16;
    pub fn g_srv_target_get_weight(target: *mut GSrvTarget) -> guint16;
    pub fn g_srv_target_list_sort(targets: *mut GList) -> *mut GList;
    pub fn g_simple_proxy_resolver_get_type() -> GType;
    pub fn g_simple_proxy_resolver_new(default_proxy: *const gchar,
                                       ignore_hosts: *mut *mut gchar)
     -> *mut GProxyResolver;
    pub fn g_simple_proxy_resolver_set_default_proxy(resolver:
                                                         *mut GSimpleProxyResolver,
                                                     default_proxy:
                                                         *const gchar);
    pub fn g_simple_proxy_resolver_set_ignore_hosts(resolver:
                                                        *mut GSimpleProxyResolver,
                                                    ignore_hosts:
                                                        *mut *mut gchar);
    pub fn g_simple_proxy_resolver_set_uri_proxy(resolver:
                                                     *mut GSimpleProxyResolver,
                                                 uri_scheme: *const gchar,
                                                 proxy: *const gchar);
    pub fn g_task_get_type() -> GType;
    pub fn g_task_new(source_object: gpointer, cancellable: *mut GCancellable,
                      callback: GAsyncReadyCallback, callback_data: gpointer)
     -> *mut GTask;
    pub fn g_task_report_error(source_object: gpointer,
                               callback: GAsyncReadyCallback,
                               callback_data: gpointer, source_tag: gpointer,
                               error: *mut GError);
    pub fn g_task_report_new_error(source_object: gpointer,
                                   callback: GAsyncReadyCallback,
                                   callback_data: gpointer,
                                   source_tag: gpointer, domain: GQuark,
                                   code: gint,
                                   format:
                                       *const ::std::os::raw::c_char, ...);
    pub fn g_task_set_task_data(task: *mut GTask, task_data: gpointer,
                                task_data_destroy: GDestroyNotify);
    pub fn g_task_set_priority(task: *mut GTask, priority: gint);
    pub fn g_task_set_check_cancellable(task: *mut GTask,
                                        check_cancellable: gboolean);
    pub fn g_task_set_source_tag(task: *mut GTask, source_tag: gpointer);
    pub fn g_task_get_source_object(task: *mut GTask) -> gpointer;
    pub fn g_task_get_task_data(task: *mut GTask) -> gpointer;
    pub fn g_task_get_priority(task: *mut GTask) -> gint;
    pub fn g_task_get_context(task: *mut GTask) -> *mut GMainContext;
    pub fn g_task_get_cancellable(task: *mut GTask) -> *mut GCancellable;
    pub fn g_task_get_check_cancellable(task: *mut GTask) -> gboolean;
    pub fn g_task_get_source_tag(task: *mut GTask) -> gpointer;
    pub fn g_task_is_valid(result: gpointer, source_object: gpointer)
     -> gboolean;
    pub fn g_task_run_in_thread(task: *mut GTask, task_func: GTaskThreadFunc);
    pub fn g_task_run_in_thread_sync(task: *mut GTask,
                                     task_func: GTaskThreadFunc);
    pub fn g_task_set_return_on_cancel(task: *mut GTask,
                                       return_on_cancel: gboolean)
     -> gboolean;
    pub fn g_task_get_return_on_cancel(task: *mut GTask) -> gboolean;
    pub fn g_task_attach_source(task: *mut GTask, source: *mut GSource,
                                callback: GSourceFunc);
    pub fn g_task_return_pointer(task: *mut GTask, result: gpointer,
                                 result_destroy: GDestroyNotify);
    pub fn g_task_return_boolean(task: *mut GTask, result: gboolean);
    pub fn g_task_return_int(task: *mut GTask, result: gssize);
    pub fn g_task_return_error(task: *mut GTask, error: *mut GError);
    pub fn g_task_return_new_error(task: *mut GTask, domain: GQuark,
                                   code: gint,
                                   format:
                                       *const ::std::os::raw::c_char, ...);
    pub fn g_task_return_error_if_cancelled(task: *mut GTask) -> gboolean;
    pub fn g_task_propagate_pointer(task: *mut GTask, error: *mut *mut GError)
     -> gpointer;
    pub fn g_task_propagate_boolean(task: *mut GTask, error: *mut *mut GError)
     -> gboolean;
    pub fn g_task_propagate_int(task: *mut GTask, error: *mut *mut GError)
     -> gssize;
    pub fn g_task_had_error(task: *mut GTask) -> gboolean;
    pub fn g_task_get_completed(task: *mut GTask) -> gboolean;
    pub fn g_subprocess_get_type() -> GType;
    pub fn g_subprocess_new(flags: GSubprocessFlags, error: *mut *mut GError,
                            argv0: *const gchar, ...) -> *mut GSubprocess;
    pub fn g_subprocess_newv(argv: *const *const gchar,
                             flags: GSubprocessFlags, error: *mut *mut GError)
     -> *mut GSubprocess;
    pub fn g_subprocess_get_stdin_pipe(subprocess: *mut GSubprocess)
     -> *mut GOutputStream;
    pub fn g_subprocess_get_stdout_pipe(subprocess: *mut GSubprocess)
     -> *mut GInputStream;
    pub fn g_subprocess_get_stderr_pipe(subprocess: *mut GSubprocess)
     -> *mut GInputStream;
    pub fn g_subprocess_get_identifier(subprocess: *mut GSubprocess)
     -> *const gchar;
    pub fn g_subprocess_send_signal(subprocess: *mut GSubprocess,
                                    signal_num: gint);
    pub fn g_subprocess_force_exit(subprocess: *mut GSubprocess);
    pub fn g_subprocess_wait(subprocess: *mut GSubprocess,
                             cancellable: *mut GCancellable,
                             error: *mut *mut GError) -> gboolean;
    pub fn g_subprocess_wait_async(subprocess: *mut GSubprocess,
                                   cancellable: *mut GCancellable,
                                   callback: GAsyncReadyCallback,
                                   user_data: gpointer);
    pub fn g_subprocess_wait_finish(subprocess: *mut GSubprocess,
                                    result: *mut GAsyncResult,
                                    error: *mut *mut GError) -> gboolean;
    pub fn g_subprocess_wait_check(subprocess: *mut GSubprocess,
                                   cancellable: *mut GCancellable,
                                   error: *mut *mut GError) -> gboolean;
    pub fn g_subprocess_wait_check_async(subprocess: *mut GSubprocess,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_subprocess_wait_check_finish(subprocess: *mut GSubprocess,
                                          result: *mut GAsyncResult,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn g_subprocess_get_status(subprocess: *mut GSubprocess) -> gint;
    pub fn g_subprocess_get_successful(subprocess: *mut GSubprocess)
     -> gboolean;
    pub fn g_subprocess_get_if_exited(subprocess: *mut GSubprocess)
     -> gboolean;
    pub fn g_subprocess_get_exit_status(subprocess: *mut GSubprocess) -> gint;
    pub fn g_subprocess_get_if_signaled(subprocess: *mut GSubprocess)
     -> gboolean;
    pub fn g_subprocess_get_term_sig(subprocess: *mut GSubprocess) -> gint;
    pub fn g_subprocess_communicate(subprocess: *mut GSubprocess,
                                    stdin_buf: *mut GBytes,
                                    cancellable: *mut GCancellable,
                                    stdout_buf: *mut *mut GBytes,
                                    stderr_buf: *mut *mut GBytes,
                                    error: *mut *mut GError) -> gboolean;
    pub fn g_subprocess_communicate_async(subprocess: *mut GSubprocess,
                                          stdin_buf: *mut GBytes,
                                          cancellable: *mut GCancellable,
                                          callback: GAsyncReadyCallback,
                                          user_data: gpointer);
    pub fn g_subprocess_communicate_finish(subprocess: *mut GSubprocess,
                                           result: *mut GAsyncResult,
                                           stdout_buf: *mut *mut GBytes,
                                           stderr_buf: *mut *mut GBytes,
                                           error: *mut *mut GError)
     -> gboolean;
    pub fn g_subprocess_communicate_utf8(subprocess: *mut GSubprocess,
                                         stdin_buf:
                                             *const ::std::os::raw::c_char,
                                         cancellable: *mut GCancellable,
                                         stdout_buf:
                                             *mut *mut ::std::os::raw::c_char,
                                         stderr_buf:
                                             *mut *mut ::std::os::raw::c_char,
                                         error: *mut *mut GError) -> gboolean;
    pub fn g_subprocess_communicate_utf8_async(subprocess: *mut GSubprocess,
                                               stdin_buf:
                                                   *const ::std::os::raw::c_char,
                                               cancellable: *mut GCancellable,
                                               callback: GAsyncReadyCallback,
                                               user_data: gpointer);
    pub fn g_subprocess_communicate_utf8_finish(subprocess: *mut GSubprocess,
                                                result: *mut GAsyncResult,
                                                stdout_buf:
                                                    *mut *mut ::std::os::raw::c_char,
                                                stderr_buf:
                                                    *mut *mut ::std::os::raw::c_char,
                                                error: *mut *mut GError)
     -> gboolean;
    pub fn g_subprocess_launcher_get_type() -> GType;
    pub fn g_subprocess_launcher_new(flags: GSubprocessFlags)
     -> *mut GSubprocessLauncher;
    pub fn g_subprocess_launcher_spawn(_self: *mut GSubprocessLauncher,
                                       error: *mut *mut GError,
                                       argv0: *const gchar, ...)
     -> *mut GSubprocess;
    pub fn g_subprocess_launcher_spawnv(_self: *mut GSubprocessLauncher,
                                        argv: *const *const gchar,
                                        error: *mut *mut GError)
     -> *mut GSubprocess;
    pub fn g_subprocess_launcher_set_environ(_self: *mut GSubprocessLauncher,
                                             env: *mut *mut gchar);
    pub fn g_subprocess_launcher_setenv(_self: *mut GSubprocessLauncher,
                                        variable: *const gchar,
                                        value: *const gchar,
                                        overwrite: gboolean);
    pub fn g_subprocess_launcher_unsetenv(_self: *mut GSubprocessLauncher,
                                          variable: *const gchar);
    pub fn g_subprocess_launcher_getenv(_self: *mut GSubprocessLauncher,
                                        variable: *const gchar)
     -> *const gchar;
    pub fn g_subprocess_launcher_set_cwd(_self: *mut GSubprocessLauncher,
                                         cwd: *const gchar);
    pub fn g_subprocess_launcher_set_flags(_self: *mut GSubprocessLauncher,
                                           flags: GSubprocessFlags);
    pub fn g_subprocess_launcher_set_stdin_file_path(_self:
                                                         *mut GSubprocessLauncher,
                                                     path: *const gchar);
    pub fn g_subprocess_launcher_take_stdin_fd(_self:
                                                   *mut GSubprocessLauncher,
                                               fd: gint);
    pub fn g_subprocess_launcher_set_stdout_file_path(_self:
                                                          *mut GSubprocessLauncher,
                                                      path: *const gchar);
    pub fn g_subprocess_launcher_take_stdout_fd(_self:
                                                    *mut GSubprocessLauncher,
                                                fd: gint);
    pub fn g_subprocess_launcher_set_stderr_file_path(_self:
                                                          *mut GSubprocessLauncher,
                                                      path: *const gchar);
    pub fn g_subprocess_launcher_take_stderr_fd(_self:
                                                    *mut GSubprocessLauncher,
                                                fd: gint);
    pub fn g_subprocess_launcher_take_fd(_self: *mut GSubprocessLauncher,
                                         source_fd: gint, target_fd: gint);
    pub fn g_subprocess_launcher_set_child_setup(_self:
                                                     *mut GSubprocessLauncher,
                                                 child_setup:
                                                     GSpawnChildSetupFunc,
                                                 user_data: gpointer,
                                                 destroy_notify:
                                                     GDestroyNotify);
    pub fn g_tcp_connection_get_type() -> GType;
    pub fn g_tcp_connection_set_graceful_disconnect(connection:
                                                        *mut GTcpConnection,
                                                    graceful_disconnect:
                                                        gboolean);
    pub fn g_tcp_connection_get_graceful_disconnect(connection:
                                                        *mut GTcpConnection)
     -> gboolean;
    pub fn g_tcp_wrapper_connection_get_type() -> GType;
    pub fn g_tcp_wrapper_connection_new(base_io_stream: *mut GIOStream,
                                        socket: *mut GSocket)
     -> *mut GSocketConnection;
    pub fn g_tcp_wrapper_connection_get_base_io_stream(conn:
                                                           *mut GTcpWrapperConnection)
     -> *mut GIOStream;
    pub fn g_test_dbus_get_type() -> GType;
    pub fn g_test_dbus_new(flags: GTestDBusFlags) -> *mut GTestDBus;
    pub fn g_test_dbus_get_flags(_self: *mut GTestDBus) -> GTestDBusFlags;
    pub fn g_test_dbus_get_bus_address(_self: *mut GTestDBus) -> *const gchar;
    pub fn g_test_dbus_add_service_dir(_self: *mut GTestDBus,
                                       path: *const gchar);
    pub fn g_test_dbus_up(_self: *mut GTestDBus);
    pub fn g_test_dbus_stop(_self: *mut GTestDBus);
    pub fn g_test_dbus_down(_self: *mut GTestDBus);
    pub fn g_test_dbus_unset();
    pub fn g_themed_icon_get_type() -> GType;
    pub fn g_themed_icon_new(iconname: *const ::std::os::raw::c_char)
     -> *mut GIcon;
    pub fn g_themed_icon_new_with_default_fallbacks(iconname:
                                                        *const ::std::os::raw::c_char)
     -> *mut GIcon;
    pub fn g_themed_icon_new_from_names(iconnames:
                                            *mut *mut ::std::os::raw::c_char,
                                        len: ::std::os::raw::c_int)
     -> *mut GIcon;
    pub fn g_themed_icon_prepend_name(icon: *mut GThemedIcon,
                                      iconname:
                                          *const ::std::os::raw::c_char);
    pub fn g_themed_icon_append_name(icon: *mut GThemedIcon,
                                     iconname: *const ::std::os::raw::c_char);
    pub fn g_themed_icon_get_names(icon: *mut GThemedIcon)
     -> *const *const gchar;
    pub fn g_threaded_socket_service_get_type() -> GType;
    pub fn g_threaded_socket_service_new(max_threads: ::std::os::raw::c_int)
     -> *mut GSocketService;
    pub fn g_tls_backend_get_type() -> GType;
    pub fn g_tls_backend_get_default() -> *mut GTlsBackend;
    pub fn g_tls_backend_get_default_database(backend: *mut GTlsBackend)
     -> *mut GTlsDatabase;
    pub fn g_tls_backend_supports_tls(backend: *mut GTlsBackend) -> gboolean;
    pub fn g_tls_backend_get_certificate_type(backend: *mut GTlsBackend)
     -> GType;
    pub fn g_tls_backend_get_client_connection_type(backend: *mut GTlsBackend)
     -> GType;
    pub fn g_tls_backend_get_server_connection_type(backend: *mut GTlsBackend)
     -> GType;
    pub fn g_tls_backend_get_file_database_type(backend: *mut GTlsBackend)
     -> GType;
    pub fn g_tls_certificate_get_type() -> GType;
    pub fn g_tls_certificate_new_from_pem(data: *const gchar, length: gssize,
                                          error: *mut *mut GError)
     -> *mut GTlsCertificate;
    pub fn g_tls_certificate_new_from_file(file: *const gchar,
                                           error: *mut *mut GError)
     -> *mut GTlsCertificate;
    pub fn g_tls_certificate_new_from_files(cert_file: *const gchar,
                                            key_file: *const gchar,
                                            error: *mut *mut GError)
     -> *mut GTlsCertificate;
    pub fn g_tls_certificate_list_new_from_file(file: *const gchar,
                                                error: *mut *mut GError)
     -> *mut GList;
    pub fn g_tls_certificate_get_issuer(cert: *mut GTlsCertificate)
     -> *mut GTlsCertificate;
    pub fn g_tls_certificate_verify(cert: *mut GTlsCertificate,
                                    identity: *mut GSocketConnectable,
                                    trusted_ca: *mut GTlsCertificate)
     -> GTlsCertificateFlags;
    pub fn g_tls_certificate_is_same(cert_one: *mut GTlsCertificate,
                                     cert_two: *mut GTlsCertificate)
     -> gboolean;
    pub fn g_tls_connection_get_type() -> GType;
    pub fn g_tls_connection_set_use_system_certdb(conn: *mut GTlsConnection,
                                                  use_system_certdb:
                                                      gboolean);
    pub fn g_tls_connection_get_use_system_certdb(conn: *mut GTlsConnection)
     -> gboolean;
    pub fn g_tls_connection_set_database(conn: *mut GTlsConnection,
                                         database: *mut GTlsDatabase);
    pub fn g_tls_connection_get_database(conn: *mut GTlsConnection)
     -> *mut GTlsDatabase;
    pub fn g_tls_connection_set_certificate(conn: *mut GTlsConnection,
                                            certificate:
                                                *mut GTlsCertificate);
    pub fn g_tls_connection_get_certificate(conn: *mut GTlsConnection)
     -> *mut GTlsCertificate;
    pub fn g_tls_connection_set_interaction(conn: *mut GTlsConnection,
                                            interaction:
                                                *mut GTlsInteraction);
    pub fn g_tls_connection_get_interaction(conn: *mut GTlsConnection)
     -> *mut GTlsInteraction;
    pub fn g_tls_connection_get_peer_certificate(conn: *mut GTlsConnection)
     -> *mut GTlsCertificate;
    pub fn g_tls_connection_get_peer_certificate_errors(conn:
                                                            *mut GTlsConnection)
     -> GTlsCertificateFlags;
    pub fn g_tls_connection_set_require_close_notify(conn:
                                                         *mut GTlsConnection,
                                                     require_close_notify:
                                                         gboolean);
    pub fn g_tls_connection_get_require_close_notify(conn:
                                                         *mut GTlsConnection)
     -> gboolean;
    pub fn g_tls_connection_set_rehandshake_mode(conn: *mut GTlsConnection,
                                                 mode: GTlsRehandshakeMode);
    pub fn g_tls_connection_get_rehandshake_mode(conn: *mut GTlsConnection)
     -> GTlsRehandshakeMode;
    pub fn g_tls_connection_handshake(conn: *mut GTlsConnection,
                                      cancellable: *mut GCancellable,
                                      error: *mut *mut GError) -> gboolean;
    pub fn g_tls_connection_handshake_async(conn: *mut GTlsConnection,
                                            io_priority:
                                                ::std::os::raw::c_int,
                                            cancellable: *mut GCancellable,
                                            callback: GAsyncReadyCallback,
                                            user_data: gpointer);
    pub fn g_tls_connection_handshake_finish(conn: *mut GTlsConnection,
                                             result: *mut GAsyncResult,
                                             error: *mut *mut GError)
     -> gboolean;
    pub fn g_tls_error_quark() -> GQuark;
    pub fn g_tls_connection_emit_accept_certificate(conn: *mut GTlsConnection,
                                                    peer_cert:
                                                        *mut GTlsCertificate,
                                                    errors:
                                                        GTlsCertificateFlags)
     -> gboolean;
    pub fn g_tls_client_connection_get_type() -> GType;
    pub fn g_tls_client_connection_new(base_io_stream: *mut GIOStream,
                                       server_identity:
                                           *mut GSocketConnectable,
                                       error: *mut *mut GError)
     -> *mut GIOStream;
    pub fn g_tls_client_connection_get_validation_flags(conn:
                                                            *mut GTlsClientConnection)
     -> GTlsCertificateFlags;
    pub fn g_tls_client_connection_set_validation_flags(conn:
                                                            *mut GTlsClientConnection,
                                                        flags:
                                                            GTlsCertificateFlags);
    pub fn g_tls_client_connection_get_server_identity(conn:
                                                           *mut GTlsClientConnection)
     -> *mut GSocketConnectable;
    pub fn g_tls_client_connection_set_server_identity(conn:
                                                           *mut GTlsClientConnection,
                                                       identity:
                                                           *mut GSocketConnectable);
    pub fn g_tls_client_connection_get_use_ssl3(conn:
                                                    *mut GTlsClientConnection)
     -> gboolean;
    pub fn g_tls_client_connection_set_use_ssl3(conn:
                                                    *mut GTlsClientConnection,
                                                use_ssl3: gboolean);
    pub fn g_tls_client_connection_get_accepted_cas(conn:
                                                        *mut GTlsClientConnection)
     -> *mut GList;
    pub fn g_tls_client_connection_copy_session_state(conn:
                                                          *mut GTlsClientConnection,
                                                      source:
                                                          *mut GTlsClientConnection);
    pub fn g_tls_database_get_type() -> GType;
    pub fn g_tls_database_verify_chain(_self: *mut GTlsDatabase,
                                       chain: *mut GTlsCertificate,
                                       purpose: *const gchar,
                                       identity: *mut GSocketConnectable,
                                       interaction: *mut GTlsInteraction,
                                       flags: GTlsDatabaseVerifyFlags,
                                       cancellable: *mut GCancellable,
                                       error: *mut *mut GError)
     -> GTlsCertificateFlags;
    pub fn g_tls_database_verify_chain_async(_self: *mut GTlsDatabase,
                                             chain: *mut GTlsCertificate,
                                             purpose: *const gchar,
                                             identity:
                                                 *mut GSocketConnectable,
                                             interaction:
                                                 *mut GTlsInteraction,
                                             flags: GTlsDatabaseVerifyFlags,
                                             cancellable: *mut GCancellable,
                                             callback: GAsyncReadyCallback,
                                             user_data: gpointer);
    pub fn g_tls_database_verify_chain_finish(_self: *mut GTlsDatabase,
                                              result: *mut GAsyncResult,
                                              error: *mut *mut GError)
     -> GTlsCertificateFlags;
    pub fn g_tls_database_create_certificate_handle(_self: *mut GTlsDatabase,
                                                    certificate:
                                                        *mut GTlsCertificate)
     -> *mut gchar;
    pub fn g_tls_database_lookup_certificate_for_handle(_self:
                                                            *mut GTlsDatabase,
                                                        handle: *const gchar,
                                                        interaction:
                                                            *mut GTlsInteraction,
                                                        flags:
                                                            GTlsDatabaseLookupFlags,
                                                        cancellable:
                                                            *mut GCancellable,
                                                        error:
                                                            *mut *mut GError)
     -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificate_for_handle_async(_self:
                                                                  *mut GTlsDatabase,
                                                              handle:
                                                                  *const gchar,
                                                              interaction:
                                                                  *mut GTlsInteraction,
                                                              flags:
                                                                  GTlsDatabaseLookupFlags,
                                                              cancellable:
                                                                  *mut GCancellable,
                                                              callback:
                                                                  GAsyncReadyCallback,
                                                              user_data:
                                                                  gpointer);
    pub fn g_tls_database_lookup_certificate_for_handle_finish(_self:
                                                                   *mut GTlsDatabase,
                                                               result:
                                                                   *mut GAsyncResult,
                                                               error:
                                                                   *mut *mut GError)
     -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificate_issuer(_self: *mut GTlsDatabase,
                                                    certificate:
                                                        *mut GTlsCertificate,
                                                    interaction:
                                                        *mut GTlsInteraction,
                                                    flags:
                                                        GTlsDatabaseLookupFlags,
                                                    cancellable:
                                                        *mut GCancellable,
                                                    error: *mut *mut GError)
     -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificate_issuer_async(_self:
                                                              *mut GTlsDatabase,
                                                          certificate:
                                                              *mut GTlsCertificate,
                                                          interaction:
                                                              *mut GTlsInteraction,
                                                          flags:
                                                              GTlsDatabaseLookupFlags,
                                                          cancellable:
                                                              *mut GCancellable,
                                                          callback:
                                                              GAsyncReadyCallback,
                                                          user_data:
                                                              gpointer);
    pub fn g_tls_database_lookup_certificate_issuer_finish(_self:
                                                               *mut GTlsDatabase,
                                                           result:
                                                               *mut GAsyncResult,
                                                           error:
                                                               *mut *mut GError)
     -> *mut GTlsCertificate;
    pub fn g_tls_database_lookup_certificates_issued_by(_self:
                                                            *mut GTlsDatabase,
                                                        issuer_raw_dn:
                                                            *mut GByteArray,
                                                        interaction:
                                                            *mut GTlsInteraction,
                                                        flags:
                                                            GTlsDatabaseLookupFlags,
                                                        cancellable:
                                                            *mut GCancellable,
                                                        error:
                                                            *mut *mut GError)
     -> *mut GList;
    pub fn g_tls_database_lookup_certificates_issued_by_async(_self:
                                                                  *mut GTlsDatabase,
                                                              issuer_raw_dn:
                                                                  *mut GByteArray,
                                                              interaction:
                                                                  *mut GTlsInteraction,
                                                              flags:
                                                                  GTlsDatabaseLookupFlags,
                                                              cancellable:
                                                                  *mut GCancellable,
                                                              callback:
                                                                  GAsyncReadyCallback,
                                                              user_data:
                                                                  gpointer);
    pub fn g_tls_database_lookup_certificates_issued_by_finish(_self:
                                                                   *mut GTlsDatabase,
                                                               result:
                                                                   *mut GAsyncResult,
                                                               error:
                                                                   *mut *mut GError)
     -> *mut GList;
    pub fn g_tls_file_database_get_type() -> GType;
    pub fn g_tls_file_database_new(anchors: *const gchar,
                                   error: *mut *mut GError)
     -> *mut GTlsDatabase;
    pub fn g_tls_interaction_get_type() -> GType;
    pub fn g_tls_interaction_invoke_ask_password(interaction:
                                                     *mut GTlsInteraction,
                                                 password: *mut GTlsPassword,
                                                 cancellable:
                                                     *mut GCancellable,
                                                 error: *mut *mut GError)
     -> GTlsInteractionResult;
    pub fn g_tls_interaction_ask_password(interaction: *mut GTlsInteraction,
                                          password: *mut GTlsPassword,
                                          cancellable: *mut GCancellable,
                                          error: *mut *mut GError)
     -> GTlsInteractionResult;
    pub fn g_tls_interaction_ask_password_async(interaction:
                                                    *mut GTlsInteraction,
                                                password: *mut GTlsPassword,
                                                cancellable:
                                                    *mut GCancellable,
                                                callback: GAsyncReadyCallback,
                                                user_data: gpointer);
    pub fn g_tls_interaction_ask_password_finish(interaction:
                                                     *mut GTlsInteraction,
                                                 result: *mut GAsyncResult,
                                                 error: *mut *mut GError)
     -> GTlsInteractionResult;
    pub fn g_tls_interaction_invoke_request_certificate(interaction:
                                                            *mut GTlsInteraction,
                                                        connection:
                                                            *mut GTlsConnection,
                                                        flags:
                                                            GTlsCertificateRequestFlags,
                                                        cancellable:
                                                            *mut GCancellable,
                                                        error:
                                                            *mut *mut GError)
     -> GTlsInteractionResult;
    pub fn g_tls_interaction_request_certificate(interaction:
                                                     *mut GTlsInteraction,
                                                 connection:
                                                     *mut GTlsConnection,
                                                 flags:
                                                     GTlsCertificateRequestFlags,
                                                 cancellable:
                                                     *mut GCancellable,
                                                 error: *mut *mut GError)
     -> GTlsInteractionResult;
    pub fn g_tls_interaction_request_certificate_async(interaction:
                                                           *mut GTlsInteraction,
                                                       connection:
                                                           *mut GTlsConnection,
                                                       flags:
                                                           GTlsCertificateRequestFlags,
                                                       cancellable:
                                                           *mut GCancellable,
                                                       callback:
                                                           GAsyncReadyCallback,
                                                       user_data: gpointer);
    pub fn g_tls_interaction_request_certificate_finish(interaction:
                                                            *mut GTlsInteraction,
                                                        result:
                                                            *mut GAsyncResult,
                                                        error:
                                                            *mut *mut GError)
     -> GTlsInteractionResult;
    pub fn g_tls_server_connection_get_type() -> GType;
    pub fn g_tls_server_connection_new(base_io_stream: *mut GIOStream,
                                       certificate: *mut GTlsCertificate,
                                       error: *mut *mut GError)
     -> *mut GIOStream;
    pub fn g_tls_password_get_type() -> GType;
    pub fn g_tls_password_new(flags: GTlsPasswordFlags,
                              description: *const gchar) -> *mut GTlsPassword;
    pub fn g_tls_password_get_value(password: *mut GTlsPassword,
                                    length: *mut gsize) -> *const guchar;
    pub fn g_tls_password_set_value(password: *mut GTlsPassword,
                                    value: *const guchar, length: gssize);
    pub fn g_tls_password_set_value_full(password: *mut GTlsPassword,
                                         value: *mut guchar, length: gssize,
                                         destroy: GDestroyNotify);
    pub fn g_tls_password_get_flags(password: *mut GTlsPassword)
     -> GTlsPasswordFlags;
    pub fn g_tls_password_set_flags(password: *mut GTlsPassword,
                                    flags: GTlsPasswordFlags);
    pub fn g_tls_password_get_description(password: *mut GTlsPassword)
     -> *const gchar;
    pub fn g_tls_password_set_description(password: *mut GTlsPassword,
                                          description: *const gchar);
    pub fn g_tls_password_get_warning(password: *mut GTlsPassword)
     -> *const gchar;
    pub fn g_tls_password_set_warning(password: *mut GTlsPassword,
                                      warning: *const gchar);
    pub fn g_vfs_get_type() -> GType;
    pub fn g_vfs_is_active(vfs: *mut GVfs) -> gboolean;
    pub fn g_vfs_get_file_for_path(vfs: *mut GVfs,
                                   path: *const ::std::os::raw::c_char)
     -> *mut GFile;
    pub fn g_vfs_get_file_for_uri(vfs: *mut GVfs,
                                  uri: *const ::std::os::raw::c_char)
     -> *mut GFile;
    pub fn g_vfs_get_supported_uri_schemes(vfs: *mut GVfs)
     -> *const *const gchar;
    pub fn g_vfs_parse_name(vfs: *mut GVfs,
                            parse_name: *const ::std::os::raw::c_char)
     -> *mut GFile;
    pub fn g_vfs_get_default() -> *mut GVfs;
    pub fn g_vfs_get_local() -> *mut GVfs;
    pub fn g_volume_get_type() -> GType;
    pub fn g_volume_get_name(volume: *mut GVolume)
     -> *mut ::std::os::raw::c_char;
    pub fn g_volume_get_icon(volume: *mut GVolume) -> *mut GIcon;
    pub fn g_volume_get_symbolic_icon(volume: *mut GVolume) -> *mut GIcon;
    pub fn g_volume_get_uuid(volume: *mut GVolume)
     -> *mut ::std::os::raw::c_char;
    pub fn g_volume_get_drive(volume: *mut GVolume) -> *mut GDrive;
    pub fn g_volume_get_mount(volume: *mut GVolume) -> *mut GMount;
    pub fn g_volume_can_mount(volume: *mut GVolume) -> gboolean;
    pub fn g_volume_can_eject(volume: *mut GVolume) -> gboolean;
    pub fn g_volume_should_automount(volume: *mut GVolume) -> gboolean;
    pub fn g_volume_mount(volume: *mut GVolume, flags: GMountMountFlags,
                          mount_operation: *mut GMountOperation,
                          cancellable: *mut GCancellable,
                          callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_volume_mount_finish(volume: *mut GVolume,
                                 result: *mut GAsyncResult,
                                 error: *mut *mut GError) -> gboolean;
    pub fn g_volume_eject(volume: *mut GVolume, flags: GMountUnmountFlags,
                          cancellable: *mut GCancellable,
                          callback: GAsyncReadyCallback, user_data: gpointer);
    pub fn g_volume_eject_finish(volume: *mut GVolume,
                                 result: *mut GAsyncResult,
                                 error: *mut *mut GError) -> gboolean;
    pub fn g_volume_get_identifier(volume: *mut GVolume,
                                   kind: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn g_volume_enumerate_identifiers(volume: *mut GVolume)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn g_volume_get_activation_root(volume: *mut GVolume) -> *mut GFile;
    pub fn g_volume_eject_with_operation(volume: *mut GVolume,
                                         flags: GMountUnmountFlags,
                                         mount_operation:
                                             *mut GMountOperation,
                                         cancellable: *mut GCancellable,
                                         callback: GAsyncReadyCallback,
                                         user_data: gpointer);
    pub fn g_volume_eject_with_operation_finish(volume: *mut GVolume,
                                                result: *mut GAsyncResult,
                                                error: *mut *mut GError)
     -> gboolean;
    pub fn g_volume_get_sort_key(volume: *mut GVolume) -> *const gchar;
    pub fn g_zlib_compressor_get_type() -> GType;
    pub fn g_zlib_compressor_new(format: GZlibCompressorFormat,
                                 level: ::std::os::raw::c_int)
     -> *mut GZlibCompressor;
    pub fn g_zlib_compressor_get_file_info(compressor: *mut GZlibCompressor)
     -> *mut GFileInfo;
    pub fn g_zlib_compressor_set_file_info(compressor: *mut GZlibCompressor,
                                           file_info: *mut GFileInfo);
    pub fn g_zlib_decompressor_get_type() -> GType;
    pub fn g_zlib_decompressor_new(format: GZlibCompressorFormat)
     -> *mut GZlibDecompressor;
    pub fn g_zlib_decompressor_get_file_info(decompressor:
                                                 *mut GZlibDecompressor)
     -> *mut GFileInfo;
    pub fn g_dbus_interface_get_type() -> GType;
    pub fn g_dbus_interface_get_info(interface_: *mut GDBusInterface)
     -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_interface_get_object(interface_: *mut GDBusInterface)
     -> *mut GDBusObject;
    pub fn g_dbus_interface_set_object(interface_: *mut GDBusInterface,
                                       object: *mut GDBusObject);
    pub fn g_dbus_interface_dup_object(interface_: *mut GDBusInterface)
     -> *mut GDBusObject;
    pub fn g_dbus_interface_skeleton_get_type() -> GType;
    pub fn g_dbus_interface_skeleton_get_flags(interface_:
                                                   *mut GDBusInterfaceSkeleton)
     -> GDBusInterfaceSkeletonFlags;
    pub fn g_dbus_interface_skeleton_set_flags(interface_:
                                                   *mut GDBusInterfaceSkeleton,
                                               flags:
                                                   GDBusInterfaceSkeletonFlags);
    pub fn g_dbus_interface_skeleton_get_info(interface_:
                                                  *mut GDBusInterfaceSkeleton)
     -> *mut GDBusInterfaceInfo;
    pub fn g_dbus_interface_skeleton_get_vtable(interface_:
                                                    *mut GDBusInterfaceSkeleton)
     -> *mut GDBusInterfaceVTable;
    pub fn g_dbus_interface_skeleton_get_properties(interface_:
                                                        *mut GDBusInterfaceSkeleton)
     -> *mut GVariant;
    pub fn g_dbus_interface_skeleton_flush(interface_:
                                               *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_interface_skeleton_export(interface_:
                                                *mut GDBusInterfaceSkeleton,
                                            connection: *mut GDBusConnection,
                                            object_path: *const gchar,
                                            error: *mut *mut GError)
     -> gboolean;
    pub fn g_dbus_interface_skeleton_unexport(interface_:
                                                  *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_interface_skeleton_unexport_from_connection(interface_:
                                                                  *mut GDBusInterfaceSkeleton,
                                                              connection:
                                                                  *mut GDBusConnection);
    pub fn g_dbus_interface_skeleton_get_connection(interface_:
                                                        *mut GDBusInterfaceSkeleton)
     -> *mut GDBusConnection;
    pub fn g_dbus_interface_skeleton_get_connections(interface_:
                                                         *mut GDBusInterfaceSkeleton)
     -> *mut GList;
    pub fn g_dbus_interface_skeleton_has_connection(interface_:
                                                        *mut GDBusInterfaceSkeleton,
                                                    connection:
                                                        *mut GDBusConnection)
     -> gboolean;
    pub fn g_dbus_interface_skeleton_get_object_path(interface_:
                                                         *mut GDBusInterfaceSkeleton)
     -> *const gchar;
    pub fn g_dbus_object_get_type() -> GType;
    pub fn g_dbus_object_get_object_path(object: *mut GDBusObject)
     -> *const gchar;
    pub fn g_dbus_object_get_interfaces(object: *mut GDBusObject)
     -> *mut GList;
    pub fn g_dbus_object_get_interface(object: *mut GDBusObject,
                                       interface_name: *const gchar)
     -> *mut GDBusInterface;
    pub fn g_dbus_object_skeleton_get_type() -> GType;
    pub fn g_dbus_object_skeleton_new(object_path: *const gchar)
     -> *mut GDBusObjectSkeleton;
    pub fn g_dbus_object_skeleton_flush(object: *mut GDBusObjectSkeleton);
    pub fn g_dbus_object_skeleton_add_interface(object:
                                                    *mut GDBusObjectSkeleton,
                                                interface_:
                                                    *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_object_skeleton_remove_interface(object:
                                                       *mut GDBusObjectSkeleton,
                                                   interface_:
                                                       *mut GDBusInterfaceSkeleton);
    pub fn g_dbus_object_skeleton_remove_interface_by_name(object:
                                                               *mut GDBusObjectSkeleton,
                                                           interface_name:
                                                               *const gchar);
    pub fn g_dbus_object_skeleton_set_object_path(object:
                                                      *mut GDBusObjectSkeleton,
                                                  object_path: *const gchar);
    pub fn g_dbus_object_proxy_get_type() -> GType;
    pub fn g_dbus_object_proxy_new(connection: *mut GDBusConnection,
                                   object_path: *const gchar)
     -> *mut GDBusObjectProxy;
    pub fn g_dbus_object_proxy_get_connection(proxy: *mut GDBusObjectProxy)
     -> *mut GDBusConnection;
    pub fn g_dbus_object_manager_get_type() -> GType;
    pub fn g_dbus_object_manager_get_object_path(manager:
                                                     *mut GDBusObjectManager)
     -> *const gchar;
    pub fn g_dbus_object_manager_get_objects(manager: *mut GDBusObjectManager)
     -> *mut GList;
    pub fn g_dbus_object_manager_get_object(manager: *mut GDBusObjectManager,
                                            object_path: *const gchar)
     -> *mut GDBusObject;
    pub fn g_dbus_object_manager_get_interface(manager:
                                                   *mut GDBusObjectManager,
                                               object_path: *const gchar,
                                               interface_name: *const gchar)
     -> *mut GDBusInterface;
    pub fn g_dbus_object_manager_client_get_type() -> GType;
    pub fn g_dbus_object_manager_client_new(connection: *mut GDBusConnection,
                                            flags:
                                                GDBusObjectManagerClientFlags,
                                            name: *const gchar,
                                            object_path: *const gchar,
                                            get_proxy_type_func:
                                                GDBusProxyTypeFunc,
                                            get_proxy_type_user_data:
                                                gpointer,
                                            get_proxy_type_destroy_notify:
                                                GDestroyNotify,
                                            cancellable: *mut GCancellable,
                                            callback: GAsyncReadyCallback,
                                            user_data: gpointer);
    pub fn g_dbus_object_manager_client_new_finish(res: *mut GAsyncResult,
                                                   error: *mut *mut GError)
     -> *mut GDBusObjectManager;
    pub fn g_dbus_object_manager_client_new_sync(connection:
                                                     *mut GDBusConnection,
                                                 flags:
                                                     GDBusObjectManagerClientFlags,
                                                 name: *const gchar,
                                                 object_path: *const gchar,
                                                 get_proxy_type_func:
                                                     GDBusProxyTypeFunc,
                                                 get_proxy_type_user_data:
                                                     gpointer,
                                                 get_proxy_type_destroy_notify:
                                                     GDestroyNotify,
                                                 cancellable:
                                                     *mut GCancellable,
                                                 error: *mut *mut GError)
     -> *mut GDBusObjectManager;
    pub fn g_dbus_object_manager_client_new_for_bus(bus_type: GBusType,
                                                    flags:
                                                        GDBusObjectManagerClientFlags,
                                                    name: *const gchar,
                                                    object_path: *const gchar,
                                                    get_proxy_type_func:
                                                        GDBusProxyTypeFunc,
                                                    get_proxy_type_user_data:
                                                        gpointer,
                                                    get_proxy_type_destroy_notify:
                                                        GDestroyNotify,
                                                    cancellable:
                                                        *mut GCancellable,
                                                    callback:
                                                        GAsyncReadyCallback,
                                                    user_data: gpointer);
    pub fn g_dbus_object_manager_client_new_for_bus_finish(res:
                                                               *mut GAsyncResult,
                                                           error:
                                                               *mut *mut GError)
     -> *mut GDBusObjectManager;
    pub fn g_dbus_object_manager_client_new_for_bus_sync(bus_type: GBusType,
                                                         flags:
                                                             GDBusObjectManagerClientFlags,
                                                         name: *const gchar,
                                                         object_path:
                                                             *const gchar,
                                                         get_proxy_type_func:
                                                             GDBusProxyTypeFunc,
                                                         get_proxy_type_user_data:
                                                             gpointer,
                                                         get_proxy_type_destroy_notify:
                                                             GDestroyNotify,
                                                         cancellable:
                                                             *mut GCancellable,
                                                         error:
                                                             *mut *mut GError)
     -> *mut GDBusObjectManager;
    pub fn g_dbus_object_manager_client_get_connection(manager:
                                                           *mut GDBusObjectManagerClient)
     -> *mut GDBusConnection;
    pub fn g_dbus_object_manager_client_get_flags(manager:
                                                      *mut GDBusObjectManagerClient)
     -> GDBusObjectManagerClientFlags;
    pub fn g_dbus_object_manager_client_get_name(manager:
                                                     *mut GDBusObjectManagerClient)
     -> *const gchar;
    pub fn g_dbus_object_manager_client_get_name_owner(manager:
                                                           *mut GDBusObjectManagerClient)
     -> *mut gchar;
    pub fn g_dbus_object_manager_server_get_type() -> GType;
    pub fn g_dbus_object_manager_server_new(object_path: *const gchar)
     -> *mut GDBusObjectManagerServer;
    pub fn g_dbus_object_manager_server_get_connection(manager:
                                                           *mut GDBusObjectManagerServer)
     -> *mut GDBusConnection;
    pub fn g_dbus_object_manager_server_set_connection(manager:
                                                           *mut GDBusObjectManagerServer,
                                                       connection:
                                                           *mut GDBusConnection);
    pub fn g_dbus_object_manager_server_export(manager:
                                                   *mut GDBusObjectManagerServer,
                                               object:
                                                   *mut GDBusObjectSkeleton);
    pub fn g_dbus_object_manager_server_export_uniquely(manager:
                                                            *mut GDBusObjectManagerServer,
                                                        object:
                                                            *mut GDBusObjectSkeleton);
    pub fn g_dbus_object_manager_server_is_exported(manager:
                                                        *mut GDBusObjectManagerServer,
                                                    object:
                                                        *mut GDBusObjectSkeleton)
     -> gboolean;
    pub fn g_dbus_object_manager_server_unexport(manager:
                                                     *mut GDBusObjectManagerServer,
                                                 object_path: *const gchar)
     -> gboolean;
    pub fn g_dbus_action_group_get_type() -> GType;
    pub fn g_dbus_action_group_get(connection: *mut GDBusConnection,
                                   bus_name: *const gchar,
                                   object_path: *const gchar)
     -> *mut GDBusActionGroup;
    pub fn g_remote_action_group_get_type() -> GType;
    pub fn g_remote_action_group_activate_action_full(remote:
                                                          *mut GRemoteActionGroup,
                                                      action_name:
                                                          *const gchar,
                                                      parameter:
                                                          *mut GVariant,
                                                      platform_data:
                                                          *mut GVariant);
    pub fn g_remote_action_group_change_action_state_full(remote:
                                                              *mut GRemoteActionGroup,
                                                          action_name:
                                                              *const gchar,
                                                          value:
                                                              *mut GVariant,
                                                          platform_data:
                                                              *mut GVariant);
    pub fn g_menu_model_get_type() -> GType;
    pub fn g_menu_model_is_mutable(model: *mut GMenuModel) -> gboolean;
    pub fn g_menu_model_get_n_items(model: *mut GMenuModel) -> gint;
    pub fn g_menu_model_iterate_item_attributes(model: *mut GMenuModel,
                                                item_index: gint)
     -> *mut GMenuAttributeIter;
    pub fn g_menu_model_get_item_attribute_value(model: *mut GMenuModel,
                                                 item_index: gint,
                                                 attribute: *const gchar,
                                                 expected_type:
                                                     *const GVariantType)
     -> *mut GVariant;
    pub fn g_menu_model_get_item_attribute(model: *mut GMenuModel,
                                           item_index: gint,
                                           attribute: *const gchar,
                                           format_string: *const gchar, ...)
     -> gboolean;
    pub fn g_menu_model_iterate_item_links(model: *mut GMenuModel,
                                           item_index: gint)
     -> *mut GMenuLinkIter;
    pub fn g_menu_model_get_item_link(model: *mut GMenuModel,
                                      item_index: gint, link: *const gchar)
     -> *mut GMenuModel;
    pub fn g_menu_model_items_changed(model: *mut GMenuModel, position: gint,
                                      removed: gint, added: gint);
    pub fn g_menu_attribute_iter_get_type() -> GType;
    pub fn g_menu_attribute_iter_get_next(iter: *mut GMenuAttributeIter,
                                          out_name: *mut *const gchar,
                                          value: *mut *mut GVariant)
     -> gboolean;
    pub fn g_menu_attribute_iter_next(iter: *mut GMenuAttributeIter)
     -> gboolean;
    pub fn g_menu_attribute_iter_get_name(iter: *mut GMenuAttributeIter)
     -> *const gchar;
    pub fn g_menu_attribute_iter_get_value(iter: *mut GMenuAttributeIter)
     -> *mut GVariant;
    pub fn g_menu_link_iter_get_type() -> GType;
    pub fn g_menu_link_iter_get_next(iter: *mut GMenuLinkIter,
                                     out_link: *mut *const gchar,
                                     value: *mut *mut GMenuModel) -> gboolean;
    pub fn g_menu_link_iter_next(iter: *mut GMenuLinkIter) -> gboolean;
    pub fn g_menu_link_iter_get_name(iter: *mut GMenuLinkIter)
     -> *const gchar;
    pub fn g_menu_link_iter_get_value(iter: *mut GMenuLinkIter)
     -> *mut GMenuModel;
    pub fn g_menu_get_type() -> GType;
    pub fn g_menu_new() -> *mut GMenu;
    pub fn g_menu_freeze(menu: *mut GMenu);
    pub fn g_menu_insert_item(menu: *mut GMenu, position: gint,
                              item: *mut GMenuItem);
    pub fn g_menu_prepend_item(menu: *mut GMenu, item: *mut GMenuItem);
    pub fn g_menu_append_item(menu: *mut GMenu, item: *mut GMenuItem);
    pub fn g_menu_remove(menu: *mut GMenu, position: gint);
    pub fn g_menu_remove_all(menu: *mut GMenu);
    pub fn g_menu_insert(menu: *mut GMenu, position: gint,
                         label: *const gchar, detailed_action: *const gchar);
    pub fn g_menu_prepend(menu: *mut GMenu, label: *const gchar,
                          detailed_action: *const gchar);
    pub fn g_menu_append(menu: *mut GMenu, label: *const gchar,
                         detailed_action: *const gchar);
    pub fn g_menu_insert_section(menu: *mut GMenu, position: gint,
                                 label: *const gchar,
                                 section: *mut GMenuModel);
    pub fn g_menu_prepend_section(menu: *mut GMenu, label: *const gchar,
                                  section: *mut GMenuModel);
    pub fn g_menu_append_section(menu: *mut GMenu, label: *const gchar,
                                 section: *mut GMenuModel);
    pub fn g_menu_insert_submenu(menu: *mut GMenu, position: gint,
                                 label: *const gchar,
                                 submenu: *mut GMenuModel);
    pub fn g_menu_prepend_submenu(menu: *mut GMenu, label: *const gchar,
                                  submenu: *mut GMenuModel);
    pub fn g_menu_append_submenu(menu: *mut GMenu, label: *const gchar,
                                 submenu: *mut GMenuModel);
    pub fn g_menu_item_get_type() -> GType;
    pub fn g_menu_item_new(label: *const gchar, detailed_action: *const gchar)
     -> *mut GMenuItem;
    pub fn g_menu_item_new_from_model(model: *mut GMenuModel,
                                      item_index: gint) -> *mut GMenuItem;
    pub fn g_menu_item_new_submenu(label: *const gchar,
                                   submenu: *mut GMenuModel)
     -> *mut GMenuItem;
    pub fn g_menu_item_new_section(label: *const gchar,
                                   section: *mut GMenuModel)
     -> *mut GMenuItem;
    pub fn g_menu_item_get_attribute_value(menu_item: *mut GMenuItem,
                                           attribute: *const gchar,
                                           expected_type: *const GVariantType)
     -> *mut GVariant;
    pub fn g_menu_item_get_attribute(menu_item: *mut GMenuItem,
                                     attribute: *const gchar,
                                     format_string: *const gchar, ...)
     -> gboolean;
    pub fn g_menu_item_get_link(menu_item: *mut GMenuItem, link: *const gchar)
     -> *mut GMenuModel;
    pub fn g_menu_item_set_attribute_value(menu_item: *mut GMenuItem,
                                           attribute: *const gchar,
                                           value: *mut GVariant);
    pub fn g_menu_item_set_attribute(menu_item: *mut GMenuItem,
                                     attribute: *const gchar,
                                     format_string: *const gchar, ...);
    pub fn g_menu_item_set_link(menu_item: *mut GMenuItem, link: *const gchar,
                                model: *mut GMenuModel);
    pub fn g_menu_item_set_label(menu_item: *mut GMenuItem,
                                 label: *const gchar);
    pub fn g_menu_item_set_submenu(menu_item: *mut GMenuItem,
                                   submenu: *mut GMenuModel);
    pub fn g_menu_item_set_section(menu_item: *mut GMenuItem,
                                   section: *mut GMenuModel);
    pub fn g_menu_item_set_action_and_target_value(menu_item: *mut GMenuItem,
                                                   action: *const gchar,
                                                   target_value:
                                                       *mut GVariant);
    pub fn g_menu_item_set_action_and_target(menu_item: *mut GMenuItem,
                                             action: *const gchar,
                                             format_string:
                                                 *const gchar, ...);
    pub fn g_menu_item_set_detailed_action(menu_item: *mut GMenuItem,
                                           detailed_action: *const gchar);
    pub fn g_menu_item_set_icon(menu_item: *mut GMenuItem, icon: *mut GIcon);
    pub fn g_dbus_connection_export_menu_model(connection:
                                                   *mut GDBusConnection,
                                               object_path: *const gchar,
                                               menu: *mut GMenuModel,
                                               error: *mut *mut GError)
     -> guint;
    pub fn g_dbus_connection_unexport_menu_model(connection:
                                                     *mut GDBusConnection,
                                                 export_id: guint);
    pub fn g_dbus_menu_model_get_type() -> GType;
    pub fn g_dbus_menu_model_get(connection: *mut GDBusConnection,
                                 bus_name: *const gchar,
                                 object_path: *const gchar)
     -> *mut GDBusMenuModel;
    pub fn g_notification_get_type() -> GType;
    pub fn g_notification_new(title: *const gchar) -> *mut GNotification;
    pub fn g_notification_set_title(notification: *mut GNotification,
                                    title: *const gchar);
    pub fn g_notification_set_body(notification: *mut GNotification,
                                   body: *const gchar);
    pub fn g_notification_set_icon(notification: *mut GNotification,
                                   icon: *mut GIcon);
    pub fn g_notification_set_urgent(notification: *mut GNotification,
                                     urgent: gboolean);
    pub fn g_notification_set_priority(notification: *mut GNotification,
                                       priority: GNotificationPriority);
    pub fn g_notification_add_button(notification: *mut GNotification,
                                     label: *const gchar,
                                     detailed_action: *const gchar);
    pub fn g_notification_add_button_with_target(notification:
                                                     *mut GNotification,
                                                 label: *const gchar,
                                                 action: *const gchar,
                                                 target_format:
                                                     *const gchar, ...);
    pub fn g_notification_add_button_with_target_value(notification:
                                                           *mut GNotification,
                                                       label: *const gchar,
                                                       action: *const gchar,
                                                       target: *mut GVariant);
    pub fn g_notification_set_default_action(notification: *mut GNotification,
                                             detailed_action: *const gchar);
    pub fn g_notification_set_default_action_and_target(notification:
                                                            *mut GNotification,
                                                        action: *const gchar,
                                                        target_format:
                                                            *const gchar, ...);
    pub fn g_notification_set_default_action_and_target_value(notification:
                                                                  *mut GNotification,
                                                              action:
                                                                  *const gchar,
                                                              target:
                                                                  *mut GVariant);
    pub fn g_list_model_get_type() -> GType;
    pub fn g_list_model_get_item_type(list: *mut GListModel) -> GType;
    pub fn g_list_model_get_n_items(list: *mut GListModel) -> guint;
    pub fn g_list_model_get_item(list: *mut GListModel, position: guint)
     -> gpointer;
    pub fn g_list_model_get_object(list: *mut GListModel, position: guint)
     -> *mut GObject;
    pub fn g_list_model_items_changed(list: *mut GListModel, position: guint,
                                      removed: guint, added: guint);
    pub fn g_list_store_get_type() -> GType;
    pub fn g_list_store_new(item_type: GType) -> *mut GListStore;
    pub fn g_list_store_insert(store: *mut GListStore, position: guint,
                               item: gpointer);
    pub fn g_list_store_insert_sorted(store: *mut GListStore, item: gpointer,
                                      compare_func: GCompareDataFunc,
                                      user_data: gpointer) -> guint;
    pub fn g_list_store_sort(store: *mut GListStore,
                             compare_func: GCompareDataFunc,
                             user_data: gpointer);
    pub fn g_list_store_append(store: *mut GListStore, item: gpointer);
    pub fn g_list_store_remove(store: *mut GListStore, position: guint);
    pub fn g_list_store_remove_all(store: *mut GListStore);
    pub fn g_list_store_splice(store: *mut GListStore, position: guint,
                               n_removals: guint, additions: *mut gpointer,
                               n_additions: guint);
    pub fn hif_error_quark() -> GQuark;
    pub fn hy_repo_create(name: *const ::std::os::raw::c_char) -> HyRepo;
    pub fn hy_repo_get_cost(repo: HyRepo) -> ::std::os::raw::c_int;
    pub fn hy_repo_get_priority(repo: HyRepo) -> ::std::os::raw::c_int;
    pub fn hy_repo_set_cost(repo: HyRepo, value: ::std::os::raw::c_int);
    pub fn hy_repo_set_priority(repo: HyRepo, value: ::std::os::raw::c_int);
    pub fn hy_repo_set_string(repo: HyRepo, which: ::std::os::raw::c_int,
                              str_val: *const ::std::os::raw::c_char);
    pub fn hy_repo_get_string(repo: HyRepo, which: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn hy_repo_free(repo: HyRepo);
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: __gnuc_va_list, arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: size_t) -> size_t;
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: size_t,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut size_t) -> *mut FILE;
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: size_t);
    pub fn setlinebuf(__stream: *mut FILE);
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: size_t,
                     __format: *const ::std::os::raw::c_char,
                     __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: __gnuc_va_list) -> ::std::os::raw::c_int;
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar() -> ::std::os::raw::c_int;
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut size_t, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut size_t, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut size_t, __stream: *mut FILE) -> __ssize_t;
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: size_t,
                 __n: size_t, __stream: *mut FILE) -> size_t;
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: size_t,
                  __n: size_t, __s: *mut FILE) -> size_t;
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: size_t,
                          __n: size_t, __stream: *mut FILE) -> size_t;
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: size_t, __n: size_t, __stream: *mut FILE)
     -> size_t;
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
    pub fn rewind(__stream: *mut FILE);
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ftello(__stream: *mut FILE) -> __off_t;
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
    pub fn clearerr(__stream: *mut FILE);
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn clearerr_unlocked(__stream: *mut FILE);
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn perror(__s: *const ::std::os::raw::c_char);
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn flockfile(__stream: *mut FILE);
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn funlockfile(__stream: *mut FILE);
    pub fn pool_str2id(pool: *mut Pool, arg1: *const ::std::os::raw::c_char,
                       arg2: ::std::os::raw::c_int) -> Id;
    pub fn pool_strn2id(pool: *mut Pool, arg1: *const ::std::os::raw::c_char,
                        arg2: ::std::os::raw::c_uint,
                        arg3: ::std::os::raw::c_int) -> Id;
    pub fn pool_rel2id(pool: *mut Pool, arg1: Id, arg2: Id,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> Id;
    pub fn pool_id2str(pool: *const Pool, arg1: Id)
     -> *const ::std::os::raw::c_char;
    pub fn pool_id2rel(pool: *const Pool, arg1: Id)
     -> *const ::std::os::raw::c_char;
    pub fn pool_id2evr(pool: *const Pool, arg1: Id)
     -> *const ::std::os::raw::c_char;
    pub fn pool_dep2str(pool: *mut Pool, arg1: Id)
     -> *const ::std::os::raw::c_char;
    pub fn pool_shrink_strings(pool: *mut Pool);
    pub fn pool_shrink_rels(pool: *mut Pool);
    pub fn pool_freeidhashes(pool: *mut Pool);
    pub fn queue_alloc_one(q: *mut Queue);
    pub fn queue_alloc_one_head(q: *mut Queue);
    pub fn queue_init(q: *mut Queue);
    pub fn queue_init_buffer(q: *mut Queue, buf: *mut Id,
                             size: ::std::os::raw::c_int);
    pub fn queue_init_clone(t: *mut Queue, s: *mut Queue);
    pub fn queue_free(q: *mut Queue);
    pub fn queue_insert(q: *mut Queue, pos: ::std::os::raw::c_int, id: Id);
    pub fn queue_insert2(q: *mut Queue, pos: ::std::os::raw::c_int, id1: Id,
                         id2: Id);
    pub fn queue_insertn(q: *mut Queue, pos: ::std::os::raw::c_int,
                         n: ::std::os::raw::c_int, elements: *mut Id);
    pub fn queue_delete(q: *mut Queue, pos: ::std::os::raw::c_int);
    pub fn queue_delete2(q: *mut Queue, pos: ::std::os::raw::c_int);
    pub fn queue_deleten(q: *mut Queue, pos: ::std::os::raw::c_int,
                         n: ::std::os::raw::c_int);
    pub fn queue_prealloc(q: *mut Queue, n: ::std::os::raw::c_int);
    pub fn solvable_lookup_type(s: *mut Solvable, keyname: Id) -> Id;
    pub fn solvable_lookup_id(s: *mut Solvable, keyname: Id) -> Id;
    pub fn solvable_lookup_num(s: *mut Solvable, keyname: Id,
                               notfound: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_ulonglong;
    pub fn solvable_lookup_sizek(s: *mut Solvable, keyname: Id,
                                 notfound: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
    pub fn solvable_lookup_str(s: *mut Solvable, keyname: Id)
     -> *const ::std::os::raw::c_char;
    pub fn solvable_lookup_str_poollang(s: *mut Solvable, keyname: Id)
     -> *const ::std::os::raw::c_char;
    pub fn solvable_lookup_str_lang(s: *mut Solvable, keyname: Id,
                                    lang: *const ::std::os::raw::c_char,
                                    usebase: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn solvable_lookup_bool(s: *mut Solvable, keyname: Id)
     -> ::std::os::raw::c_int;
    pub fn solvable_lookup_void(s: *mut Solvable, keyname: Id)
     -> ::std::os::raw::c_int;
    pub fn solvable_get_location(s: *mut Solvable,
                                 medianrp: *mut ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
    pub fn solvable_lookup_location(s: *mut Solvable,
                                    medianrp: *mut ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
    pub fn solvable_lookup_sourcepkg(s: *mut Solvable)
     -> *const ::std::os::raw::c_char;
    pub fn solvable_lookup_bin_checksum(s: *mut Solvable, keyname: Id,
                                        typep: *mut Id)
     -> *const ::std::os::raw::c_uchar;
    pub fn solvable_lookup_checksum(s: *mut Solvable, keyname: Id,
                                    typep: *mut Id)
     -> *const ::std::os::raw::c_char;
    pub fn solvable_lookup_idarray(s: *mut Solvable, keyname: Id,
                                   q: *mut Queue) -> ::std::os::raw::c_int;
    pub fn solvable_lookup_deparray(s: *mut Solvable, keyname: Id,
                                    q: *mut Queue, marker: Id)
     -> ::std::os::raw::c_int;
    pub fn solvable_set_id(s: *mut Solvable, keyname: Id, id: Id);
    pub fn solvable_set_num(s: *mut Solvable, keyname: Id,
                            num: ::std::os::raw::c_ulonglong);
    pub fn solvable_set_str(s: *mut Solvable, keyname: Id,
                            str: *const ::std::os::raw::c_char);
    pub fn solvable_set_poolstr(s: *mut Solvable, keyname: Id,
                                str: *const ::std::os::raw::c_char);
    pub fn solvable_add_poolstr_array(s: *mut Solvable, keyname: Id,
                                      str: *const ::std::os::raw::c_char);
    pub fn solvable_add_idarray(s: *mut Solvable, keyname: Id, id: Id);
    pub fn solvable_add_deparray(s: *mut Solvable, keyname: Id, dep: Id,
                                 marker: Id);
    pub fn solvable_set_idarray(s: *mut Solvable, keyname: Id, q: *mut Queue);
    pub fn solvable_set_deparray(s: *mut Solvable, keyname: Id, q: *mut Queue,
                                 marker: Id);
    pub fn solvable_unset(s: *mut Solvable, keyname: Id);
    pub fn solvable_identical(s1: *mut Solvable, s2: *mut Solvable)
     -> ::std::os::raw::c_int;
    pub fn solvable_selfprovidedep(s: *mut Solvable) -> Id;
    pub fn solvable_matchesdep(s: *mut Solvable, keyname: Id, dep: Id,
                               marker: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> size_t;
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: size_t,
                     __l: __locale_t) -> size_t;
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char) -> size_t;
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char) -> size_t;
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> size_t;
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t)
     -> size_t;
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: size_t)
     -> ::std::os::raw::c_int;
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn map_init(m: *mut Map, n: ::std::os::raw::c_int);
    pub fn map_init_clone(t: *mut Map, s: *mut Map);
    pub fn map_grow(m: *mut Map, n: ::std::os::raw::c_int);
    pub fn map_free(m: *mut Map);
    pub fn map_and(t: *mut Map, s: *mut Map);
    pub fn map_or(t: *mut Map, s: *mut Map);
    pub fn map_subtract(t: *mut Map, s: *mut Map);
    pub fn stringpool_init(ss: *mut Stringpool,
                           strs: *mut *const ::std::os::raw::c_char);
    pub fn stringpool_init_empty(ss: *mut Stringpool);
    pub fn stringpool_clone(ss: *mut Stringpool, from: *mut Stringpool);
    pub fn stringpool_free(ss: *mut Stringpool);
    pub fn stringpool_freehash(ss: *mut Stringpool);
    pub fn stringpool_str2id(ss: *mut Stringpool,
                             str: *const ::std::os::raw::c_char,
                             create: ::std::os::raw::c_int) -> Id;
    pub fn stringpool_strn2id(ss: *mut Stringpool,
                              str: *const ::std::os::raw::c_char,
                              len: ::std::os::raw::c_uint,
                              create: ::std::os::raw::c_int) -> Id;
    pub fn stringpool_shrink(ss: *mut Stringpool);
    pub fn pool_create() -> *mut Pool;
    pub fn pool_free(pool: *mut Pool);
    pub fn pool_freeallrepos(pool: *mut Pool,
                             reuseids: ::std::os::raw::c_int);
    pub fn pool_setdebuglevel(pool: *mut Pool, level: ::std::os::raw::c_int);
    pub fn pool_setdisttype(pool: *mut Pool, disttype: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pool_set_flag(pool: *mut Pool, flag: ::std::os::raw::c_int,
                         value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pool_get_flag(pool: *mut Pool, flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pool_debug(pool: *mut Pool, _type: ::std::os::raw::c_int,
                      format: *const ::std::os::raw::c_char, ...);
    pub fn pool_setdebugcallback(pool: *mut Pool,
                                 debugcallback:
                                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut Struct__Pool,
                                                                                data:
                                                                                    *mut ::std::os::raw::c_void,
                                                                                _type:
                                                                                    ::std::os::raw::c_int,
                                                                                str:
                                                                                    *const ::std::os::raw::c_char)>,
                                 debugcallbackdata:
                                     *mut ::std::os::raw::c_void);
    pub fn pool_setdebugmask(pool: *mut Pool, mask: ::std::os::raw::c_int);
    pub fn pool_setloadcallback(pool: *mut Pool,
                                cb:
                                    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut Struct__Pool,
                                                                               arg2:
                                                                                   *mut Struct__Repodata,
                                                                               arg3:
                                                                                   *mut ::std::os::raw::c_void)
                                                              ->
                                                                  ::std::os::raw::c_int>,
                                loadcbdata: *mut ::std::os::raw::c_void);
    pub fn pool_setnamespacecallback(pool: *mut Pool,
                                     cb:
                                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *mut Struct__Pool,
                                                                                    arg2:
                                                                                        *mut ::std::os::raw::c_void,
                                                                                    arg3:
                                                                                        Id,
                                                                                    arg4:
                                                                                        Id)
                                                                   -> Id>,
                                     nscbdata: *mut ::std::os::raw::c_void);
    pub fn pool_flush_namespaceproviders(pool: *mut Pool, ns: Id, evr: Id);
    pub fn pool_set_custom_vendorcheck(pool: *mut Pool,
                                       vendorcheck:
                                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                          *mut Struct__Pool,
                                                                                      arg2:
                                                                                          *mut Solvable,
                                                                                      arg3:
                                                                                          *mut Solvable)
                                                                     ->
                                                                         ::std::os::raw::c_int>);
    pub fn pool_alloctmpspace(pool: *mut Pool, len: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn pool_freetmpspace(pool: *mut Pool,
                             space: *const ::std::os::raw::c_char);
    pub fn pool_tmpjoin(pool: *mut Pool, str1: *const ::std::os::raw::c_char,
                        str2: *const ::std::os::raw::c_char,
                        str3: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn pool_tmpappend(pool: *mut Pool,
                          str1: *const ::std::os::raw::c_char,
                          str2: *const ::std::os::raw::c_char,
                          str3: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn pool_bin2hex(pool: *mut Pool, buf: *const ::std::os::raw::c_uchar,
                        len: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn pool_set_installed(pool: *mut Pool, repo: *mut Struct__Repo);
    pub fn pool_error(pool: *mut Pool, ret: ::std::os::raw::c_int,
                      format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn pool_errstr(pool: *mut Pool) -> *mut ::std::os::raw::c_char;
    pub fn pool_set_rootdir(pool: *mut Pool,
                            rootdir: *const ::std::os::raw::c_char);
    pub fn pool_get_rootdir(pool: *mut Pool) -> *const ::std::os::raw::c_char;
    pub fn pool_prepend_rootdir(pool: *mut Pool,
                                dir: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn pool_prepend_rootdir_tmp(pool: *mut Pool,
                                    dir: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn pool_add_solvable(pool: *mut Pool) -> Id;
    pub fn pool_add_solvable_block(pool: *mut Pool,
                                   count: ::std::os::raw::c_int) -> Id;
    pub fn pool_free_solvable_block(pool: *mut Pool, start: Id,
                                    count: ::std::os::raw::c_int,
                                    reuseids: ::std::os::raw::c_int);
    pub fn pool_solvable2str(pool: *mut Pool, s: *mut Solvable)
     -> *const ::std::os::raw::c_char;
    pub fn pool_set_languages(pool: *mut Pool,
                              languages: *mut *const ::std::os::raw::c_char,
                              nlanguages: ::std::os::raw::c_int);
    pub fn pool_id2langid(pool: *mut Pool, id: Id,
                          lang: *const ::std::os::raw::c_char,
                          create: ::std::os::raw::c_int) -> Id;
    pub fn solvable_trivial_installable_map(s: *mut Solvable,
                                            installedmap: *mut Map,
                                            conflictsmap: *mut Map,
                                            multiversionmap: *mut Map)
     -> ::std::os::raw::c_int;
    pub fn solvable_trivial_installable_repo(s: *mut Solvable,
                                             installed: *mut Struct__Repo,
                                             multiversionmap: *mut Map)
     -> ::std::os::raw::c_int;
    pub fn solvable_trivial_installable_queue(s: *mut Solvable,
                                              installed: *mut Queue,
                                              multiversionmap: *mut Map)
     -> ::std::os::raw::c_int;
    pub fn solvable_is_irrelevant_patch(s: *mut Solvable,
                                        installedmap: *mut Map)
     -> ::std::os::raw::c_int;
    pub fn pool_create_state_maps(pool: *mut Pool, installed: *mut Queue,
                                  installedmap: *mut Map,
                                  conflictsmap: *mut Map);
    pub fn pool_intersect_evrs(pool: *mut Pool, pflags: ::std::os::raw::c_int,
                               pevr: Id, flags: ::std::os::raw::c_int,
                               evr: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pool_match_dep(pool: *mut Pool, d1: Id, d2: Id)
     -> ::std::os::raw::c_int;
    pub fn pool_match_nevr_rel(pool: *mut Pool, s: *mut Solvable, d: Id)
     -> ::std::os::raw::c_int;
    pub fn pool_createwhatprovides(pool: *mut Pool);
    pub fn pool_addfileprovides(pool: *mut Pool);
    pub fn pool_addfileprovides_queue(pool: *mut Pool, idq: *mut Queue,
                                      idqinst: *mut Queue);
    pub fn pool_freewhatprovides(pool: *mut Pool);
    pub fn pool_queuetowhatprovides(pool: *mut Pool, q: *mut Queue) -> Id;
    pub fn pool_ids2whatprovides(pool: *mut Pool, ids: *mut Id,
                                 count: ::std::os::raw::c_int) -> Id;
    pub fn pool_searchlazywhatprovidesq(pool: *mut Pool, d: Id) -> Id;
    pub fn pool_addrelproviders(pool: *mut Pool, d: Id) -> Id;
    pub fn pool_whatmatchesdep(pool: *mut Pool, keyname: Id, dep: Id,
                               q: *mut Queue, marker: ::std::os::raw::c_int);
    pub fn pool_search(pool: *mut Pool, p: Id, key: Id,
                       _match: *const ::std::os::raw::c_char,
                       flags: ::std::os::raw::c_int,
                       callback:
                           ::std::option::Option<unsafe extern "C" fn(cbdata:
                                                                          *mut ::std::os::raw::c_void,
                                                                      s:
                                                                          *mut Solvable,
                                                                      data:
                                                                          *mut Struct__Repodata,
                                                                      key:
                                                                          *mut Struct__Repokey,
                                                                      kv:
                                                                          *mut Struct__KeyValue)
                                                     ->
                                                         ::std::os::raw::c_int>,
                       cbdata: *mut ::std::os::raw::c_void);
    pub fn pool_clear_pos(pool: *mut Pool);
    pub fn pool_calc_duchanges(pool: *mut Pool, installedmap: *mut Map,
                               mps: *mut DUChanges,
                               nmps: ::std::os::raw::c_int);
    pub fn pool_calc_installsizechange(pool: *mut Pool,
                                       installedmap: *mut Map)
     -> ::std::os::raw::c_int;
    pub fn pool_trivial_installable(pool: *mut Pool, installedmap: *mut Map,
                                    pkgs: *mut Queue, res: *mut Queue);
    pub fn pool_trivial_installable_multiversionmap(pool: *mut Pool,
                                                    installedmap: *mut Map,
                                                    pkgs: *mut Queue,
                                                    res: *mut Queue,
                                                    multiversionmap:
                                                        *mut Map);
    pub fn pool_lookup_str(pool: *mut Pool, entry: Id, keyname: Id)
     -> *const ::std::os::raw::c_char;
    pub fn pool_lookup_id(pool: *mut Pool, entry: Id, keyname: Id) -> Id;
    pub fn pool_lookup_num(pool: *mut Pool, entry: Id, keyname: Id,
                           notfound: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_ulonglong;
    pub fn pool_lookup_void(pool: *mut Pool, entry: Id, keyname: Id)
     -> ::std::os::raw::c_int;
    pub fn pool_lookup_bin_checksum(pool: *mut Pool, entry: Id, keyname: Id,
                                    typep: *mut Id)
     -> *const ::std::os::raw::c_uchar;
    pub fn pool_lookup_idarray(pool: *mut Pool, entry: Id, keyname: Id,
                               q: *mut Queue) -> ::std::os::raw::c_int;
    pub fn pool_lookup_checksum(pool: *mut Pool, entry: Id, keyname: Id,
                                typep: *mut Id)
     -> *const ::std::os::raw::c_char;
    pub fn pool_lookup_deltalocation(pool: *mut Pool, entry: Id,
                                     medianrp: *mut ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
    pub fn pool_add_fileconflicts_deps(pool: *mut Pool,
                                       conflicts: *mut Queue);
    pub fn hif_packagedelta_get_type() -> GType;
    pub fn hif_packagedelta_get_location(delta: *mut HifPackageDelta)
     -> *const ::std::os::raw::c_char;
    pub fn hif_packagedelta_get_baseurl(delta: *mut HifPackageDelta)
     -> *const ::std::os::raw::c_char;
    pub fn hif_packagedelta_get_downloadsize(delta: *mut HifPackageDelta)
     -> guint64;
    pub fn hif_packagedelta_get_chksum(delta: *mut HifPackageDelta,
                                       _type: *mut ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_uchar;
    pub fn hif_package_get_type() -> GType;
    pub fn hif_package_get_identical(pkg1: *mut HifPackage,
                                     pkg2: *mut HifPackage) -> gboolean;
    pub fn hif_package_installed(pkg: *mut HifPackage) -> gboolean;
    pub fn hif_package_cmp(pkg1: *mut HifPackage, pkg2: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hif_package_evr_cmp(pkg1: *mut HifPackage, pkg2: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hif_package_get_location(pkg: *mut HifPackage)
     -> *mut ::std::os::raw::c_char;
    pub fn hif_package_get_baseurl(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_nevra(pkg: *mut HifPackage)
     -> *mut ::std::os::raw::c_char;
    pub fn hif_package_get_sourcerpm(pkg: *mut HifPackage)
     -> *mut ::std::os::raw::c_char;
    pub fn hif_package_get_version(pkg: *mut HifPackage)
     -> *mut ::std::os::raw::c_char;
    pub fn hif_package_get_release(pkg: *mut HifPackage)
     -> *mut ::std::os::raw::c_char;
    pub fn hif_package_get_name(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_arch(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_chksum(pkg: *mut HifPackage,
                                  _type: *mut ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_uchar;
    pub fn hif_package_get_description(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_evr(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_group(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_license(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_hdr_chksum(pkg: *mut HifPackage,
                                      _type: *mut ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_uchar;
    pub fn hif_package_get_packager(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_reponame(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_summary(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_url(pkg: *mut HifPackage)
     -> *const ::std::os::raw::c_char;
    pub fn hif_package_get_downloadsize(pkg: *mut HifPackage) -> guint64;
    pub fn hif_package_get_epoch(pkg: *mut HifPackage) -> guint64;
    pub fn hif_package_get_hdr_end(pkg: *mut HifPackage) -> guint64;
    pub fn hif_package_get_installsize(pkg: *mut HifPackage) -> guint64;
    pub fn hif_package_get_medianr(pkg: *mut HifPackage) -> guint64;
    pub fn hif_package_get_rpmdbid(pkg: *mut HifPackage) -> guint64;
    pub fn hif_package_get_size(pkg: *mut HifPackage) -> guint64;
    pub fn hif_package_get_buildtime(pkg: *mut HifPackage) -> guint64;
    pub fn hif_package_get_installtime(pkg: *mut HifPackage) -> guint64;
    pub fn hif_package_get_conflicts(pkg: *mut HifPackage) -> HyReldepList;
    pub fn hif_package_get_enhances(pkg: *mut HifPackage) -> HyReldepList;
    pub fn hif_package_get_obsoletes(pkg: *mut HifPackage) -> HyReldepList;
    pub fn hif_package_get_provides(pkg: *mut HifPackage) -> HyReldepList;
    pub fn hif_package_get_recommends(pkg: *mut HifPackage) -> HyReldepList;
    pub fn hif_package_get_requires(pkg: *mut HifPackage) -> HyReldepList;
    pub fn hif_package_get_suggests(pkg: *mut HifPackage) -> HyReldepList;
    pub fn hif_package_get_supplements(pkg: *mut HifPackage) -> HyReldepList;
    pub fn hif_package_get_files(pkg: *mut HifPackage)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn hif_package_get_advisories(pkg: *mut HifPackage,
                                      cmp_type: ::std::os::raw::c_int)
     -> *mut GPtrArray;
    pub fn hif_package_get_delta_from_evr(pkg: *mut HifPackage,
                                          from_evr:
                                              *const ::std::os::raw::c_char)
     -> *mut HifPackageDelta;
    pub fn hif_lock_get_type() -> GType;
    pub fn hif_lock_new() -> *mut HifLock;
    pub fn hif_lock_get_state(lock: *mut HifLock) -> guint;
    pub fn hif_lock_set_lock_dir(lock: *mut HifLock, lock_dir: *const gchar);
    pub fn hif_lock_take(lock: *mut HifLock, _type: HifLockType,
                         mode: HifLockMode, error: *mut *mut GError) -> guint;
    pub fn hif_lock_release(lock: *mut HifLock, id: guint,
                            error: *mut *mut GError) -> gboolean;
    pub fn hif_lock_release_noerror(lock: *mut HifLock, id: guint);
    pub fn hif_lock_type_to_string(lock_type: HifLockType) -> *const gchar;
    pub fn hif_state_get_type() -> GType;
    pub fn hif_state_new() -> *mut HifState;
    pub fn hif_state_get_percentage(state: *mut HifState) -> guint;
    pub fn hif_state_get_action(state: *mut HifState) -> HifStateAction;
    pub fn hif_state_get_action_hint(state: *mut HifState) -> *const gchar;
    pub fn hif_state_get_cancellable(state: *mut HifState)
     -> *mut GCancellable;
    pub fn hif_state_get_allow_cancel(state: *mut HifState) -> gboolean;
    pub fn hif_state_get_speed(state: *mut HifState) -> guint64;
    pub fn hif_state_set_cancellable(state: *mut HifState,
                                     cancellable: *mut GCancellable);
    pub fn hif_state_set_allow_cancel(state: *mut HifState,
                                      allow_cancel: gboolean);
    pub fn hif_state_set_speed(state: *mut HifState, speed: guint64);
    pub fn hif_state_set_report_progress(state: *mut HifState,
                                         report_progress: gboolean);
    pub fn hif_state_set_number_steps_real(state: *mut HifState, steps: guint,
                                           strloc: *const gchar) -> gboolean;
    pub fn hif_state_set_steps_real(state: *mut HifState,
                                    error: *mut *mut GError,
                                    strloc: *const gchar, value: gint, ...)
     -> gboolean;
    pub fn hif_state_set_percentage(state: *mut HifState, percentage: guint)
     -> gboolean;
    pub fn hif_state_set_package_progress(state: *mut HifState,
                                          hif_package_get_id: *const gchar,
                                          action: HifStateAction,
                                          percentage: guint);
    pub fn hif_state_get_child(state: *mut HifState) -> *mut HifState;
    pub fn hif_state_action_start(state: *mut HifState,
                                  action: HifStateAction,
                                  action_hint: *const gchar) -> gboolean;
    pub fn hif_state_action_stop(state: *mut HifState) -> gboolean;
    pub fn hif_state_check(state: *mut HifState, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_state_done_real(state: *mut HifState, error: *mut *mut GError,
                               strloc: *const gchar) -> gboolean;
    pub fn hif_state_finished_real(state: *mut HifState,
                                   error: *mut *mut GError,
                                   strloc: *const gchar) -> gboolean;
    pub fn hif_state_reset(state: *mut HifState) -> gboolean;
    pub fn hif_state_set_enable_profile(state: *mut HifState,
                                        enable_profile: gboolean);
    pub fn hif_state_take_lock(state: *mut HifState, lock_type: HifLockType,
                               lock_mode: HifLockMode,
                               error: *mut *mut GError) -> gboolean;
    pub fn hif_state_release_locks(state: *mut HifState) -> gboolean;
    pub fn lr_checksum_type(_type: *const ::std::os::raw::c_char)
     -> LrChecksumType;
    pub fn lr_checksum_type_to_str(_type: LrChecksumType)
     -> *const ::std::os::raw::c_char;
    pub fn lr_checksum_fd(_type: LrChecksumType, fd: ::std::os::raw::c_int,
                          err: *mut *mut GError)
     -> *mut ::std::os::raw::c_char;
    pub fn lr_checksum_fd_cmp(_type: LrChecksumType,
                              fd: ::std::os::raw::c_int,
                              expected: *const ::std::os::raw::c_char,
                              caching: gboolean, matches: *mut gboolean,
                              err: *mut *mut GError) -> gboolean;
    pub fn lr_checksum_fd_compare(_type: LrChecksumType,
                                  fd: ::std::os::raw::c_int,
                                  expected: *const ::std::os::raw::c_char,
                                  caching: gboolean, matches: *mut gboolean,
                                  calculated: *mut *mut gchar,
                                  err: *mut *mut GError) -> gboolean;
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const Struct_iovec,
                 __count: ::std::os::raw::c_int) -> ssize_t;
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const Struct_iovec,
                  __count: ::std::os::raw::c_int) -> ssize_t;
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const Struct_iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t)
     -> ssize_t;
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const Struct_iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> ssize_t;
    pub fn __cmsg_nxthdr(__mhdr: *mut Struct_msghdr,
                         __cmsg: *mut Struct_cmsghdr) -> *mut Struct_cmsghdr;
    pub fn socket(__domain: ::std::os::raw::c_int,
                  __type: ::std::os::raw::c_int,
                  __protocol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn socketpair(__domain: ::std::os::raw::c_int,
                      __type: ::std::os::raw::c_int,
                      __protocol: ::std::os::raw::c_int,
                      __fds: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn bind(__fd: ::std::os::raw::c_int, __addr: *const Struct_sockaddr,
                __len: socklen_t) -> ::std::os::raw::c_int;
    pub fn getsockname(__fd: ::std::os::raw::c_int,
                       __addr: *mut Struct_sockaddr, __len: *mut socklen_t)
     -> ::std::os::raw::c_int;
    pub fn connect(__fd: ::std::os::raw::c_int,
                   __addr: *const Struct_sockaddr, __len: socklen_t)
     -> ::std::os::raw::c_int;
    pub fn getpeername(__fd: ::std::os::raw::c_int,
                       __addr: *mut Struct_sockaddr, __len: *mut socklen_t)
     -> ::std::os::raw::c_int;
    pub fn send(__fd: ::std::os::raw::c_int,
                __buf: *const ::std::os::raw::c_void, __n: size_t,
                __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn recv(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __n: size_t,
                __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn sendto(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: size_t,
                  __flags: ::std::os::raw::c_int,
                  __addr: *const Struct_sockaddr, __addr_len: socklen_t)
     -> ssize_t;
    pub fn recvfrom(__fd: ::std::os::raw::c_int,
                    __buf: *mut ::std::os::raw::c_void, __n: size_t,
                    __flags: ::std::os::raw::c_int,
                    __addr: *mut Struct_sockaddr, __addr_len: *mut socklen_t)
     -> ssize_t;
    pub fn sendmsg(__fd: ::std::os::raw::c_int,
                   __message: *const Struct_msghdr,
                   __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn recvmsg(__fd: ::std::os::raw::c_int, __message: *mut Struct_msghdr,
                   __flags: ::std::os::raw::c_int) -> ssize_t;
    pub fn getsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *mut ::std::os::raw::c_void,
                      __optlen: *mut socklen_t) -> ::std::os::raw::c_int;
    pub fn setsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *const ::std::os::raw::c_void,
                      __optlen: socklen_t) -> ::std::os::raw::c_int;
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn accept(__fd: ::std::os::raw::c_int, __addr: *mut Struct_sockaddr,
                  __addr_len: *mut socklen_t) -> ::std::os::raw::c_int;
    pub fn shutdown(__fd: ::std::os::raw::c_int, __how: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isfdtype(__fd: ::std::os::raw::c_int,
                    __fdtype: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn gettimeofday(__tv: *mut Struct_timeval, __tz: __timezone_ptr_t)
     -> ::std::os::raw::c_int;
    pub fn settimeofday(__tv: *const Struct_timeval,
                        __tz: *const Struct_timezone)
     -> ::std::os::raw::c_int;
    pub fn adjtime(__delta: *const Struct_timeval,
                   __olddelta: *mut Struct_timeval) -> ::std::os::raw::c_int;
    pub fn getitimer(__which: __itimer_which_t,
                     __value: *mut Struct_itimerval) -> ::std::os::raw::c_int;
    pub fn setitimer(__which: __itimer_which_t,
                     __new: *const Struct_itimerval,
                     __old: *mut Struct_itimerval) -> ::std::os::raw::c_int;
    pub fn utimes(__file: *const ::std::os::raw::c_char,
                  __tvp: *mut Struct_timeval) -> ::std::os::raw::c_int;
    pub fn lutimes(__file: *const ::std::os::raw::c_char,
                   __tvp: *mut Struct_timeval) -> ::std::os::raw::c_int;
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *mut Struct_timeval)
     -> ::std::os::raw::c_int;
    pub fn curl_strequal(s1: *const ::std::os::raw::c_char,
                         s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn curl_strnequal(s1: *const ::std::os::raw::c_char,
                          s2: *const ::std::os::raw::c_char, n: size_t)
     -> ::std::os::raw::c_int;
    pub fn curl_formadd(httppost: *mut *mut Struct_curl_httppost,
                        last_post: *mut *mut Struct_curl_httppost, ...)
     -> CURLFORMcode;
    pub fn curl_formget(form: *mut Struct_curl_httppost,
                        arg: *mut ::std::os::raw::c_void,
                        append: curl_formget_callback)
     -> ::std::os::raw::c_int;
    pub fn curl_formfree(form: *mut Struct_curl_httppost);
    pub fn curl_getenv(variable: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn curl_version() -> *mut ::std::os::raw::c_char;
    pub fn curl_easy_escape(handle: *mut CURL,
                            string: *const ::std::os::raw::c_char,
                            length: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn curl_escape(string: *const ::std::os::raw::c_char,
                       length: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn curl_easy_unescape(handle: *mut CURL,
                              string: *const ::std::os::raw::c_char,
                              length: ::std::os::raw::c_int,
                              outlength: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn curl_unescape(string: *const ::std::os::raw::c_char,
                         length: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn curl_free(p: *mut ::std::os::raw::c_void);
    pub fn curl_global_init(flags: ::std::os::raw::c_long) -> CURLcode;
    pub fn curl_global_init_mem(flags: ::std::os::raw::c_long,
                                m: curl_malloc_callback,
                                f: curl_free_callback,
                                r: curl_realloc_callback,
                                s: curl_strdup_callback,
                                c: curl_calloc_callback) -> CURLcode;
    pub fn curl_global_cleanup();
    pub fn curl_slist_append(arg1: *mut Struct_curl_slist,
                             arg2: *const ::std::os::raw::c_char)
     -> *mut Struct_curl_slist;
    pub fn curl_slist_free_all(arg1: *mut Struct_curl_slist);
    pub fn curl_getdate(p: *const ::std::os::raw::c_char,
                        unused: *const time_t) -> time_t;
    pub fn curl_share_init() -> *mut CURLSH;
    pub fn curl_share_setopt(arg1: *mut CURLSH, option: CURLSHoption, ...)
     -> CURLSHcode;
    pub fn curl_share_cleanup(arg1: *mut CURLSH) -> CURLSHcode;
    pub fn curl_version_info(arg1: CURLversion)
     -> *mut curl_version_info_data;
    pub fn curl_easy_strerror(arg1: CURLcode)
     -> *const ::std::os::raw::c_char;
    pub fn curl_share_strerror(arg1: CURLSHcode)
     -> *const ::std::os::raw::c_char;
    pub fn curl_easy_pause(handle: *mut CURL, bitmask: ::std::os::raw::c_int)
     -> CURLcode;
    pub fn curl_easy_init() -> *mut CURL;
    pub fn curl_easy_setopt(curl: *mut CURL, option: CURLoption, ...)
     -> CURLcode;
    pub fn curl_easy_perform(curl: *mut CURL) -> CURLcode;
    pub fn curl_easy_cleanup(curl: *mut CURL);
    pub fn curl_easy_getinfo(curl: *mut CURL, info: CURLINFO, ...)
     -> CURLcode;
    pub fn curl_easy_duphandle(curl: *mut CURL) -> *mut CURL;
    pub fn curl_easy_reset(curl: *mut CURL);
    pub fn curl_easy_recv(curl: *mut CURL,
                          buffer: *mut ::std::os::raw::c_void, buflen: size_t,
                          n: *mut size_t) -> CURLcode;
    pub fn curl_easy_send(curl: *mut CURL,
                          buffer: *const ::std::os::raw::c_void,
                          buflen: size_t, n: *mut size_t) -> CURLcode;
    pub fn curl_multi_init() -> *mut CURLM;
    pub fn curl_multi_add_handle(multi_handle: *mut CURLM,
                                 curl_handle: *mut CURL) -> CURLMcode;
    pub fn curl_multi_remove_handle(multi_handle: *mut CURLM,
                                    curl_handle: *mut CURL) -> CURLMcode;
    pub fn curl_multi_fdset(multi_handle: *mut CURLM,
                            read_fd_set: *mut fd_set,
                            write_fd_set: *mut fd_set,
                            exc_fd_set: *mut fd_set,
                            max_fd: *mut ::std::os::raw::c_int) -> CURLMcode;
    pub fn curl_multi_wait(multi_handle: *mut CURLM,
                           extra_fds: *mut Struct_curl_waitfd,
                           extra_nfds: ::std::os::raw::c_uint,
                           timeout_ms: ::std::os::raw::c_int,
                           ret: *mut ::std::os::raw::c_int) -> CURLMcode;
    pub fn curl_multi_perform(multi_handle: *mut CURLM,
                              running_handles: *mut ::std::os::raw::c_int)
     -> CURLMcode;
    pub fn curl_multi_cleanup(multi_handle: *mut CURLM) -> CURLMcode;
    pub fn curl_multi_info_read(multi_handle: *mut CURLM,
                                msgs_in_queue: *mut ::std::os::raw::c_int)
     -> *mut CURLMsg;
    pub fn curl_multi_strerror(arg1: CURLMcode)
     -> *const ::std::os::raw::c_char;
    pub fn curl_multi_socket(multi_handle: *mut CURLM, s: curl_socket_t,
                             running_handles: *mut ::std::os::raw::c_int)
     -> CURLMcode;
    pub fn curl_multi_socket_action(multi_handle: *mut CURLM,
                                    s: curl_socket_t,
                                    ev_bitmask: ::std::os::raw::c_int,
                                    running_handles:
                                        *mut ::std::os::raw::c_int)
     -> CURLMcode;
    pub fn curl_multi_socket_all(multi_handle: *mut CURLM,
                                 running_handles: *mut ::std::os::raw::c_int)
     -> CURLMcode;
    pub fn curl_multi_timeout(multi_handle: *mut CURLM,
                              milliseconds: *mut ::std::os::raw::c_long)
     -> CURLMcode;
    pub fn curl_multi_setopt(multi_handle: *mut CURLM,
                             option: CURLMoption, ...) -> CURLMcode;
    pub fn curl_multi_assign(multi_handle: *mut CURLM, sockfd: curl_socket_t,
                             sockp: *mut ::std::os::raw::c_void) -> CURLMcode;
    pub fn __ctype_get_mb_cur_max() -> size_t;
    pub fn atof(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_float;
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    pub fn random() -> ::std::os::raw::c_long;
    pub fn srandom(__seed: ::std::os::raw::c_uint);
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: size_t) -> *mut ::std::os::raw::c_char;
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn random_r(__buf: *mut Struct_random_data, __result: *mut int32_t)
     -> ::std::os::raw::c_int;
    pub fn srandom_r(__seed: ::std::os::raw::c_uint,
                     __buf: *mut Struct_random_data) -> ::std::os::raw::c_int;
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: size_t, __buf: *mut Struct_random_data)
     -> ::std::os::raw::c_int;
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut Struct_random_data)
     -> ::std::os::raw::c_int;
    pub fn rand() -> ::std::os::raw::c_int;
    pub fn srand(__seed: ::std::os::raw::c_uint);
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn drand48() -> ::std::os::raw::c_double;
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_double;
    pub fn lrand48() -> ::std::os::raw::c_long;
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn mrand48() -> ::std::os::raw::c_long;
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn srand48(__seedval: ::std::os::raw::c_long);
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
    pub fn drand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn lrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn mrand48_r(__buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut Struct_drand48_data)
     -> ::std::os::raw::c_int;
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut Struct_drand48_data)
     -> ::std::os::raw::c_int;
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut Struct_drand48_data)
     -> ::std::os::raw::c_int;
    pub fn malloc(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn calloc(__nmemb: size_t, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
    pub fn alloca(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: size_t, __size: size_t)
     -> ::std::os::raw::c_int;
    pub fn aligned_alloc(__alignment: size_t, __size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn abort();
    pub fn atexit(__func: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn at_quick_exit(__func: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn exit(__status: ::std::os::raw::c_int);
    pub fn quick_exit(__status: ::std::os::raw::c_int);
    pub fn _Exit(__status: ::std::os::raw::c_int);
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn clearenv() -> ::std::os::raw::c_int;
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: size_t,
                   __size: size_t, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: size_t,
                 __size: size_t, __compar: __compar_fn_t);
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
    pub fn ecvt(__value: ::std::os::raw::c_double,
                __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn fcvt(__value: ::std::os::raw::c_double,
                __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn gcvt(__value: ::std::os::raw::c_double,
                __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn qecvt(__value: ::std::os::raw::c_double,
                 __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn qfcvt(__value: ::std::os::raw::c_double,
                 __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn qgcvt(__value: ::std::os::raw::c_double,
                 __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn ecvt_r(__value: ::std::os::raw::c_double,
                  __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn fcvt_r(__value: ::std::os::raw::c_double,
                  __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn qecvt_r(__value: ::std::os::raw::c_double,
                   __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn qfcvt_r(__value: ::std::os::raw::c_double,
                   __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: size_t)
     -> ::std::os::raw::c_int;
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t)
     -> ::std::os::raw::c_int;
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: size_t) -> ::std::os::raw::c_int;
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: size_t) -> size_t;
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: size_t) -> size_t;
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *mut ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getloadavg(__loadavg: *mut ::std::os::raw::c_double,
                      __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn lr_urlvars_set(list: *mut LrUrlVars,
                          var: *const ::std::os::raw::c_char,
                          value: *const ::std::os::raw::c_char)
     -> *mut LrUrlVars;
    pub fn lr_urlvars_free(list: *mut LrUrlVars);
    pub fn lr_url_substitute(url: *const ::std::os::raw::c_char,
                             list: *mut LrUrlVars)
     -> *mut ::std::os::raw::c_char;
    pub fn lr_mirrorlist_init() -> *mut LrMirrorlist;
    pub fn lr_mirrorlist_parse_file(mirrorlist: *mut LrMirrorlist,
                                    fd: ::std::os::raw::c_int,
                                    err: *mut *mut GError) -> gboolean;
    pub fn lr_mirrorlist_free(mirrorlist: *mut LrMirrorlist);
    pub fn lr_metalink_init() -> *mut LrMetalink;
    pub fn lr_metalink_parse_file(metalink: *mut LrMetalink,
                                  fd: ::std::os::raw::c_int,
                                  filename: *const ::std::os::raw::c_char,
                                  warningcb: LrXmlParserWarningCb,
                                  warningcb_data: *mut ::std::os::raw::c_void,
                                  err: *mut *mut GError) -> gboolean;
    pub fn lr_metalink_free(metalink: *mut LrMetalink);
    pub fn lr_result_init() -> *mut LrResult;
    pub fn lr_result_clear(result: *mut LrResult);
    pub fn lr_result_free(result: *mut LrResult);
    pub fn lr_result_getinfo(result: *mut LrResult, err: *mut *mut GError,
                             option: LrResultInfoOption, ...) -> gboolean;
    pub fn lr_handle_init() -> *mut LrHandle;
    pub fn lr_handle_free(handle: *mut LrHandle);
    pub fn lr_handle_setopt(handle: *mut LrHandle, err: *mut *mut GError,
                            option: LrHandleOption, ...) -> gboolean;
    pub fn lr_handle_getinfo(handle: *mut LrHandle, err: *mut *mut GError,
                             option: LrHandleInfoOption, ...) -> gboolean;
    pub fn lr_handle_perform(handle: *mut LrHandle, result: *mut LrResult,
                             err: *mut *mut GError) -> gboolean;
    pub fn lr_lrfastestmirror_free(mirror: *mut LrFastestMirror);
    pub fn lr_fastestmirror(handle: *mut LrHandle, list: *mut *mut GSList,
                            err: *mut *mut GError) -> gboolean;
    pub fn lr_fastestmirror_detailed(handle: *mut LrHandle,
                                     inlist: *mut GSList,
                                     outlist: *mut *mut GSList,
                                     err: *mut *mut GError) -> gboolean;
    pub fn lr_gpg_check_signature_fd(signature_fd: ::std::os::raw::c_int,
                                     data_fd: ::std::os::raw::c_int,
                                     home_dir: *const ::std::os::raw::c_char,
                                     err: *mut *mut GError) -> gboolean;
    pub fn lr_gpg_check_signature(signature_fn: *const ::std::os::raw::c_char,
                                  data_fn: *const ::std::os::raw::c_char,
                                  home_dir: *const ::std::os::raw::c_char,
                                  err: *mut *mut GError) -> gboolean;
    pub fn lr_gpg_import_key(key_fn: *const ::std::os::raw::c_char,
                             home_dir: *const ::std::os::raw::c_char,
                             err: *mut *mut GError) -> gboolean;
    pub fn lr_strerror(rc: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn lr_checksum_error_quark() -> GQuark;
    pub fn lr_downloader_error_quark() -> GQuark;
    pub fn lr_fastestmirror_error_quark() -> GQuark;
    pub fn lr_gpg_error_quark() -> GQuark;
    pub fn lr_handle_error_quark() -> GQuark;
    pub fn lr_metalink_error_quark() -> GQuark;
    pub fn lr_mirrorlist_error_quark() -> GQuark;
    pub fn lr_package_downloader_error_quark() -> GQuark;
    pub fn lr_repoconf_error_quark() -> GQuark;
    pub fn lr_repomd_error_quark() -> GQuark;
    pub fn lr_repoutil_yum_error_quark() -> GQuark;
    pub fn lr_result_error_quark() -> GQuark;
    pub fn lr_xml_parser_error_quark() -> GQuark;
    pub fn lr_yum_error_quark() -> GQuark;
    pub fn lr_download_package(handle: *mut LrHandle,
                               relative_url: *const ::std::os::raw::c_char,
                               dest: *const ::std::os::raw::c_char,
                               checksum_type: LrChecksumType,
                               checksum: *const ::std::os::raw::c_char,
                               expectedsize: gint64,
                               base_url: *const ::std::os::raw::c_char,
                               resume: gboolean, err: *mut *mut GError)
     -> gboolean;
    pub fn lr_packagetarget_new(handle: *mut LrHandle,
                                relative_url: *const ::std::os::raw::c_char,
                                dest: *const ::std::os::raw::c_char,
                                checksum_type: LrChecksumType,
                                checksum: *const ::std::os::raw::c_char,
                                expectedsize: gint64,
                                base_url: *const ::std::os::raw::c_char,
                                resume: gboolean, progresscb: LrProgressCb,
                                cbdata: *mut ::std::os::raw::c_void,
                                err: *mut *mut GError)
     -> *mut LrPackageTarget;
    pub fn lr_packagetarget_new_v2(handle: *mut LrHandle,
                                   relative_url:
                                       *const ::std::os::raw::c_char,
                                   dest: *const ::std::os::raw::c_char,
                                   checksum_type: LrChecksumType,
                                   checksum: *const ::std::os::raw::c_char,
                                   expectedsize: gint64,
                                   base_url: *const ::std::os::raw::c_char,
                                   resume: gboolean, progresscb: LrProgressCb,
                                   cbdata: *mut ::std::os::raw::c_void,
                                   endcb: LrEndCb,
                                   mirrorfailurecb: LrMirrorFailureCb,
                                   err: *mut *mut GError)
     -> *mut LrPackageTarget;
    pub fn lr_packagetarget_new_v3(handle: *mut LrHandle,
                                   relative_url:
                                       *const ::std::os::raw::c_char,
                                   dest: *const ::std::os::raw::c_char,
                                   checksum_type: LrChecksumType,
                                   checksum: *const ::std::os::raw::c_char,
                                   expectedsize: gint64,
                                   base_url: *const ::std::os::raw::c_char,
                                   resume: gboolean, progresscb: LrProgressCb,
                                   cbdata: *mut ::std::os::raw::c_void,
                                   endcb: LrEndCb,
                                   mirrorfailurecb: LrMirrorFailureCb,
                                   byterangestart: gint64,
                                   byterangeend: gint64,
                                   err: *mut *mut GError)
     -> *mut LrPackageTarget;
    pub fn lr_packagetarget_free(target: *mut LrPackageTarget);
    pub fn lr_download_packages(targets: *mut GSList,
                                flags: LrPackageDownloadFlag,
                                err: *mut *mut GError) -> gboolean;
    pub fn lr_check_packages(targets: *mut GSList, flags: LrPackageCheckFlag,
                             err: *mut *mut GError) -> gboolean;
    pub fn lr_yum_repoconfs_init() -> *mut LrYumRepoConfs;
    pub fn lr_yum_repoconfs_free(confs: *mut LrYumRepoConfs);
    pub fn lr_yum_repoconfs_get_list(confs: *mut LrYumRepoConfs,
                                     err: *mut *mut GError) -> *mut GSList;
    pub fn lr_yum_repoconfs_add_empty_conf(confs: *mut LrYumRepoConfs,
                                           filename:
                                               *const ::std::os::raw::c_char,
                                           ids:
                                               *mut *const ::std::os::raw::c_char,
                                           err: *mut *mut GError) -> gboolean;
    pub fn lr_yum_repoconfs_parse(confs: *mut LrYumRepoConfs,
                                  filename: *const ::std::os::raw::c_char,
                                  err: *mut *mut GError) -> gboolean;
    pub fn lr_yum_repoconfs_load_dir(confs: *mut LrYumRepoConfs,
                                     path: *const ::std::os::raw::c_char,
                                     err: *mut *mut GError) -> gboolean;
    pub fn lr_yum_repoconfs_save(confs: *mut LrYumRepoConfs,
                                 err: *mut *mut GError) -> gboolean;
    pub fn lr_yum_repoconf_save(repoconf: *mut LrYumRepoConf,
                                err: *mut *mut GError) -> gboolean;
    pub fn lr_yum_repoconf_getinfo(repoconf: *mut LrYumRepoConf,
                                   err: *mut *mut GError,
                                   option: LrYumRepoConfOption, ...)
     -> gboolean;
    pub fn lr_yum_repoconf_setopt(repoconf: *mut LrYumRepoConf,
                                  err: *mut *mut GError,
                                  option: LrYumRepoConfOption, ...)
     -> gboolean;
    pub fn lr_yum_repomd_init() -> *mut LrYumRepoMd;
    pub fn lr_yum_repomd_free(repomd: *mut LrYumRepoMd);
    pub fn lr_yum_repomd_parse_file(repomd: *mut LrYumRepoMd,
                                    fd: ::std::os::raw::c_int,
                                    warningcb: LrXmlParserWarningCb,
                                    warningcb_data:
                                        *mut ::std::os::raw::c_void,
                                    err: *mut *mut GError) -> gboolean;
    pub fn lr_yum_repomd_get_record(repomd: *mut LrYumRepoMd,
                                    _type: *const ::std::os::raw::c_char)
     -> *mut LrYumRepoMdRecord;
    pub fn lr_yum_repomd_get_highest_timestamp(repomd: *mut LrYumRepoMd,
                                               err: *mut *mut GError)
     -> gint64;
    pub fn lr_repoutil_yum_check_repo(path: *const ::std::os::raw::c_char,
                                      err: *mut *mut GError) -> gboolean;
    pub fn lr_repoutil_yum_parse_repomd(path: *const ::std::os::raw::c_char,
                                        repomd: *mut LrYumRepoMd,
                                        err: *mut *mut GError) -> gboolean;
    pub fn lr_yum_repomd_get_age(result: *mut LrResult)
     -> ::std::os::raw::c_double;
    pub fn lr_global_init();
    pub fn lr_out_of_memory();
    pub fn lr_malloc(len: size_t) -> *mut ::std::os::raw::c_void;
    pub fn lr_malloc0(len: size_t) -> *mut ::std::os::raw::c_void;
    pub fn lr_realloc(ptr: *mut ::std::os::raw::c_void, len: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn lr_free(mem: *mut ::std::os::raw::c_void);
    pub fn lr_gettmpfile() -> ::std::os::raw::c_int;
    pub fn lr_gettmpdir() -> *mut ::std::os::raw::c_char;
    pub fn lr_pathconcat(str: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
    pub fn lr_remove_dir(path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn lr_copy_content(source: ::std::os::raw::c_int,
                           dest: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn lr_prepend_url_protocol(path: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn lr_string_chunk_insert(chunk: *mut GStringChunk,
                                  string: *const gchar) -> *mut gchar;
    pub fn lr_xml_parser_warning_logger(_type: LrXmlParserWarningType,
                                        msg: *mut ::std::os::raw::c_char,
                                        cbdata: *mut ::std::os::raw::c_void,
                                        err: *mut *mut GError)
     -> ::std::os::raw::c_int;
    pub fn lr_best_checksum(list: *mut GSList, _type: *mut LrChecksumType,
                            value: *mut *mut gchar) -> gboolean;
    pub fn lr_url_without_path(url: *const ::std::os::raw::c_char)
     -> *mut gchar;
    pub fn lr_strv_dup(array: *mut *mut gchar) -> *mut *mut gchar;
    pub fn lr_is_local_path(path: *const gchar) -> gboolean;
    pub fn lr_key_file_save_to_file(key_file: *mut GKeyFile,
                                    filename: *const gchar,
                                    error: *mut *mut GError) -> gboolean;
    pub fn lr_yum_repo_init() -> *mut LrYumRepo;
    pub fn lr_yum_repo_free(repo: *mut LrYumRepo);
    pub fn lr_yum_repo_path(repo: *mut LrYumRepo,
                            _type: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn lr_downloadtargetchecksum_new(_type: LrChecksumType,
                                         value: *const gchar)
     -> *mut LrDownloadTargetChecksum;
    pub fn lr_downloadtargetchecksum_free(dtch:
                                              *mut LrDownloadTargetChecksum);
    pub fn lr_downloadtarget_new(handle: *mut LrHandle,
                                 path: *const ::std::os::raw::c_char,
                                 baseurl: *const ::std::os::raw::c_char,
                                 fd: ::std::os::raw::c_int,
                                 _fn: *const ::std::os::raw::c_char,
                                 possiblechecksums: *mut GSList,
                                 expectedsize: gint64, resume: gboolean,
                                 progresscb: LrProgressCb,
                                 cbdata: *mut ::std::os::raw::c_void,
                                 endcb: LrEndCb,
                                 mirrorfailurecb: LrMirrorFailureCb,
                                 userdata: *mut ::std::os::raw::c_void,
                                 byterangestart: gint64, byterangeend: gint64)
     -> *mut LrDownloadTarget;
    pub fn lr_downloadtarget_reset(target: *mut LrDownloadTarget);
    pub fn lr_downloadtarget_free(target: *mut LrDownloadTarget);
    pub fn lr_sigint_handler(sig: ::std::os::raw::c_int);
    pub fn lr_download(targets: *mut GSList, failfast: gboolean,
                       err: *mut *mut GError) -> gboolean;
    pub fn lr_download_target(target: *mut LrDownloadTarget,
                              err: *mut *mut GError) -> gboolean;
    pub fn lr_download_url(handle: *mut LrHandle,
                           url: *const ::std::os::raw::c_char,
                           fd: ::std::os::raw::c_int, err: *mut *mut GError)
     -> gboolean;
    pub fn lr_download_single_cb(targets: *mut GSList, failfast: gboolean,
                                 cb: LrProgressCb, mfcb: LrMirrorFailureCb,
                                 err: *mut *mut GError) -> gboolean;
    pub fn hif_repo_get_type() -> GType;
    pub fn hif_repo_new(context: *mut HifContext) -> *mut HifRepo;
    pub fn hif_repo_get_id(repo: *mut HifRepo) -> *const gchar;
    pub fn hif_repo_get_location(repo: *mut HifRepo) -> *const gchar;
    pub fn hif_repo_get_filename(repo: *mut HifRepo) -> *const gchar;
    pub fn hif_repo_get_packages(repo: *mut HifRepo) -> *const gchar;
    pub fn hif_repo_get_enabled(repo: *mut HifRepo) -> HifRepoEnabled;
    pub fn hif_repo_get_required(repo: *mut HifRepo) -> gboolean;
    pub fn hif_repo_get_cost(repo: *mut HifRepo) -> guint;
    pub fn hif_repo_get_kind(repo: *mut HifRepo) -> HifRepoKind;
    pub fn hif_repo_get_exclude_packages(repo: *mut HifRepo)
     -> *mut *mut gchar;
    pub fn hif_repo_get_gpgcheck(repo: *mut HifRepo) -> gboolean;
    pub fn hif_repo_get_gpgcheck_md(repo: *mut HifRepo) -> gboolean;
    pub fn hif_repo_get_description(repo: *mut HifRepo) -> *mut gchar;
    pub fn hif_repo_get_filename_md(repo: *mut HifRepo, md_kind: *const gchar)
     -> *const gchar;
    pub fn hif_repo_get_repo(repo: *mut HifRepo) -> HyRepo;
    pub fn hif_repo_is_devel(repo: *mut HifRepo) -> gboolean;
    pub fn hif_repo_is_local(repo: *mut HifRepo) -> gboolean;
    pub fn hif_repo_is_repo(repo: *mut HifRepo) -> gboolean;
    pub fn hif_repo_set_id(repo: *mut HifRepo, id: *const gchar);
    pub fn hif_repo_set_location(repo: *mut HifRepo, location: *const gchar);
    pub fn hif_repo_set_location_tmp(repo: *mut HifRepo,
                                     location_tmp: *const gchar);
    pub fn hif_repo_set_filename(repo: *mut HifRepo, filename: *const gchar);
    pub fn hif_repo_set_packages(repo: *mut HifRepo, packages: *const gchar);
    pub fn hif_repo_set_packages_tmp(repo: *mut HifRepo,
                                     packages_tmp: *const gchar);
    pub fn hif_repo_set_enabled(repo: *mut HifRepo, enabled: HifRepoEnabled);
    pub fn hif_repo_set_required(repo: *mut HifRepo, required: gboolean);
    pub fn hif_repo_set_cost(repo: *mut HifRepo, cost: guint);
    pub fn hif_repo_set_kind(repo: *mut HifRepo, kind: HifRepoKind);
    pub fn hif_repo_set_gpgcheck(repo: *mut HifRepo, gpgcheck_pkgs: gboolean);
    pub fn hif_repo_set_gpgcheck_md(repo: *mut HifRepo,
                                    gpgcheck_md: gboolean);
    pub fn hif_repo_set_keyfile(repo: *mut HifRepo, keyfile: *mut GKeyFile);
    pub fn hif_repo_setup(repo: *mut HifRepo, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_repo_check(repo: *mut HifRepo, permissible_cache_age: guint,
                          state: *mut HifState, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_repo_update(repo: *mut HifRepo, flags: HifRepoUpdateFlags,
                           state: *mut HifState, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_repo_clean(repo: *mut HifRepo, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_repo_set_data(repo: *mut HifRepo, parameter: *const gchar,
                             value: *const gchar, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_repo_commit(repo: *mut HifRepo, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_repo_get_lr_handle(repo: *mut HifRepo) -> *mut LrHandle;
    pub fn hif_repo_get_lr_result(repo: *mut HifRepo) -> *mut LrResult;
    pub fn hif_repo_download_package(repo: *mut HifRepo, pkg: *mut HifPackage,
                                     directory: *const gchar,
                                     state: *mut HifState,
                                     error: *mut *mut GError) -> *mut gchar;
    pub fn hif_packageset_get_type() -> GType;
    pub fn hif_packageset_new(sack: *mut HifSack) -> *mut HifPackageSet;
    pub fn hif_packageset_clone(pset: *mut HifPackageSet)
     -> *mut HifPackageSet;
    pub fn hif_packageset_add(pset: *mut HifPackageSet, pkg: *mut HifPackage);
    pub fn hif_packageset_count(pset: *mut HifPackageSet)
     -> ::std::os::raw::c_uint;
    pub fn hif_packageset_get_clone(pset: *mut HifPackageSet,
                                    index: ::std::os::raw::c_int)
     -> *mut HifPackage;
    pub fn hif_packageset_has(pset: *mut HifPackageSet, pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hif_sack_get_type() -> GType;
    pub fn hif_sack_new() -> *mut HifSack;
    pub fn hif_sack_set_cachedir(sack: *mut HifSack, value: *const gchar);
    pub fn hif_sack_set_arch(sack: *mut HifSack, value: *const gchar,
                             error: *mut *mut GError) -> gboolean;
    pub fn hif_sack_set_rootdir(sack: *mut HifSack, value: *const gchar);
    pub fn hif_sack_setup(sack: *mut HifSack, flags: ::std::os::raw::c_int,
                          error: *mut *mut GError) -> gboolean;
    pub fn hif_sack_evr_cmp(sack: *mut HifSack,
                            evr1: *const ::std::os::raw::c_char,
                            evr2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hif_sack_get_cache_dir(sack: *mut HifSack)
     -> *const ::std::os::raw::c_char;
    pub fn hif_sack_get_running_kernel(sack: *mut HifSack) -> *mut HifPackage;
    pub fn hif_sack_give_cache_fn(sack: *mut HifSack,
                                  reponame: *const ::std::os::raw::c_char,
                                  ext: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn hif_sack_list_arches(sack: *mut HifSack)
     -> *mut *const ::std::os::raw::c_char;
    pub fn hif_sack_set_installonly(sack: *mut HifSack,
                                    installonly:
                                        *mut *const ::std::os::raw::c_char);
    pub fn hif_sack_set_installonly_limit(sack: *mut HifSack, limit: guint);
    pub fn hif_sack_get_installonly_limit(sack: *mut HifSack) -> guint;
    pub fn hif_sack_add_cmdline_package(sack: *mut HifSack,
                                        _fn: *const ::std::os::raw::c_char)
     -> *mut HifPackage;
    pub fn hif_sack_count(sack: *mut HifSack) -> ::std::os::raw::c_int;
    pub fn hif_sack_add_excludes(sack: *mut HifSack,
                                 pset: *mut HifPackageSet);
    pub fn hif_sack_add_includes(sack: *mut HifSack,
                                 pset: *mut HifPackageSet);
    pub fn hif_sack_set_excludes(sack: *mut HifSack,
                                 pset: *mut HifPackageSet);
    pub fn hif_sack_set_includes(sack: *mut HifSack,
                                 pset: *mut HifPackageSet);
    pub fn hif_sack_repo_enabled(sack: *mut HifSack,
                                 reponame: *const ::std::os::raw::c_char,
                                 enabled: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn hif_sack_load_system_repo(sack: *mut HifSack, a_hrepo: HyRepo,
                                     flags: ::std::os::raw::c_int,
                                     error: *mut *mut GError) -> gboolean;
    pub fn hif_sack_load_repo(sack: *mut HifSack, hrepo: HyRepo,
                              flags: ::std::os::raw::c_int,
                              error: *mut *mut GError) -> gboolean;
    pub fn hif_sack_add_repo(sack: *mut HifSack, repo: *mut HifRepo,
                             permissible_cache_age: guint,
                             flags: HifSackAddFlags, state: *mut HifState,
                             error: *mut *mut GError) -> gboolean;
    pub fn hif_sack_add_repos(sack: *mut HifSack, repos: *mut GPtrArray,
                              permissible_cache_age: guint,
                              flags: HifSackAddFlags, state: *mut HifState,
                              error: *mut *mut GError) -> gboolean;
    pub fn hy_goal_create(sack: *mut HifSack) -> HyGoal;
    pub fn hy_goal_clone(goal: HyGoal) -> HyGoal;
    pub fn hy_goal_free(goal: HyGoal);
    pub fn hy_goal_distupgrade_all(goal: HyGoal) -> ::std::os::raw::c_int;
    pub fn hy_goal_distupgrade(goal: HyGoal, new_pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_distupgrade_selector(goal: HyGoal, arg1: HySelector)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_downgrade_to(goal: HyGoal, new_pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_erase(goal: HyGoal, pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_erase_flags(goal: HyGoal, pkg: *mut HifPackage,
                               flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_erase_selector(goal: HyGoal, sltr: HySelector)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_erase_selector_flags(goal: HyGoal, sltr: HySelector,
                                        flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_install(goal: HyGoal, new_pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_install_optional(goal: HyGoal, new_pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_install_selector(goal: HyGoal, sltr: HySelector,
                                    error: *mut *mut GError) -> gboolean;
    pub fn hy_goal_install_selector_optional(goal: HyGoal, sltr: HySelector,
                                             error: *mut *mut GError)
     -> gboolean;
    pub fn hy_goal_upgrade_all(goal: HyGoal) -> ::std::os::raw::c_int;
    pub fn hy_goal_upgrade_to(goal: HyGoal, new_pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_upgrade_to_flags(goal: HyGoal, new_pkg: *mut HifPackage,
                                    flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_upgrade_selector(goal: HyGoal, sltr: HySelector)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_upgrade_to_selector(goal: HyGoal, sltr: HySelector)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_userinstalled(goal: HyGoal, pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_has_actions(goal: HyGoal, action: HifGoalActions)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_req_length(goal: HyGoal) -> ::std::os::raw::c_int;
    pub fn hy_goal_run(goal: HyGoal) -> ::std::os::raw::c_int;
    pub fn hy_goal_run_flags(goal: HyGoal, flags: HifGoalActions)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_run_all(goal: HyGoal, cb: hy_solution_callback,
                           cb_data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_run_all_flags(goal: HyGoal, cb: hy_solution_callback,
                                 cb_data: *mut ::std::os::raw::c_void,
                                 flags: HifGoalActions)
     -> ::std::os::raw::c_int;
    pub fn hy_goal_count_problems(goal: HyGoal) -> ::std::os::raw::c_int;
    pub fn hy_goal_describe_problem(goal: HyGoal, i: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_char;
    pub fn hy_goal_log_decisions(goal: HyGoal) -> ::std::os::raw::c_int;
    pub fn hy_goal_write_debugdata(goal: HyGoal,
                                   dir: *const ::std::os::raw::c_char,
                                   error: *mut *mut GError) -> gboolean;
    pub fn hy_goal_list_erasures(goal: HyGoal, error: *mut *mut GError)
     -> *mut GPtrArray;
    pub fn hy_goal_list_installs(goal: HyGoal, error: *mut *mut GError)
     -> *mut GPtrArray;
    pub fn hy_goal_list_obsoleted(goal: HyGoal, error: *mut *mut GError)
     -> *mut GPtrArray;
    pub fn hy_goal_list_reinstalls(goal: HyGoal, error: *mut *mut GError)
     -> *mut GPtrArray;
    pub fn hy_goal_list_unneeded(goal: HyGoal, error: *mut *mut GError)
     -> *mut GPtrArray;
    pub fn hy_goal_list_upgrades(goal: HyGoal, error: *mut *mut GError)
     -> *mut GPtrArray;
    pub fn hy_goal_list_downgrades(goal: HyGoal, error: *mut *mut GError)
     -> *mut GPtrArray;
    pub fn hy_goal_list_obsoleted_by_package(goal: HyGoal,
                                             pkg: *mut HifPackage)
     -> *mut GPtrArray;
    pub fn hy_goal_get_reason(goal: HyGoal, pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
    pub fn hif_db_get_type() -> GType;
    pub fn hif_db_new(context: *mut HifContext) -> *mut HifDb;
    pub fn hif_db_set_enabled(db: *mut HifDb, enabled: gboolean);
    pub fn hif_db_get_string(db: *mut HifDb, package: *mut HifPackage,
                             key: *const gchar, error: *mut *mut GError)
     -> *mut gchar;
    pub fn hif_db_set_string(db: *mut HifDb, package: *mut HifPackage,
                             key: *const gchar, value: *const gchar,
                             error: *mut *mut GError) -> gboolean;
    pub fn hif_db_remove(db: *mut HifDb, package: *mut HifPackage,
                         key: *const gchar, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_db_remove_all(db: *mut HifDb, package: *mut HifPackage,
                             error: *mut *mut GError) -> gboolean;
    pub fn hif_db_ensure_origin_pkg(db: *mut HifDb, pkg: *mut HifPackage);
    pub fn hif_db_ensure_origin_pkglist(db: *mut HifDb,
                                        pkglist: *mut GPtrArray);
    pub fn hif_repos_get_type() -> GType;
    pub fn hif_repos_new(context: *mut HifContext) -> *mut HifRepos;
    pub fn hif_repos_has_removable(_self: *mut HifRepos) -> gboolean;
    pub fn hif_repos_get_repos(_self: *mut HifRepos, error: *mut *mut GError)
     -> *mut GPtrArray;
    pub fn hif_repos_get_by_id(_self: *mut HifRepos, id: *const gchar,
                               error: *mut *mut GError) -> *mut HifRepo;
    pub fn hif_transaction_get_type() -> GType;
    pub fn hif_transaction_new(context: *mut HifContext)
     -> *mut HifTransaction;
    pub fn hif_transaction_get_flags(transaction: *mut HifTransaction)
     -> guint64;
    pub fn hif_transaction_get_remote_pkgs(transaction: *mut HifTransaction)
     -> *mut GPtrArray;
    pub fn hif_transaction_get_db(transaction: *mut HifTransaction)
     -> *mut HifDb;
    pub fn hif_transaction_set_repos(transaction: *mut HifTransaction,
                                     repos: *mut GPtrArray);
    pub fn hif_transaction_set_uid(transaction: *mut HifTransaction,
                                   uid: guint);
    pub fn hif_transaction_set_flags(transaction: *mut HifTransaction,
                                     flags: guint64);
    pub fn hif_transaction_depsolve(transaction: *mut HifTransaction,
                                    goal: HyGoal, state: *mut HifState,
                                    error: *mut *mut GError) -> gboolean;
    pub fn hif_transaction_download(transaction: *mut HifTransaction,
                                    state: *mut HifState,
                                    error: *mut *mut GError) -> gboolean;
    pub fn hif_transaction_commit(transaction: *mut HifTransaction,
                                  goal: HyGoal, state: *mut HifState,
                                  error: *mut *mut GError) -> gboolean;
    pub fn hif_transaction_ensure_repo(transaction: *mut HifTransaction,
                                       pkg: *mut HifPackage,
                                       error: *mut *mut GError) -> gboolean;
    pub fn hif_transaction_ensure_repo_list(transaction: *mut HifTransaction,
                                            pkglist: *mut GPtrArray,
                                            error: *mut *mut GError)
     -> gboolean;
    pub fn hif_context_get_type() -> GType;
    pub fn hif_context_new() -> *mut HifContext;
    pub fn hif_context_get_repo_dir(context: *mut HifContext) -> *const gchar;
    pub fn hif_context_get_base_arch(context: *mut HifContext)
     -> *const gchar;
    pub fn hif_context_get_os_info(context: *mut HifContext) -> *const gchar;
    pub fn hif_context_get_arch_info(context: *mut HifContext)
     -> *const gchar;
    pub fn hif_context_get_release_ver(context: *mut HifContext)
     -> *const gchar;
    pub fn hif_context_get_cache_dir(context: *mut HifContext)
     -> *const gchar;
    pub fn hif_context_get_solv_dir(context: *mut HifContext) -> *const gchar;
    pub fn hif_context_get_lock_dir(context: *mut HifContext) -> *const gchar;
    pub fn hif_context_get_rpm_verbosity(context: *mut HifContext)
     -> *const gchar;
    pub fn hif_context_get_install_root(context: *mut HifContext)
     -> *const gchar;
    pub fn hif_context_get_native_arches(context: *mut HifContext)
     -> *mut *const gchar;
    pub fn hif_context_get_installonly_pkgs(context: *mut HifContext)
     -> *mut *const gchar;
    pub fn hif_context_get_check_disk_space(context: *mut HifContext)
     -> gboolean;
    pub fn hif_context_get_check_transaction(context: *mut HifContext)
     -> gboolean;
    pub fn hif_context_get_keep_cache(context: *mut HifContext) -> gboolean;
    pub fn hif_context_get_only_trusted(context: *mut HifContext) -> gboolean;
    pub fn hif_context_get_yumdb_enabled(context: *mut HifContext)
     -> gboolean;
    pub fn hif_context_get_cache_age(context: *mut HifContext) -> guint;
    pub fn hif_context_get_installonly_limit(context: *mut HifContext)
     -> guint;
    pub fn hif_context_get_http_proxy(context: *mut HifContext)
     -> *const gchar;
    pub fn hif_context_get_repos(context: *mut HifContext) -> *mut GPtrArray;
    pub fn hif_context_get_transaction(context: *mut HifContext)
     -> *mut HifTransaction;
    pub fn hif_context_get_sack(context: *mut HifContext) -> *mut HifSack;
    pub fn hif_context_get_goal(context: *mut HifContext) -> HyGoal;
    pub fn hif_context_get_state(context: *mut HifContext) -> *mut HifState;
    pub fn hif_context_set_repo_dir(context: *mut HifContext,
                                    repo_dir: *const gchar);
    pub fn hif_context_set_release_ver(context: *mut HifContext,
                                       release_ver: *const gchar);
    pub fn hif_context_set_cache_dir(context: *mut HifContext,
                                     cache_dir: *const gchar);
    pub fn hif_context_set_solv_dir(context: *mut HifContext,
                                    solv_dir: *const gchar);
    pub fn hif_context_set_vendor_cache_dir(context: *mut HifContext,
                                            vendor_cache_dir: *const gchar);
    pub fn hif_context_set_vendor_solv_dir(context: *mut HifContext,
                                           vendor_solv_dir: *const gchar);
    pub fn hif_context_set_lock_dir(context: *mut HifContext,
                                    lock_dir: *const gchar);
    pub fn hif_context_set_rpm_verbosity(context: *mut HifContext,
                                         rpm_verbosity: *const gchar);
    pub fn hif_context_set_install_root(context: *mut HifContext,
                                        install_root: *const gchar);
    pub fn hif_context_set_check_disk_space(context: *mut HifContext,
                                            check_disk_space: gboolean);
    pub fn hif_context_set_check_transaction(context: *mut HifContext,
                                             check_transaction: gboolean);
    pub fn hif_context_set_keep_cache(context: *mut HifContext,
                                      keep_cache: gboolean);
    pub fn hif_context_set_only_trusted(context: *mut HifContext,
                                        only_trusted: gboolean);
    pub fn hif_context_set_yumdb_enabled(context: *mut HifContext,
                                         enable_yumdb: gboolean);
    pub fn hif_context_set_cache_age(context: *mut HifContext,
                                     cache_age: guint);
    pub fn hif_context_set_rpm_macro(context: *mut HifContext,
                                     key: *const gchar, value: *const gchar);
    pub fn hif_context_set_http_proxy(context: *mut HifContext,
                                      proxyurl: *const gchar);
    pub fn hif_context_setup(context: *mut HifContext,
                             cancellable: *mut GCancellable,
                             error: *mut *mut GError) -> gboolean;
    pub fn hif_context_setup_enrollments(context: *mut HifContext,
                                         error: *mut *mut GError) -> gboolean;
    pub fn hif_context_setup_sack(context: *mut HifContext,
                                  state: *mut HifState,
                                  error: *mut *mut GError) -> gboolean;
    pub fn hif_context_commit(context: *mut HifContext, state: *mut HifState,
                              error: *mut *mut GError) -> gboolean;
    pub fn hif_context_invalidate(context: *mut HifContext,
                                  message: *const gchar);
    pub fn hif_context_invalidate_full(context: *mut HifContext,
                                       message: *const gchar,
                                       flags: HifContextInvalidateFlags);
    pub fn hif_context_install(context: *mut HifContext, name: *const gchar,
                               error: *mut *mut GError) -> gboolean;
    pub fn hif_context_remove(context: *mut HifContext, name: *const gchar,
                              error: *mut *mut GError) -> gboolean;
    pub fn hif_context_update(context: *mut HifContext, name: *const gchar,
                              error: *mut *mut GError) -> gboolean;
    pub fn hif_context_repo_enable(context: *mut HifContext,
                                   repo_id: *const gchar,
                                   error: *mut *mut GError) -> gboolean;
    pub fn hif_context_repo_disable(context: *mut HifContext,
                                    repo_id: *const gchar,
                                    error: *mut *mut GError) -> gboolean;
    pub fn hif_context_run(context: *mut HifContext,
                           cancellable: *mut GCancellable,
                           error: *mut *mut GError) -> gboolean;
    pub fn hif_goal_depsolve(goal: HyGoal, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_goal_get_packages(goal: HyGoal, ...) -> *mut GPtrArray;
    pub fn rpmTagGetName(tag: rpmTagVal) -> *const ::std::os::raw::c_char;
    pub fn rpmTagGetType(tag: rpmTagVal) -> rpmTagType;
    pub fn rpmTagGetTagType(tag: rpmTagVal) -> rpmTagType;
    pub fn rpmTagGetReturnType(tag: rpmTagVal) -> rpmTagReturnType;
    pub fn rpmTagGetClass(tag: rpmTagVal) -> rpmTagClass;
    pub fn rpmTagGetValue(tagstr: *const ::std::os::raw::c_char) -> rpmTagVal;
    pub fn rpmTagTypeGetClass(_type: rpmTagType) -> rpmTagClass;
    pub fn rpmTagGetNames(tagnames: rpmtd, fullname: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rmalloc(size: size_t) -> *mut ::std::os::raw::c_void;
    pub fn rcalloc(nmemb: size_t, size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rrealloc(ptr: *mut ::std::os::raw::c_void, size: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rstrdup(str: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn rfree(ptr: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn rpmSetMemFail(func: rpmMemFailFunc,
                         data: *mut ::std::os::raw::c_void) -> rpmMemFailFunc;
    pub fn rstrcasecmp(s1: *const ::std::os::raw::c_char,
                       s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rstrncasecmp(s1: *const ::std::os::raw::c_char,
                        s2: *const ::std::os::raw::c_char, n: size_t)
     -> ::std::os::raw::c_int;
    pub fn rasprintf(strp: *mut *mut ::std::os::raw::c_char,
                     fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn rstrcat(dest: *mut *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn rstrscat(dest: *mut *mut ::std::os::raw::c_char,
                    arg: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
    pub fn rstrlcpy(dest: *mut ::std::os::raw::c_char,
                    src: *const ::std::os::raw::c_char, n: size_t) -> size_t;
    pub fn rstrhash(string: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
    pub fn pgpValString(_type: pgpValType, val: uint8_t)
     -> *const ::std::os::raw::c_char;
    pub fn pgpHexStr(p: *const uint8_t, plen: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn pgpPubkeyFingerprint(pkt: *const uint8_t, pktlen: size_t,
                                keyid: pgpKeyID_t) -> ::std::os::raw::c_int;
    pub fn pgpExtractPubkeyFingerprint(b64pkt: *const ::std::os::raw::c_char,
                                       keyid: pgpKeyID_t)
     -> ::std::os::raw::c_int;
    pub fn pgpPrtParams(pkts: *const uint8_t, pktlen: size_t,
                        pkttype: ::std::os::raw::c_uint,
                        ret: *mut pgpDigParams) -> ::std::os::raw::c_int;
    pub fn pgpPrtParamsSubkeys(pkts: *const uint8_t, pktlen: size_t,
                               mainkey: pgpDigParams,
                               subkeys: *mut *mut pgpDigParams,
                               subkeysCount: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pgpPrtPkts(pkts: *const uint8_t, pktlen: size_t, dig: pgpDig,
                      printing: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pgpReadPkts(_fn: *const ::std::os::raw::c_char,
                       pkt: *mut *mut uint8_t, pktlen: *mut size_t)
     -> pgpArmor;
    pub fn pgpParsePkts(armor: *const ::std::os::raw::c_char,
                        pkt: *mut *mut uint8_t, pktlen: *mut size_t)
     -> pgpArmor;
    pub fn pgpPubKeyCertLen(pkts: *const uint8_t, pktslen: size_t,
                            certlen: *mut size_t) -> ::std::os::raw::c_int;
    pub fn pgpArmorWrap(atype: ::std::os::raw::c_int,
                        s: *const ::std::os::raw::c_uchar, ns: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn pgpNewDig() -> pgpDig;
    pub fn pgpCleanDig(dig: pgpDig);
    pub fn pgpFreeDig(dig: pgpDig) -> pgpDig;
    pub fn pgpDigGetParams(dig: pgpDig, pkttype: ::std::os::raw::c_uint)
     -> pgpDigParams;
    pub fn pgpDigParamsCmp(p1: pgpDigParams, p2: pgpDigParams)
     -> ::std::os::raw::c_int;
    pub fn pgpDigParamsAlgo(digp: pgpDigParams,
                            algotype: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
    pub fn pgpDigParamsFree(digp: pgpDigParams) -> pgpDigParams;
    pub fn pgpVerifySignature(key: pgpDigParams, sig: pgpDigParams,
                              hashctx: DIGEST_CTX) -> rpmRC;
    pub fn pgpVerifySig(dig: pgpDig, hashctx: DIGEST_CTX) -> rpmRC;
    pub fn pgpIdentItem(digp: pgpDigParams) -> *mut ::std::os::raw::c_char;
    pub fn rpmInitCrypto() -> ::std::os::raw::c_int;
    pub fn rpmFreeCrypto() -> ::std::os::raw::c_int;
    pub fn rpmDigestDup(octx: DIGEST_CTX) -> DIGEST_CTX;
    pub fn rpmDigestLength(hashalgo: ::std::os::raw::c_int) -> size_t;
    pub fn rpmDigestInit(hashalgo: ::std::os::raw::c_int,
                         flags: rpmDigestFlags) -> DIGEST_CTX;
    pub fn rpmDigestUpdate(ctx: DIGEST_CTX,
                           data: *const ::std::os::raw::c_void, len: size_t)
     -> ::std::os::raw::c_int;
    pub fn rpmDigestFinal(ctx: DIGEST_CTX,
                          datap: *mut *mut ::std::os::raw::c_void,
                          lenp: *mut size_t, asAscii: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmDigestBundleNew() -> rpmDigestBundle;
    pub fn rpmDigestBundleFree(bundle: rpmDigestBundle) -> rpmDigestBundle;
    pub fn rpmDigestBundleAdd(bundle: rpmDigestBundle,
                              algo: ::std::os::raw::c_int,
                              flags: rpmDigestFlags) -> ::std::os::raw::c_int;
    pub fn rpmDigestBundleUpdate(bundle: rpmDigestBundle,
                                 data: *const ::std::os::raw::c_void,
                                 len: size_t) -> ::std::os::raw::c_int;
    pub fn rpmDigestBundleFinal(bundle: rpmDigestBundle,
                                algo: ::std::os::raw::c_int,
                                datap: *mut *mut ::std::os::raw::c_void,
                                lenp: *mut size_t,
                                asAscii: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmDigestBundleDupCtx(bundle: rpmDigestBundle,
                                 algo: ::std::os::raw::c_int) -> DIGEST_CTX;
    pub fn rpmKeyringNew() -> rpmKeyring;
    pub fn rpmKeyringFree(keyring: rpmKeyring) -> rpmKeyring;
    pub fn rpmKeyringAddKey(keyring: rpmKeyring, key: rpmPubkey)
     -> ::std::os::raw::c_int;
    pub fn rpmKeyringLookup(keyring: rpmKeyring, sig: pgpDig) -> rpmRC;
    pub fn rpmKeyringVerifySig(keyring: rpmKeyring, sig: pgpDigParams,
                               ctx: DIGEST_CTX) -> rpmRC;
    pub fn rpmKeyringLink(keyring: rpmKeyring) -> rpmKeyring;
    pub fn rpmPubkeyNew(pkt: *const uint8_t, pktlen: size_t) -> rpmPubkey;
    pub fn rpmGetSubkeys(mainkey: rpmPubkey,
                         count: *mut ::std::os::raw::c_int) -> *mut rpmPubkey;
    pub fn rpmPubkeyRead(filename: *const ::std::os::raw::c_char)
     -> rpmPubkey;
    pub fn rpmPubkeyFree(key: rpmPubkey) -> rpmPubkey;
    pub fn rpmPubkeyLink(key: rpmPubkey) -> rpmPubkey;
    pub fn rpmPubkeyDig(key: rpmPubkey) -> pgpDig;
    pub fn rpmPubkeyBase64(key: rpmPubkey) -> *mut ::std::os::raw::c_char;
    pub fn rpmPubkeyPgpDigParams(key: rpmPubkey) -> pgpDigParams;
    pub fn hif_keyring_add_public_key(keyring: rpmKeyring,
                                      filename: *const gchar,
                                      error: *mut *mut GError) -> gboolean;
    pub fn hif_keyring_add_public_keys(keyring: rpmKeyring,
                                       error: *mut *mut GError) -> gboolean;
    pub fn hif_keyring_check_untrusted_file(keyring: rpmKeyring,
                                            filename: *const gchar,
                                            error: *mut *mut GError)
     -> gboolean;
    pub fn hif_package_get_repo(pkg: *mut HifPackage) -> *mut HifRepo;
    pub fn hif_package_set_repo(pkg: *mut HifPackage, repo: *mut HifRepo);
    pub fn hif_package_get_filename(pkg: *mut HifPackage) -> *const gchar;
    pub fn hif_package_set_filename(pkg: *mut HifPackage,
                                    filename: *const gchar);
    pub fn hif_package_get_origin(pkg: *mut HifPackage) -> *const gchar;
    pub fn hif_package_set_origin(pkg: *mut HifPackage, origin: *const gchar);
    pub fn hif_package_get_package_id(pkg: *mut HifPackage) -> *const gchar;
    pub fn hif_package_get_info(pkg: *mut HifPackage) -> HifPackageInfo;
    pub fn hif_package_set_info(pkg: *mut HifPackage, info: HifPackageInfo);
    pub fn hif_package_get_action(pkg: *mut HifPackage) -> HifStateAction;
    pub fn hif_package_set_action(pkg: *mut HifPackage,
                                  action: HifStateAction);
    pub fn hif_package_get_user_action(pkg: *mut HifPackage) -> gboolean;
    pub fn hif_package_set_user_action(pkg: *mut HifPackage,
                                       user_action: gboolean);
    pub fn hif_package_is_gui(pkg: *mut HifPackage) -> gboolean;
    pub fn hif_package_is_devel(pkg: *mut HifPackage) -> gboolean;
    pub fn hif_package_is_downloaded(pkg: *mut HifPackage) -> gboolean;
    pub fn hif_package_is_installonly(pkg: *mut HifPackage) -> gboolean;
    pub fn hif_package_get_pkgid(pkg: *mut HifPackage) -> *const gchar;
    pub fn hif_package_set_pkgid(pkg: *mut HifPackage, pkgid: *const gchar);
    pub fn hif_package_get_cost(pkg: *mut HifPackage) -> guint;
    pub fn hif_package_download(pkg: *mut HifPackage, directory: *const gchar,
                                state: *mut HifState, error: *mut *mut GError)
     -> *mut gchar;
    pub fn hif_package_check_filename(pkg: *mut HifPackage,
                                      valid: *mut gboolean,
                                      error: *mut *mut GError) -> gboolean;
    pub fn hif_package_array_download(packages: *mut GPtrArray,
                                      directory: *const gchar,
                                      state: *mut HifState,
                                      error: *mut *mut GError) -> gboolean;
    pub fn argvPrint(msg: *const ::std::os::raw::c_char, argv: ARGV_const_t,
                     fp: *mut FILE);
    pub fn argiFree(argi: ARGI_t) -> ARGI_t;
    pub fn argvNew() -> ARGV_t;
    pub fn argvFree(argv: ARGV_t) -> ARGV_t;
    pub fn argiCount(argi: ARGI_const_t) -> ::std::os::raw::c_int;
    pub fn argiData(argi: ARGI_const_t) -> ARGint_t;
    pub fn argvCount(argv: ARGV_const_t) -> ::std::os::raw::c_int;
    pub fn argvData(argv: ARGV_t) -> ARGV_t;
    pub fn argvCmp(a: *const ::std::os::raw::c_void,
                   b: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
    pub fn argvSort(argv: ARGV_t,
                    compar:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
    pub fn argvSearch(argv: ARGV_const_t, val: *const ::std::os::raw::c_char,
                      compar:
                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *const ::std::os::raw::c_void,
                                                                     arg2:
                                                                         *const ::std::os::raw::c_void)
                                                    -> ::std::os::raw::c_int>)
     -> ARGV_t;
    pub fn argiAdd(argip: *mut ARGI_t, ix: ::std::os::raw::c_int,
                   val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn argvAdd(argvp: *mut ARGV_t, val: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn argvAddNum(argvp: *mut ARGV_t, val: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn argvAppend(argvp: *mut ARGV_t, av: ARGV_const_t)
     -> ::std::os::raw::c_int;
    pub fn argvSplitString(str: *const ::std::os::raw::c_char,
                           seps: *const ::std::os::raw::c_char,
                           flags: argvFlags) -> ARGV_t;
    pub fn argvSplit(argvp: *mut ARGV_t, str: *const ::std::os::raw::c_char,
                     seps: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn argvJoin(argv: ARGV_const_t, sep: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn rpmteHeader(te: rpmte) -> Header;
    pub fn rpmteSetHeader(te: rpmte, h: Header) -> Header;
    pub fn rpmteType(te: rpmte) -> rpmElementType;
    pub fn rpmteN(te: rpmte) -> *const ::std::os::raw::c_char;
    pub fn rpmteE(te: rpmte) -> *const ::std::os::raw::c_char;
    pub fn rpmteV(te: rpmte) -> *const ::std::os::raw::c_char;
    pub fn rpmteR(te: rpmte) -> *const ::std::os::raw::c_char;
    pub fn rpmteA(te: rpmte) -> *const ::std::os::raw::c_char;
    pub fn rpmteO(te: rpmte) -> *const ::std::os::raw::c_char;
    pub fn rpmteIsSource(te: rpmte) -> ::std::os::raw::c_int;
    pub fn rpmteColor(te: rpmte) -> rpm_color_t;
    pub fn rpmteSetColor(te: rpmte, color: rpm_color_t) -> rpm_color_t;
    pub fn rpmteDBInstance(te: rpmte) -> ::std::os::raw::c_uint;
    pub fn rpmteSetDBInstance(te: rpmte, instance: ::std::os::raw::c_uint);
    pub fn rpmtePkgFileSize(te: rpmte) -> rpm_loff_t;
    pub fn rpmteParent(te: rpmte) -> rpmte;
    pub fn rpmteSetParent(te: rpmte, pte: rpmte) -> rpmte;
    pub fn rpmteProblems(te: rpmte) -> rpmps;
    pub fn rpmteCleanProblems(te: rpmte);
    pub fn rpmteCleanDS(te: rpmte);
    pub fn rpmteSetDependsOn(te: rpmte, depends: rpmte);
    pub fn rpmteDependsOn(te: rpmte) -> rpmte;
    pub fn rpmteDBOffset(te: rpmte) -> ::std::os::raw::c_int;
    pub fn rpmteEVR(te: rpmte) -> *const ::std::os::raw::c_char;
    pub fn rpmteNEVR(te: rpmte) -> *const ::std::os::raw::c_char;
    pub fn rpmteNEVRA(te: rpmte) -> *const ::std::os::raw::c_char;
    pub fn rpmteKey(te: rpmte) -> fnpyKey;
    pub fn rpmteFailed(te: rpmte) -> ::std::os::raw::c_int;
    pub fn rpmteDS(te: rpmte, tag: rpmTagVal) -> rpmds;
    pub fn rpmteFiles(te: rpmte) -> rpmfiles;
    pub fn rpmteFI(te: rpmte) -> rpmfi;
    pub fn rpmProblemCreate(_type: rpmProblemType,
                            pkgNEVR: *const ::std::os::raw::c_char,
                            key: fnpyKey,
                            altNEVR: *const ::std::os::raw::c_char,
                            str: *const ::std::os::raw::c_char,
                            number: uint64_t) -> rpmProblem;
    pub fn rpmProblemFree(prob: rpmProblem) -> rpmProblem;
    pub fn rpmProblemLink(prob: rpmProblem) -> rpmProblem;
    pub fn rpmProblemCompare(ap: rpmProblem, bp: rpmProblem)
     -> ::std::os::raw::c_int;
    pub fn rpmProblemGetPkgNEVR(prob: rpmProblem)
     -> *const ::std::os::raw::c_char;
    pub fn rpmProblemGetAltNEVR(prob: rpmProblem)
     -> *const ::std::os::raw::c_char;
    pub fn rpmProblemGetType(prob: rpmProblem) -> rpmProblemType;
    pub fn rpmProblemGetKey(prob: rpmProblem) -> fnpyKey;
    pub fn rpmProblemGetStr(prob: rpmProblem)
     -> *const ::std::os::raw::c_char;
    pub fn rpmProblemGetDiskNeed(prob: rpmProblem) -> rpm_loff_t;
    pub fn rpmProblemString(prob: rpmProblem) -> *mut ::std::os::raw::c_char;
    pub fn rpmpsLink(ps: rpmps) -> rpmps;
    pub fn rpmpsNumProblems(ps: rpmps) -> ::std::os::raw::c_int;
    pub fn rpmpsInitIterator(ps: rpmps) -> rpmpsi;
    pub fn rpmpsFreeIterator(psi: rpmpsi) -> rpmpsi;
    pub fn rpmpsiNext(psi: rpmpsi) -> rpmProblem;
    pub fn rpmpsNextIterator(psi: rpmpsi) -> ::std::os::raw::c_int;
    pub fn rpmpsGetProblem(psi: rpmpsi) -> rpmProblem;
    pub fn rpmpsCreate() -> rpmps;
    pub fn rpmpsFree(ps: rpmps) -> rpmps;
    pub fn rpmpsPrint(fp: *mut FILE, ps: rpmps);
    pub fn rpmpsAppendProblem(ps: rpmps, prob: rpmProblem);
    pub fn rpmpsMerge(dest: rpmps, src: rpmps) -> ::std::os::raw::c_int;
    pub fn rpmswNow(sw: rpmsw) -> rpmsw;
    pub fn rpmswDiff(end: rpmsw, begin: rpmsw) -> rpmtime_t;
    pub fn rpmswInit() -> rpmtime_t;
    pub fn rpmswEnter(op: rpmop, rc: ssize_t) -> ::std::os::raw::c_int;
    pub fn rpmswExit(op: rpmop, rc: ssize_t) -> rpmtime_t;
    pub fn rpmswAdd(to: rpmop, from: rpmop) -> rpmtime_t;
    pub fn rpmswSub(to: rpmop, from: rpmop) -> rpmtime_t;
    pub fn stat(__file: *const ::std::os::raw::c_char,
                __buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut Struct_stat)
     -> ::std::os::raw::c_int;
    pub fn fstatat(__fd: ::std::os::raw::c_int,
                   __file: *const ::std::os::raw::c_char,
                   __buf: *mut Struct_stat, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn lstat(__file: *const ::std::os::raw::c_char,
                 __buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn fchmodat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn umask(__mask: __mode_t) -> __mode_t;
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn mkdirat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn mknod(__path: *const ::std::os::raw::c_char, __mode: __mode_t,
                 __dev: __dev_t) -> ::std::os::raw::c_int;
    pub fn mknodat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                   __dev: __dev_t) -> ::std::os::raw::c_int;
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn mkfifoat(__fd: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
    pub fn utimensat(__fd: ::std::os::raw::c_int,
                     __path: *const ::std::os::raw::c_char,
                     __times: *mut Struct_timespec,
                     __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn futimens(__fd: ::std::os::raw::c_int,
                    __times: *mut Struct_timespec) -> ::std::os::raw::c_int;
    pub fn __fxstat(__ver: ::std::os::raw::c_int,
                    __fildes: ::std::os::raw::c_int,
                    __stat_buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn __xstat(__ver: ::std::os::raw::c_int,
                   __filename: *const ::std::os::raw::c_char,
                   __stat_buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn __lxstat(__ver: ::std::os::raw::c_int,
                    __filename: *const ::std::os::raw::c_char,
                    __stat_buf: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn __fxstatat(__ver: ::std::os::raw::c_int,
                      __fildes: ::std::os::raw::c_int,
                      __filename: *const ::std::os::raw::c_char,
                      __stat_buf: *mut Struct_stat,
                      __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn __xmknod(__ver: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __dev: *mut __dev_t) -> ::std::os::raw::c_int;
    pub fn __xmknodat(__ver: ::std::os::raw::c_int,
                      __fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                      __dev: *mut __dev_t) -> ::std::os::raw::c_int;
    pub fn rpmVerifyFile(ts: rpmts, fi: rpmfi, res: *mut rpmVerifyAttrs,
                         omitMask: rpmVerifyAttrs) -> ::std::os::raw::c_int;
    pub fn rpmfilesNew(pool: rpmstrPool, h: Header, tagN: rpmTagVal,
                       flags: rpmfiFlags) -> rpmfiles;
    pub fn rpmfilesLink(fi: rpmfiles) -> rpmfiles;
    pub fn rpmfilesFree(fi: rpmfiles) -> rpmfiles;
    pub fn rpmfilesFC(fi: rpmfiles) -> rpm_count_t;
    pub fn rpmfilesDC(fi: rpmfiles) -> rpm_count_t;
    pub fn rpmfilesFindFN(files: rpmfiles, _fn: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rpmfilesFindOFN(files: rpmfiles,
                           _fn: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rpmfilesIter(files: rpmfiles, itype: ::std::os::raw::c_int)
     -> rpmfi;
    pub fn rpmfilesDigestAlgo(fi: rpmfiles) -> ::std::os::raw::c_int;
    pub fn rpmfilesColor(files: rpmfiles) -> rpm_color_t;
    pub fn rpmfilesCompare(afi: rpmfiles, aix: ::std::os::raw::c_int,
                           bfi: rpmfiles, bix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmfilesBN(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesDN(fi: rpmfiles, jx: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesDI(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmfilesFN(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn rpmfilesODI(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmfilesOBN(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesODN(fi: rpmfiles, jx: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesOFN(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn rpmfilesVFlags(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpmVerifyAttrs;
    pub fn rpmfilesFState(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpmfileState;
    pub fn rpmfilesFLink(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesFSize(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_loff_t;
    pub fn rpmfilesFColor(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_color_t;
    pub fn rpmfilesFClass(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesFDepends(fi: rpmfiles, ix: ::std::os::raw::c_int,
                            fddictp: *mut *const uint32_t) -> uint32_t;
    pub fn rpmfilesFNlink(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> uint32_t;
    pub fn rpmfilesFLinks(fi: rpmfiles, ix: ::std::os::raw::c_int,
                          files: *mut *const ::std::os::raw::c_int)
     -> uint32_t;
    pub fn rpmfilesFLangs(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesFFlags(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpmfileAttrs;
    pub fn rpmfilesFMode(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_mode_t;
    pub fn rpmfilesFDigest(fi: rpmfiles, ix: ::std::os::raw::c_int,
                           algo: *mut ::std::os::raw::c_int, len: *mut size_t)
     -> *const ::std::os::raw::c_uchar;
    pub fn rpmfilesFSignature(fi: rpmfiles, ix: ::std::os::raw::c_int,
                              len: *mut size_t)
     -> *const ::std::os::raw::c_uchar;
    pub fn rpmfilesFRdev(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_rdev_t;
    pub fn rpmfilesFInode(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_ino_t;
    pub fn rpmfilesFMtime(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_time_t;
    pub fn rpmfilesFUser(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesFGroup(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesFCaps(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn rpmfilesStat(fi: rpmfiles, ix: ::std::os::raw::c_int,
                        flags: ::std::os::raw::c_int, sb: *mut Struct_stat)
     -> ::std::os::raw::c_int;
    pub fn rpmfileStrerror(rc: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn rpmfiNewArchiveWriter(fd: FD_t, files: rpmfiles) -> rpmfi;
    pub fn rpmfiNewArchiveReader(fd: FD_t, files: rpmfiles,
                                 itype: ::std::os::raw::c_int) -> rpmfi;
    pub fn rpmfiArchiveClose(fi: rpmfi) -> ::std::os::raw::c_int;
    pub fn rpmfiArchiveTell(fi: rpmfi) -> rpm_loff_t;
    pub fn rpmfiArchiveWrite(fi: rpmfi, buf: *const ::std::os::raw::c_void,
                             size: size_t) -> size_t;
    pub fn rpmfiArchiveWriteFile(fi: rpmfi, fd: FD_t)
     -> ::std::os::raw::c_int;
    pub fn rpmfiArchiveRead(fi: rpmfi, buf: *mut ::std::os::raw::c_void,
                            size: size_t) -> size_t;
    pub fn rpmfiArchiveHasContent(fi: rpmfi) -> ::std::os::raw::c_int;
    pub fn rpmfiArchiveReadToFile(fi: rpmfi, fd: FD_t,
                                  nodigest: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmfiLink(fi: rpmfi) -> rpmfi;
    pub fn rpmfiFC(fi: rpmfi) -> rpm_count_t;
    pub fn rpmfiFX(fi: rpmfi) -> ::std::os::raw::c_int;
    pub fn rpmfiSetFX(fi: rpmfi, fx: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmfiDC(fi: rpmfi) -> rpm_count_t;
    pub fn rpmfiDX(fi: rpmfi) -> ::std::os::raw::c_int;
    pub fn rpmfiSetDX(fi: rpmfi, dx: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmfiBN(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiDN(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiFN(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiFindFN(fi: rpmfi, _fn: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rpmfiOBN(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiODN(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiOFN(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiFindOFN(fi: rpmfi, _fn: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rpmfiFFlags(fi: rpmfi) -> rpmfileAttrs;
    pub fn rpmfiVFlags(fi: rpmfi) -> rpmVerifyAttrs;
    pub fn rpmfiFMode(fi: rpmfi) -> rpm_mode_t;
    pub fn rpmfiFState(fi: rpmfi) -> rpmfileState;
    pub fn rpmfiDigestAlgo(fi: rpmfi) -> ::std::os::raw::c_int;
    pub fn rpmfiFDigest(fi: rpmfi, algo: *mut ::std::os::raw::c_int,
                        diglen: *mut size_t)
     -> *const ::std::os::raw::c_uchar;
    pub fn rpmfiFDigestHex(fi: rpmfi, algo: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn rpmfiFSignature(fi: rpmfi, siglen: *mut size_t)
     -> *const ::std::os::raw::c_uchar;
    pub fn rpmfiMD5(fi: rpmfi) -> *const ::std::os::raw::c_uchar;
    pub fn rpmfiFLink(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiFSize(fi: rpmfi) -> rpm_loff_t;
    pub fn rpmfiFRdev(fi: rpmfi) -> rpm_rdev_t;
    pub fn rpmfiFInode(fi: rpmfi) -> rpm_ino_t;
    pub fn rpmfiColor(fi: rpmfi) -> rpm_color_t;
    pub fn rpmfiFColor(fi: rpmfi) -> rpm_color_t;
    pub fn rpmfiFClass(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiFDepends(fi: rpmfi, fddictp: *mut *const uint32_t)
     -> uint32_t;
    pub fn rpmfiFNlink(fi: rpmfi) -> uint32_t;
    pub fn rpmfiFLinks(fi: rpmfi, files: *mut *const ::std::os::raw::c_int)
     -> uint32_t;
    pub fn rpmfiFMtime(fi: rpmfi) -> rpm_time_t;
    pub fn rpmfiFUser(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiFGroup(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiFCaps(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiFLangs(fi: rpmfi) -> *const ::std::os::raw::c_char;
    pub fn rpmfiStat(fi: rpmfi, flags: ::std::os::raw::c_int,
                     sb: *mut Struct_stat) -> ::std::os::raw::c_int;
    pub fn rpmfiNext(fi: rpmfi) -> ::std::os::raw::c_int;
    pub fn rpmfiInit(fi: rpmfi, fx: ::std::os::raw::c_int) -> rpmfi;
    pub fn rpmfiNextD(fi: rpmfi) -> ::std::os::raw::c_int;
    pub fn rpmfiInitD(fi: rpmfi, dx: ::std::os::raw::c_int) -> rpmfi;
    pub fn rpmfiFree(fi: rpmfi) -> rpmfi;
    pub fn rpmfiNewPool(pool: rpmstrPool, h: Header, tagN: rpmTagVal,
                        flags: rpmfiFlags) -> rpmfi;
    pub fn rpmfiNew(ts: rpmts, h: Header, tagN: rpmTagVal, flags: rpmfiFlags)
     -> rpmfi;
    pub fn rpmfiWhatis(mode: rpm_mode_t) -> rpmFileTypes;
    pub fn rpmfiCompare(afi: rpmfi, bfi: rpmfi) -> ::std::os::raw::c_int;
    pub fn rpmfiDecideFate(ofi: rpmfi, nfi: rpmfi,
                           skipMissing: ::std::os::raw::c_int)
     -> rpmFileAction;
    pub fn rpmfiConfigConflict(fi: rpmfi) -> ::std::os::raw::c_int;
    pub fn rpmtsCheck(ts: rpmts) -> ::std::os::raw::c_int;
    pub fn rpmtsOrder(ts: rpmts) -> ::std::os::raw::c_int;
    pub fn rpmtsRun(ts: rpmts, okProbs: rpmps, ignoreSet: rpmprobFilterFlags)
     -> ::std::os::raw::c_int;
    pub fn rpmtsLink(ts: rpmts) -> rpmts;
    pub fn rpmtsCloseDB(ts: rpmts) -> ::std::os::raw::c_int;
    pub fn rpmtsOpenDB(ts: rpmts, dbmode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmtsInitDB(ts: rpmts, dbmode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmtsGetDBMode(ts: rpmts) -> ::std::os::raw::c_int;
    pub fn rpmtsSetDBMode(ts: rpmts, dbmode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmtsRebuildDB(ts: rpmts) -> ::std::os::raw::c_int;
    pub fn rpmtsVerifyDB(ts: rpmts) -> ::std::os::raw::c_int;
    pub fn rpmtsInitIterator(ts: rpmts, rpmtag: rpmDbiTagVal,
                             keyp: *const ::std::os::raw::c_void,
                             keylen: size_t) -> rpmdbMatchIterator;
    pub fn rpmtsImportHeader(txn: rpmtxn, h: Header, flags: rpmFlags)
     -> rpmRC;
    pub fn rpmtsImportPubkey(ts: rpmts, pkt: *const ::std::os::raw::c_uchar,
                             pktlen: size_t) -> rpmRC;
    pub fn rpmtsGetKeyring(ts: rpmts, autoload: ::std::os::raw::c_int)
     -> rpmKeyring;
    pub fn rpmtsSetKeyring(ts: rpmts, keyring: rpmKeyring)
     -> ::std::os::raw::c_int;
    pub fn rpmtsSetSolveCallback(ts: rpmts,
                                 solve:
                                     ::std::option::Option<unsafe extern "C" fn(ts:
                                                                                    rpmts,
                                                                                ds:
                                                                                    rpmds,
                                                                                data:
                                                                                    *const ::std::os::raw::c_void)
                                                               ->
                                                                   ::std::os::raw::c_int>,
                                 solveData: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn rpmtsProblems(ts: rpmts) -> rpmps;
    pub fn rpmtsCleanProblems(ts: rpmts);
    pub fn rpmtsClean(ts: rpmts);
    pub fn rpmtsEmpty(ts: rpmts);
    pub fn rpmtsFree(ts: rpmts) -> rpmts;
    pub fn rpmtsVSFlags(ts: rpmts) -> rpmVSFlags;
    pub fn rpmtsSetVSFlags(ts: rpmts, vsflags: rpmVSFlags) -> rpmVSFlags;
    pub fn rpmtsRootDir(ts: rpmts) -> *const ::std::os::raw::c_char;
    pub fn rpmtsSetRootDir(ts: rpmts, rootDir: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rpmtsScriptFd(ts: rpmts) -> FD_t;
    pub fn rpmtsSetScriptFd(ts: rpmts, scriptFd: FD_t);
    pub fn rpmtsGetTid(ts: rpmts) -> rpm_tid_t;
    pub fn rpmtsSetTid(ts: rpmts, tid: rpm_tid_t) -> rpm_tid_t;
    pub fn rpmtsGetRdb(ts: rpmts) -> rpmdb;
    pub fn rpmtsNotify(ts: rpmts, te: rpmte, what: rpmCallbackType,
                       amount: rpm_loff_t, total: rpm_loff_t)
     -> *mut ::std::os::raw::c_void;
    pub fn rpmtsNElements(ts: rpmts) -> ::std::os::raw::c_int;
    pub fn rpmtsElement(ts: rpmts, ix: ::std::os::raw::c_int) -> rpmte;
    pub fn rpmtsFilterFlags(ts: rpmts) -> rpmprobFilterFlags;
    pub fn rpmtsFlags(ts: rpmts) -> rpmtransFlags;
    pub fn rpmtsSetFlags(ts: rpmts, transFlags: rpmtransFlags)
     -> rpmtransFlags;
    pub fn rpmtsColor(ts: rpmts) -> rpm_color_t;
    pub fn rpmtsPrefColor(ts: rpmts) -> rpm_color_t;
    pub fn rpmtsSetColor(ts: rpmts, color: rpm_color_t) -> rpm_color_t;
    pub fn rpmtsSetPrefColor(ts: rpmts, color: rpm_color_t) -> rpm_color_t;
    pub fn rpmtsOp(ts: rpmts, opx: rpmtsOpX) -> rpmop;
    pub fn rpmtsPlugins(ts: rpmts) -> rpmPlugins;
    pub fn rpmtsSetNotifyCallback(ts: rpmts, notify: rpmCallbackFunction,
                                  notifyData: rpmCallbackData)
     -> ::std::os::raw::c_int;
    pub fn rpmtsCreate() -> rpmts;
    pub fn rpmtsAddInstallElement(ts: rpmts, h: Header, key: fnpyKey,
                                  upgrade: ::std::os::raw::c_int,
                                  relocs: *mut rpmRelocation)
     -> ::std::os::raw::c_int;
    pub fn rpmtsAddReinstallElement(ts: rpmts, h: Header, key: fnpyKey)
     -> ::std::os::raw::c_int;
    pub fn rpmtsAddEraseElement(ts: rpmts, h: Header,
                                dboffset: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn rpmtxnBegin(ts: rpmts, flags: rpmtxnFlags) -> rpmtxn;
    pub fn rpmtxnEnd(txn: rpmtxn) -> rpmtxn;
    pub fn rpmtsiFree(tsi: rpmtsi) -> rpmtsi;
    pub fn rpmtsiInit(ts: rpmts) -> rpmtsi;
    pub fn rpmtsiNext(tsi: rpmtsi, types: rpmElementTypes) -> rpmte;
    pub fn hif_rpmts_add_install_filename(ts: rpmts, filename: *const gchar,
                                          allow_untrusted: gboolean,
                                          is_update: gboolean,
                                          error: *mut *mut GError)
     -> gboolean;
    pub fn hif_rpmts_add_remove_pkg(ts: rpmts, pkg: *mut HifPackage,
                                    error: *mut *mut GError) -> gboolean;
    pub fn hif_rpmts_look_for_problems(ts: rpmts, error: *mut *mut GError)
     -> gboolean;
    pub fn hif_realpath(path: *const gchar) -> *mut gchar;
    pub fn hif_remove_recursive(directory: *const gchar,
                                error: *mut *mut GError) -> gboolean;
    pub fn hy_nevra_create() -> HyNevra;
    pub fn hy_nevra_free(nevra: HyNevra);
    pub fn hy_nevra_clone(nevra: HyNevra) -> HyNevra;
    pub fn hy_nevra_cmp(nevra1: HyNevra, nevra2: HyNevra)
     -> ::std::os::raw::c_int;
    pub fn hy_nevra_get_string(nevra: HyNevra, which: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn hy_nevra_get_epoch(nevra: HyNevra) -> ::std::os::raw::c_int;
    pub fn hy_nevra_set_epoch(nevra: HyNevra, epoch: ::std::os::raw::c_int);
    pub fn hy_nevra_set_string(nevra: HyNevra, which: ::std::os::raw::c_int,
                               str_val: *const ::std::os::raw::c_char);
    pub fn hy_nevra_to_query(nevra: HyNevra, sack: *mut HifSack) -> HyQuery;
    pub fn hy_nevra_evr_cmp(nevra1: HyNevra, nevra2: HyNevra,
                            sack: *mut HifSack) -> ::std::os::raw::c_int;
    pub fn hy_nevra_get_evr(nevra: HyNevra) -> *mut ::std::os::raw::c_char;
    pub fn hy_query_apply(q: HyQuery);
    pub fn hy_query_create(sack: *mut HifSack) -> HyQuery;
    pub fn hy_query_create_flags(sack: *mut HifSack,
                                 flags: ::std::os::raw::c_int) -> HyQuery;
    pub fn hy_query_free(q: HyQuery);
    pub fn hy_query_clear(q: HyQuery);
    pub fn hy_query_clone(q: HyQuery) -> HyQuery;
    pub fn hy_query_filter(q: HyQuery, keyname: ::std::os::raw::c_int,
                           cmp_type: ::std::os::raw::c_int,
                           _match: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hy_query_filter_empty(q: HyQuery) -> ::std::os::raw::c_int;
    pub fn hy_query_filter_in(q: HyQuery, keyname: ::std::os::raw::c_int,
                              cmp_type: ::std::os::raw::c_int,
                              matches: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hy_query_filter_num(q: HyQuery, keyname: ::std::os::raw::c_int,
                               cmp_type: ::std::os::raw::c_int,
                               _match: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn hy_query_filter_num_in(q: HyQuery, keyname: ::std::os::raw::c_int,
                                  cmp_type: ::std::os::raw::c_int,
                                  nmatches: ::std::os::raw::c_int,
                                  matches: *const ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn hy_query_filter_package_in(q: HyQuery,
                                      keyname: ::std::os::raw::c_int,
                                      cmp_type: ::std::os::raw::c_int,
                                      pset: *mut HifPackageSet)
     -> ::std::os::raw::c_int;
    pub fn hy_query_filter_reldep(q: HyQuery, keyname: ::std::os::raw::c_int,
                                  reldep: HyReldep) -> ::std::os::raw::c_int;
    pub fn hy_query_filter_reldep_in(q: HyQuery,
                                     keyname: ::std::os::raw::c_int,
                                     reldeplist: HyReldepList)
     -> ::std::os::raw::c_int;
    pub fn hy_query_filter_provides(q: HyQuery,
                                    cmp_type: ::std::os::raw::c_int,
                                    name: *const ::std::os::raw::c_char,
                                    evr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hy_query_filter_provides_in(q: HyQuery,
                                       reldep_strs:
                                           *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hy_query_filter_requires(q: HyQuery,
                                    cmp_type: ::std::os::raw::c_int,
                                    name: *const ::std::os::raw::c_char,
                                    evr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hy_query_filter_downgradable(q: HyQuery,
                                        val: ::std::os::raw::c_int);
    pub fn hy_query_filter_downgrades(q: HyQuery, val: ::std::os::raw::c_int);
    pub fn hy_query_filter_upgradable(q: HyQuery, val: ::std::os::raw::c_int);
    pub fn hy_query_filter_upgrades(q: HyQuery, val: ::std::os::raw::c_int);
    pub fn hy_query_filter_latest_per_arch(q: HyQuery,
                                           val: ::std::os::raw::c_int);
    pub fn hy_query_filter_latest(q: HyQuery, val: ::std::os::raw::c_int);
    pub fn hy_query_run(q: HyQuery) -> *mut GPtrArray;
    pub fn hy_query_run_set(q: HyQuery) -> *mut HifPackageSet;
    pub fn hy_reldep_create(sack: *mut HifSack,
                            name: *const ::std::os::raw::c_char,
                            cmp_type: ::std::os::raw::c_int,
                            evr: *const ::std::os::raw::c_char) -> HyReldep;
    pub fn hy_reldep_free(reldep: HyReldep);
    pub fn hy_reldep_clone(reldep: HyReldep) -> HyReldep;
    pub fn hy_reldep_str(reldep: HyReldep) -> *mut ::std::os::raw::c_char;
    pub fn hy_reldeplist_create(sack: *mut HifSack) -> HyReldepList;
    pub fn hy_reldeplist_free(reldeplist: HyReldepList);
    pub fn hy_reldeplist_add(reldeplist: HyReldepList, reldep: HyReldep);
    pub fn hy_reldeplist_count(reldeplist: HyReldepList)
     -> ::std::os::raw::c_int;
    pub fn hy_reldeplist_get_clone(reldeplist: HyReldepList,
                                   index: ::std::os::raw::c_int) -> HyReldep;
    pub fn hy_selector_create(sack: *mut HifSack) -> HySelector;
    pub fn hy_selector_free(sltr: HySelector);
    pub fn hy_selector_set(sltr: HySelector, keyname: ::std::os::raw::c_int,
                           cmp_type: ::std::os::raw::c_int,
                           _match: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hy_selector_matches(sltr: HySelector) -> *mut GPtrArray;
    pub fn solv_malloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
    pub fn solv_malloc2(arg1: size_t, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn solv_calloc(arg1: size_t, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn solv_realloc(arg1: *mut ::std::os::raw::c_void, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn solv_realloc2(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                         arg3: size_t) -> *mut ::std::os::raw::c_void;
    pub fn solv_extend_realloc(arg1: *mut ::std::os::raw::c_void,
                               arg2: size_t, arg3: size_t, arg4: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn solv_free(arg1: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn solv_strdup(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn solv_oom(arg1: size_t, arg2: size_t);
    pub fn solv_timems(subtract: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
    pub fn solv_sort(base: *mut ::std::os::raw::c_void, nmemb: size_t,
                     size: size_t,
                     compar:
                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *const ::std::os::raw::c_void,
                                                                    arg2:
                                                                        *const ::std::os::raw::c_void,
                                                                    arg3:
                                                                        *mut ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>,
                     compard: *mut ::std::os::raw::c_void);
    pub fn solv_dupjoin(str1: *const ::std::os::raw::c_char,
                        str2: *const ::std::os::raw::c_char,
                        str3: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn solv_dupappend(str1: *const ::std::os::raw::c_char,
                          str2: *const ::std::os::raw::c_char,
                          str3: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn solv_hex2bin(strp: *mut *const ::std::os::raw::c_char,
                        buf: *mut ::std::os::raw::c_uchar,
                        bufl: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn solv_bin2hex(buf: *const ::std::os::raw::c_uchar,
                        l: ::std::os::raw::c_int,
                        str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn solv_validutf8(buf: *const ::std::os::raw::c_char) -> size_t;
    pub fn solv_latin1toutf8(buf: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn solv_replacebadutf8(buf: *const ::std::os::raw::c_char,
                               replchar: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn hy_subject_create(pattern: *const ::std::os::raw::c_char)
     -> HySubject;
    pub fn hy_subject_free(subject: HySubject);
    pub fn hy_possibilities_free(iter: HyPossibilities);
    pub fn hy_subject_reldep_possibilities_real(subject: HySubject,
                                                sack: *mut HifSack,
                                                flags: ::std::os::raw::c_int)
     -> HyPossibilities;
    pub fn hy_possibilities_next_reldep(iter: HyPossibilities,
                                        out_reldep: *mut HyReldep)
     -> ::std::os::raw::c_int;
    pub fn hy_subject_nevra_possibilities(subject: HySubject,
                                          forms: *mut HyForm)
     -> HyPossibilities;
    pub fn hy_subject_nevra_possibilities_real(subject: HySubject,
                                               forms: *mut HyForm,
                                               sack: *mut HifSack,
                                               flags: ::std::os::raw::c_int)
     -> HyPossibilities;
    pub fn hy_possibilities_next_nevra(iter: HyPossibilities,
                                       out_nevra: *mut HyNevra)
     -> ::std::os::raw::c_int;
    pub fn hy_chksum_name(chksum_type: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn hy_chksum_type(chksum_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hy_chksum_str(chksum: *const ::std::os::raw::c_uchar,
                         _type: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn hy_detect_arch(arch: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hy_split_nevra(nevra: *const ::std::os::raw::c_char,
                          name: *mut *mut ::std::os::raw::c_char,
                          epoch: *mut ::std::os::raw::c_long,
                          version: *mut *mut ::std::os::raw::c_char,
                          release: *mut *mut ::std::os::raw::c_char,
                          arch: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn hy_packagelist_create() -> *mut GPtrArray;
    pub fn hy_packagelist_has(plist: *mut GPtrArray, pkg: *mut HifPackage)
     -> ::std::os::raw::c_int;
}
